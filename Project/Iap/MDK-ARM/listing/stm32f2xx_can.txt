; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stm32f2xx_can.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\stm32f2xx_can.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\Inc -I..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Pfm6Ctrl\inc\app -I..\..\Pfm6Ctrl\src\wifi -I..\..\..\Utilities\FatFs_R0.09a -I.\RTE\_iap...PFM6 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -D__PFM6__ -DHSE_VALUE=25000000 -DWITH_COM_PORT --omf_browse=.\output\stm32f2xx_can.crf ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_can.c]
                          THUMB

                          AREA ||i.CAN_CancelTransmit||, CODE, READONLY, ALIGN=1

                  CAN_CancelTransmit PROC
;;;703      */
;;;704    void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
000000  b121              CBZ      r1,|L1.12|
;;;705    {
;;;706      /* Check the parameters */
;;;707      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;708      assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
;;;709      /* abort transmission */
;;;710      switch (Mailbox)
000002  2901              CMP      r1,#1
000004  d007              BEQ      |L1.22|
000006  2902              CMP      r1,#2
000008  d10f              BNE      |L1.42|
00000a  e009              B        |L1.32|
                  |L1.12|
;;;711      {
;;;712        case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
00000c  6882              LDR      r2,[r0,#8]
00000e  f0420280          ORR      r2,r2,#0x80
000012  6082              STR      r2,[r0,#8]
;;;713          break;
000014  e00a              B        |L1.44|
                  |L1.22|
;;;714        case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
000016  6882              LDR      r2,[r0,#8]
000018  f4424200          ORR      r2,r2,#0x8000
00001c  6082              STR      r2,[r0,#8]
;;;715          break;
00001e  e005              B        |L1.44|
                  |L1.32|
;;;716        case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
000020  6882              LDR      r2,[r0,#8]
000022  f4420200          ORR      r2,r2,#0x800000
000026  6082              STR      r2,[r0,#8]
;;;717          break;
000028  e000              B        |L1.44|
                  |L1.42|
;;;718        default:
;;;719          break;
00002a  bf00              NOP      
                  |L1.44|
00002c  bf00              NOP                            ;713
;;;720      }
;;;721    }
00002e  4770              BX       lr
;;;722    /**
                          ENDP


                          AREA ||i.CAN_ClearFlag||, CODE, READONLY, ALIGN=2

                  CAN_ClearFlag PROC
;;;1432     */
;;;1433   void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  2200              MOVS     r2,#0
;;;1434   {
;;;1435     uint32_t flagtmp=0;
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1438     assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
;;;1439     
;;;1440     if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
000002  4b0c              LDR      r3,|L2.52|
000004  4299              CMP      r1,r3
000006  d102              BNE      |L2.14|
;;;1441     {
;;;1442       /* Clear the selected CAN flags */
;;;1443       CANx->ESR = (uint32_t)RESET;
000008  2300              MOVS     r3,#0
00000a  6183              STR      r3,[r0,#0x18]
00000c  e011              B        |L2.50|
                  |L2.14|
;;;1444     }
;;;1445     else /* MSR or TSR or RF0R or RF1R */
;;;1446     {
;;;1447       flagtmp = CAN_FLAG & 0x000FFFFF;
00000e  f3c10213          UBFX     r2,r1,#0,#20
;;;1448   
;;;1449       if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
000012  f0017300          AND      r3,r1,#0x2000000
000016  b10b              CBZ      r3,|L2.28|
;;;1450       {
;;;1451         /* Receive Flags */
;;;1452         CANx->RF0R = (uint32_t)(flagtmp);
000018  60c2              STR      r2,[r0,#0xc]
00001a  e00a              B        |L2.50|
                  |L2.28|
;;;1453       }
;;;1454       else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
00001c  f0016380          AND      r3,r1,#0x4000000
000020  b10b              CBZ      r3,|L2.38|
;;;1455       {
;;;1456         /* Receive Flags */
;;;1457         CANx->RF1R = (uint32_t)(flagtmp);
000022  6102              STR      r2,[r0,#0x10]
000024  e005              B        |L2.50|
                  |L2.38|
;;;1458       }
;;;1459       else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
000026  f0016300          AND      r3,r1,#0x8000000
00002a  b10b              CBZ      r3,|L2.48|
;;;1460       {
;;;1461         /* Transmit Flags */
;;;1462         CANx->TSR = (uint32_t)(flagtmp);
00002c  6082              STR      r2,[r0,#8]
00002e  e000              B        |L2.50|
                  |L2.48|
;;;1463       }
;;;1464       else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
;;;1465       {
;;;1466         /* Operating mode Flags */
;;;1467         CANx->MSR = (uint32_t)(flagtmp);
000030  6042              STR      r2,[r0,#4]
                  |L2.50|
;;;1468       }
;;;1469     }
;;;1470   }
000032  4770              BX       lr
;;;1471   
                          ENDP

                  |L2.52|
                          DCD      0x30f00070

                          AREA ||i.CAN_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CAN_ClearITPendingBit PROC
;;;1596     */
;;;1597   void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  f5b17f00          CMP      r1,#0x200
;;;1598   {
;;;1599     /* Check the parameters */
;;;1600     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1601     assert_param(IS_CAN_CLEAR_IT(CAN_IT));
;;;1602   
;;;1603     switch (CAN_IT)
000004  d03a              BEQ      |L3.124|
000006  dc0f              BGT      |L3.40|
000008  2920              CMP      r1,#0x20
00000a  d028              BEQ      |L3.94|
00000c  dc06              BGT      |L3.28|
00000e  2901              CMP      r1,#1
000010  d01c              BEQ      |L3.76|
000012  2904              CMP      r1,#4
000014  d01d              BEQ      |L3.82|
000016  2908              CMP      r1,#8
000018  d140              BNE      |L3.156|
00001a  e01d              B        |L3.88|
                  |L3.28|
00001c  2940              CMP      r1,#0x40
00001e  d021              BEQ      |L3.100|
000020  f5b17f80          CMP      r1,#0x100
000024  d13a              BNE      |L3.156|
000026  e026              B        |L3.118|
                  |L3.40|
000028  f5b14f00          CMP      r1,#0x8000
00002c  d031              BEQ      |L3.146|
00002e  dc06              BGT      |L3.62|
000030  f5b16f80          CMP      r1,#0x400
000034  d025              BEQ      |L3.130|
000036  f5b16f00          CMP      r1,#0x800
00003a  d12f              BNE      |L3.156|
00003c  e024              B        |L3.136|
                  |L3.62|
00003e  f5b13f80          CMP      r1,#0x10000
000042  d012              BEQ      |L3.106|
000044  f5b13f00          CMP      r1,#0x20000
000048  d128              BNE      |L3.156|
00004a  e011              B        |L3.112|
                  |L3.76|
;;;1604     {
;;;1605       case CAN_IT_TME:
;;;1606         /* Clear CAN_TSR_RQCPx (rc_w1)*/
;;;1607         CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
00004c  4a15              LDR      r2,|L3.164|
00004e  6082              STR      r2,[r0,#8]
;;;1608         break;
000050  e025              B        |L3.158|
                  |L3.82|
;;;1609       case CAN_IT_FF0:
;;;1610         /* Clear CAN_RF0R_FULL0 (rc_w1)*/
;;;1611         CANx->RF0R = CAN_RF0R_FULL0; 
000052  2208              MOVS     r2,#8
000054  60c2              STR      r2,[r0,#0xc]
;;;1612         break;
000056  e022              B        |L3.158|
                  |L3.88|
;;;1613       case CAN_IT_FOV0:
;;;1614         /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
;;;1615         CANx->RF0R = CAN_RF0R_FOVR0; 
000058  2210              MOVS     r2,#0x10
00005a  60c2              STR      r2,[r0,#0xc]
;;;1616         break;
00005c  e01f              B        |L3.158|
                  |L3.94|
;;;1617       case CAN_IT_FF1:
;;;1618         /* Clear CAN_RF1R_FULL1 (rc_w1)*/
;;;1619         CANx->RF1R = CAN_RF1R_FULL1;  
00005e  2208              MOVS     r2,#8
000060  6102              STR      r2,[r0,#0x10]
;;;1620         break;
000062  e01c              B        |L3.158|
                  |L3.100|
;;;1621       case CAN_IT_FOV1:
;;;1622         /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
;;;1623         CANx->RF1R = CAN_RF1R_FOVR1; 
000064  2210              MOVS     r2,#0x10
000066  6102              STR      r2,[r0,#0x10]
;;;1624         break;
000068  e019              B        |L3.158|
                  |L3.106|
;;;1625       case CAN_IT_WKU:
;;;1626         /* Clear CAN_MSR_WKUI (rc_w1)*/
;;;1627         CANx->MSR = CAN_MSR_WKUI;  
00006a  2208              MOVS     r2,#8
00006c  6042              STR      r2,[r0,#4]
;;;1628         break;
00006e  e016              B        |L3.158|
                  |L3.112|
;;;1629       case CAN_IT_SLK:
;;;1630         /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
;;;1631         CANx->MSR = CAN_MSR_SLAKI;   
000070  2210              MOVS     r2,#0x10
000072  6042              STR      r2,[r0,#4]
;;;1632         break;
000074  e013              B        |L3.158|
                  |L3.118|
;;;1633       case CAN_IT_EWG:
;;;1634         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1635         CANx->MSR = CAN_MSR_ERRI;
000076  2204              MOVS     r2,#4
000078  6042              STR      r2,[r0,#4]
;;;1636          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
;;;1637         break;
00007a  e010              B        |L3.158|
                  |L3.124|
;;;1638       case CAN_IT_EPV:
;;;1639         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1640         CANx->MSR = CAN_MSR_ERRI; 
00007c  2204              MOVS     r2,#4
00007e  6042              STR      r2,[r0,#4]
;;;1641          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1642         break;
000080  e00d              B        |L3.158|
                  |L3.130|
;;;1643       case CAN_IT_BOF:
;;;1644         /* Clear CAN_MSR_ERRI (rc_w1) */ 
;;;1645         CANx->MSR = CAN_MSR_ERRI; 
000082  2204              MOVS     r2,#4
000084  6042              STR      r2,[r0,#4]
;;;1646          /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
;;;1647          break;
000086  e00a              B        |L3.158|
                  |L3.136|
;;;1648       case CAN_IT_LEC:
;;;1649         /*  Clear LEC bits */
;;;1650         CANx->ESR = RESET; 
000088  2200              MOVS     r2,#0
00008a  6182              STR      r2,[r0,#0x18]
;;;1651         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1652         CANx->MSR = CAN_MSR_ERRI; 
00008c  2204              MOVS     r2,#4
00008e  6042              STR      r2,[r0,#4]
;;;1653         break;
000090  e005              B        |L3.158|
                  |L3.146|
;;;1654       case CAN_IT_ERR:
;;;1655         /*Clear LEC bits */
;;;1656         CANx->ESR = RESET; 
000092  2200              MOVS     r2,#0
000094  6182              STR      r2,[r0,#0x18]
;;;1657         /* Clear CAN_MSR_ERRI (rc_w1) */
;;;1658         CANx->MSR = CAN_MSR_ERRI; 
000096  2204              MOVS     r2,#4
000098  6042              STR      r2,[r0,#4]
;;;1659          /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
;;;1660          break;
00009a  e000              B        |L3.158|
                  |L3.156|
;;;1661       default:
;;;1662          break;
00009c  bf00              NOP      
                  |L3.158|
00009e  bf00              NOP                            ;1608
;;;1663      }
;;;1664   }
0000a0  4770              BX       lr
;;;1665    /**
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      0x00010101

                          AREA ||i.CAN_DBGFreeze||, CODE, READONLY, ALIGN=1

                  CAN_DBGFreeze PROC
;;;493      */
;;;494    void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;495    {
;;;496      /* Check the parameters */
;;;497      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;498      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;499      
;;;500      if (NewState != DISABLE)
;;;501      {
;;;502        /* Enable Debug Freeze  */
;;;503        CANx->MCR |= MCR_DBF;
000002  6802              LDR      r2,[r0,#0]
000004  f4423280          ORR      r2,r2,#0x10000
000008  6002              STR      r2,[r0,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;504      }
;;;505      else
;;;506      {
;;;507        /* Disable Debug Freeze */
;;;508        CANx->MCR &= ~MCR_DBF;
00000c  6802              LDR      r2,[r0,#0]
00000e  f4223280          BIC      r2,r2,#0x10000
000012  6002              STR      r2,[r0,#0]
                  |L4.20|
;;;509      }
;;;510    }
000014  4770              BX       lr
;;;511    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=2

                  CAN_DeInit PROC
;;;167      */
;;;168    void CAN_DeInit(CAN_TypeDef* CANx)
000000  b510              PUSH     {r4,lr}
;;;169    {
000002  4604              MOV      r4,r0
;;;170      /* Check the parameters */
;;;171      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;172     
;;;173      if (CANx == CAN1)
000004  480b              LDR      r0,|L5.52|
000006  4284              CMP      r4,r0
000008  d109              BNE      |L5.30|
;;;174      {
;;;175        /* Enable CAN1 reset state */
;;;176        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;177        /* Release CAN1 from reset state */
;;;178        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN1, DISABLE);
000012  2100              MOVS     r1,#0
000014  f04f7000          MOV      r0,#0x2000000
000018  f7fffffe          BL       RCC_APB1PeriphResetCmd
00001c  e008              B        |L5.48|
                  |L5.30|
;;;179      }
;;;180      else
;;;181      {  
;;;182        /* Enable CAN2 reset state */
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, ENABLE);
00001e  2101              MOVS     r1,#1
000020  0688              LSLS     r0,r1,#26
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184        /* Release CAN2 from reset state */
;;;185        RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN2, DISABLE);
000026  2100              MOVS     r1,#0
000028  f04f6080          MOV      r0,#0x4000000
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L5.48|
;;;186      }
;;;187    }
000030  bd10              POP      {r4,pc}
;;;188    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      0x40006400

                          AREA ||i.CAN_FIFORelease||, CODE, READONLY, ALIGN=1

                  CAN_FIFORelease PROC
;;;799      */
;;;800    void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  b921              CBNZ     r1,|L6.12|
;;;801    {
;;;802      /* Check the parameters */
;;;803      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;804      assert_param(IS_CAN_FIFO(FIFONumber));
;;;805      /* Release FIFO0 */
;;;806      if (FIFONumber == CAN_FIFO0)
;;;807      {
;;;808        CANx->RF0R |= CAN_RF0R_RFOM0;
000002  68c2              LDR      r2,[r0,#0xc]
000004  f0420220          ORR      r2,r2,#0x20
000008  60c2              STR      r2,[r0,#0xc]
00000a  e003              B        |L6.20|
                  |L6.12|
;;;809      }
;;;810      /* Release FIFO1 */
;;;811      else /* FIFONumber == CAN_FIFO1 */
;;;812      {
;;;813        CANx->RF1R |= CAN_RF1R_RFOM1;
00000c  6902              LDR      r2,[r0,#0x10]
00000e  f0420220          ORR      r2,r2,#0x20
000012  6102              STR      r2,[r0,#0x10]
                  |L6.20|
;;;814      }
;;;815    }
000014  4770              BX       lr
;;;816    
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=2

                  CAN_FilterInit PROC
;;;334      */
;;;335    void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;336    {
;;;337      uint32_t filter_number_bit_pos = 0;
000002  2100              MOVS     r1,#0
;;;338      /* Check the parameters */
;;;339      assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
;;;340      assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
;;;341      assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
;;;342      assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
;;;343      assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
;;;344    
;;;345      filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
000004  7a83              LDRB     r3,[r0,#0xa]
000006  2201              MOVS     r2,#1
000008  fa02f103          LSL      r1,r2,r3
;;;346    
;;;347      /* Initialisation mode for the filter */
;;;348      CAN1->FMR |= FMR_FINIT;
00000c  4a3d              LDR      r2,|L7.260|
00000e  6812              LDR      r2,[r2,#0]
000010  f0420201          ORR      r2,r2,#1
000014  4b3b              LDR      r3,|L7.260|
000016  601a              STR      r2,[r3,#0]
;;;349    
;;;350      /* Filter Deactivation */
;;;351      CAN1->FA1R &= ~(uint32_t)filter_number_bit_pos;
000018  4a3a              LDR      r2,|L7.260|
00001a  321c              ADDS     r2,r2,#0x1c
00001c  6812              LDR      r2,[r2,#0]
00001e  438a              BICS     r2,r2,r1
000020  4b38              LDR      r3,|L7.260|
000022  331c              ADDS     r3,r3,#0x1c
000024  601a              STR      r2,[r3,#0]
;;;352    
;;;353      /* Filter Scale */
;;;354      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
000026  7b02              LDRB     r2,[r0,#0xc]
000028  b9ca              CBNZ     r2,|L7.94|
;;;355      {
;;;356        /* 16-bit scale for the filter */
;;;357        CAN1->FS1R &= ~(uint32_t)filter_number_bit_pos;
00002a  4a36              LDR      r2,|L7.260|
00002c  320c              ADDS     r2,r2,#0xc
00002e  6812              LDR      r2,[r2,#0]
000030  438a              BICS     r2,r2,r1
000032  4b34              LDR      r3,|L7.260|
000034  330c              ADDS     r3,r3,#0xc
000036  601a              STR      r2,[r3,#0]
;;;358    
;;;359        /* First 16-bit identifier and First 16-bit mask */
;;;360        /* Or First 16-bit identifier and Second 16-bit identifier */
;;;361        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000038  8842              LDRH     r2,[r0,#2]
00003a  88c3              LDRH     r3,[r0,#6]
00003c  ea424303          ORR      r3,r2,r3,LSL #16
000040  4a30              LDR      r2,|L7.260|
000042  3240              ADDS     r2,r2,#0x40
000044  7a84              LDRB     r4,[r0,#0xa]
000046  f8423034          STR      r3,[r2,r4,LSL #3]
;;;362           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
;;;363            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;364    
;;;365        /* Second 16-bit identifier and Second 16-bit mask */
;;;366        /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;367        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
00004a  8802              LDRH     r2,[r0,#0]
00004c  8883              LDRH     r3,[r0,#4]
00004e  ea424303          ORR      r3,r2,r3,LSL #16
000052  4a2c              LDR      r2,|L7.260|
000054  3240              ADDS     r2,r2,#0x40
000056  7a84              LDRB     r4,[r0,#0xa]
000058  eb0202c4          ADD      r2,r2,r4,LSL #3
00005c  6053              STR      r3,[r2,#4]
                  |L7.94|
;;;368           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;369            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
;;;370      }
;;;371    
;;;372      if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
00005e  7b02              LDRB     r2,[r0,#0xc]
000060  2a01              CMP      r2,#1
000062  d119              BNE      |L7.152|
;;;373      {
;;;374        /* 32-bit scale for the filter */
;;;375        CAN1->FS1R |= filter_number_bit_pos;
000064  4a27              LDR      r2,|L7.260|
000066  320c              ADDS     r2,r2,#0xc
000068  6812              LDR      r2,[r2,#0]
00006a  430a              ORRS     r2,r2,r1
00006c  4b25              LDR      r3,|L7.260|
00006e  330c              ADDS     r3,r3,#0xc
000070  601a              STR      r2,[r3,#0]
;;;376        /* 32-bit identifier or First 32-bit identifier */
;;;377        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
000072  8842              LDRH     r2,[r0,#2]
000074  8803              LDRH     r3,[r0,#0]
000076  ea424303          ORR      r3,r2,r3,LSL #16
00007a  4a22              LDR      r2,|L7.260|
00007c  3240              ADDS     r2,r2,#0x40
00007e  7a84              LDRB     r4,[r0,#0xa]
000080  f8423034          STR      r3,[r2,r4,LSL #3]
;;;378           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
;;;379            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
;;;380        /* 32-bit mask or Second 32-bit identifier */
;;;381        CAN1->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
000084  88c2              LDRH     r2,[r0,#6]
000086  8883              LDRH     r3,[r0,#4]
000088  ea424303          ORR      r3,r2,r3,LSL #16
00008c  4a1d              LDR      r2,|L7.260|
00008e  3240              ADDS     r2,r2,#0x40
000090  7a84              LDRB     r4,[r0,#0xa]
000092  eb0202c4          ADD      r2,r2,r4,LSL #3
000096  6053              STR      r3,[r2,#4]
                  |L7.152|
;;;382           ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
;;;383            (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
;;;384      }
;;;385    
;;;386      /* Filter Mode */
;;;387      if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
000098  7ac2              LDRB     r2,[r0,#0xb]
00009a  b93a              CBNZ     r2,|L7.172|
;;;388      {
;;;389        /*Id/Mask mode for the filter*/
;;;390        CAN1->FM1R &= ~(uint32_t)filter_number_bit_pos;
00009c  4a19              LDR      r2,|L7.260|
00009e  1d12              ADDS     r2,r2,#4
0000a0  6812              LDR      r2,[r2,#0]
0000a2  438a              BICS     r2,r2,r1
0000a4  4b17              LDR      r3,|L7.260|
0000a6  1d1b              ADDS     r3,r3,#4
0000a8  601a              STR      r2,[r3,#0]
0000aa  e006              B        |L7.186|
                  |L7.172|
;;;391      }
;;;392      else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;393      {
;;;394        /*Identifier list mode for the filter*/
;;;395        CAN1->FM1R |= (uint32_t)filter_number_bit_pos;
0000ac  4a15              LDR      r2,|L7.260|
0000ae  1d12              ADDS     r2,r2,#4
0000b0  6812              LDR      r2,[r2,#0]
0000b2  430a              ORRS     r2,r2,r1
0000b4  4b13              LDR      r3,|L7.260|
0000b6  1d1b              ADDS     r3,r3,#4
0000b8  601a              STR      r2,[r3,#0]
                  |L7.186|
;;;396      }
;;;397    
;;;398      /* Filter FIFO assignment */
;;;399      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
0000ba  8902              LDRH     r2,[r0,#8]
0000bc  b932              CBNZ     r2,|L7.204|
;;;400      {
;;;401        /* FIFO 0 assignation for the filter */
;;;402        CAN1->FFA1R &= ~(uint32_t)filter_number_bit_pos;
0000be  4a11              LDR      r2,|L7.260|
0000c0  3214              ADDS     r2,r2,#0x14
0000c2  6812              LDR      r2,[r2,#0]
0000c4  438a              BICS     r2,r2,r1
0000c6  4b0f              LDR      r3,|L7.260|
0000c8  3314              ADDS     r3,r3,#0x14
0000ca  601a              STR      r2,[r3,#0]
                  |L7.204|
;;;403      }
;;;404    
;;;405      if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
0000cc  8902              LDRH     r2,[r0,#8]
0000ce  2a01              CMP      r2,#1
0000d0  d106              BNE      |L7.224|
;;;406      {
;;;407        /* FIFO 1 assignation for the filter */
;;;408        CAN1->FFA1R |= (uint32_t)filter_number_bit_pos;
0000d2  4a0c              LDR      r2,|L7.260|
0000d4  3214              ADDS     r2,r2,#0x14
0000d6  6812              LDR      r2,[r2,#0]
0000d8  430a              ORRS     r2,r2,r1
0000da  4b0a              LDR      r3,|L7.260|
0000dc  3314              ADDS     r3,r3,#0x14
0000de  601a              STR      r2,[r3,#0]
                  |L7.224|
;;;409      }
;;;410      
;;;411      /* Filter activation */
;;;412      if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
0000e0  7b42              LDRB     r2,[r0,#0xd]
0000e2  2a01              CMP      r2,#1
0000e4  d106              BNE      |L7.244|
;;;413      {
;;;414        CAN1->FA1R |= filter_number_bit_pos;
0000e6  4a07              LDR      r2,|L7.260|
0000e8  321c              ADDS     r2,r2,#0x1c
0000ea  6812              LDR      r2,[r2,#0]
0000ec  430a              ORRS     r2,r2,r1
0000ee  4b05              LDR      r3,|L7.260|
0000f0  331c              ADDS     r3,r3,#0x1c
0000f2  601a              STR      r2,[r3,#0]
                  |L7.244|
;;;415      }
;;;416    
;;;417      /* Leave the initialisation mode for the filter */
;;;418      CAN1->FMR &= ~FMR_FINIT;
0000f4  4a03              LDR      r2,|L7.260|
0000f6  6812              LDR      r2,[r2,#0]
0000f8  f0220201          BIC      r2,r2,#1
0000fc  4b01              LDR      r3,|L7.260|
0000fe  601a              STR      r2,[r3,#0]
;;;419    }
000100  bd10              POP      {r4,pc}
;;;420    
                          ENDP

000102  0000              DCW      0x0000
                  |L7.260|
                          DCD      0x40006600

                          AREA ||i.CAN_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetFlagStatus PROC
;;;1332     */
;;;1333   FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1334   {
000002  4602              MOV      r2,r0
;;;1335     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1336     
;;;1337     /* Check the parameters */
;;;1338     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1339     assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
;;;1340     
;;;1341   
;;;1342     if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
000006  f4010370          AND      r3,r1,#0xf00000
00000a  b143              CBZ      r3,|L8.30|
;;;1343     { 
;;;1344       /* Check the status of the specified CAN flag */
;;;1345       if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00000c  6993              LDR      r3,[r2,#0x18]
00000e  f3c10413          UBFX     r4,r1,#0,#20
000012  4023              ANDS     r3,r3,r4
000014  b10b              CBZ      r3,|L8.26|
;;;1346       { 
;;;1347         /* CAN_FLAG is set */
;;;1348         bitstatus = SET;
000016  2001              MOVS     r0,#1
000018  e02d              B        |L8.118|
                  |L8.26|
;;;1349       }
;;;1350       else
;;;1351       { 
;;;1352         /* CAN_FLAG is reset */
;;;1353         bitstatus = RESET;
00001a  2000              MOVS     r0,#0
00001c  e02b              B        |L8.118|
                  |L8.30|
;;;1354       }
;;;1355     }
;;;1356     else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
00001e  f0017380          AND      r3,r1,#0x1000000
000022  b143              CBZ      r3,|L8.54|
;;;1357     { 
;;;1358       /* Check the status of the specified CAN flag */
;;;1359       if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000024  6853              LDR      r3,[r2,#4]
000026  f3c10413          UBFX     r4,r1,#0,#20
00002a  4023              ANDS     r3,r3,r4
00002c  b10b              CBZ      r3,|L8.50|
;;;1360       { 
;;;1361         /* CAN_FLAG is set */
;;;1362         bitstatus = SET;
00002e  2001              MOVS     r0,#1
000030  e021              B        |L8.118|
                  |L8.50|
;;;1363       }
;;;1364       else
;;;1365       { 
;;;1366         /* CAN_FLAG is reset */
;;;1367         bitstatus = RESET;
000032  2000              MOVS     r0,#0
000034  e01f              B        |L8.118|
                  |L8.54|
;;;1368       }
;;;1369     }
;;;1370     else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
000036  f0016300          AND      r3,r1,#0x8000000
00003a  b143              CBZ      r3,|L8.78|
;;;1371     { 
;;;1372       /* Check the status of the specified CAN flag */
;;;1373       if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
00003c  6893              LDR      r3,[r2,#8]
00003e  f3c10413          UBFX     r4,r1,#0,#20
000042  4023              ANDS     r3,r3,r4
000044  b10b              CBZ      r3,|L8.74|
;;;1374       { 
;;;1375         /* CAN_FLAG is set */
;;;1376         bitstatus = SET;
000046  2001              MOVS     r0,#1
000048  e015              B        |L8.118|
                  |L8.74|
;;;1377       }
;;;1378       else
;;;1379       { 
;;;1380         /* CAN_FLAG is reset */
;;;1381         bitstatus = RESET;
00004a  2000              MOVS     r0,#0
00004c  e013              B        |L8.118|
                  |L8.78|
;;;1382       }
;;;1383     }
;;;1384     else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
00004e  f0017300          AND      r3,r1,#0x2000000
000052  b143              CBZ      r3,|L8.102|
;;;1385     { 
;;;1386       /* Check the status of the specified CAN flag */
;;;1387       if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000054  68d3              LDR      r3,[r2,#0xc]
000056  f3c10413          UBFX     r4,r1,#0,#20
00005a  4023              ANDS     r3,r3,r4
00005c  b10b              CBZ      r3,|L8.98|
;;;1388       { 
;;;1389         /* CAN_FLAG is set */
;;;1390         bitstatus = SET;
00005e  2001              MOVS     r0,#1
000060  e009              B        |L8.118|
                  |L8.98|
;;;1391       }
;;;1392       else
;;;1393       { 
;;;1394         /* CAN_FLAG is reset */
;;;1395         bitstatus = RESET;
000062  2000              MOVS     r0,#0
000064  e007              B        |L8.118|
                  |L8.102|
;;;1396       }
;;;1397     }
;;;1398     else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
;;;1399     { 
;;;1400       /* Check the status of the specified CAN flag */
;;;1401       if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
000066  6913              LDR      r3,[r2,#0x10]
000068  f3c10413          UBFX     r4,r1,#0,#20
00006c  4023              ANDS     r3,r3,r4
00006e  b10b              CBZ      r3,|L8.116|
;;;1402       { 
;;;1403         /* CAN_FLAG is set */
;;;1404         bitstatus = SET;
000070  2001              MOVS     r0,#1
000072  e000              B        |L8.118|
                  |L8.116|
;;;1405       }
;;;1406       else
;;;1407       { 
;;;1408         /* CAN_FLAG is reset */
;;;1409         bitstatus = RESET;
000074  2000              MOVS     r0,#0
                  |L8.118|
;;;1410       }
;;;1411     }
;;;1412     /* Return the CAN_FLAG status */
;;;1413     return  bitstatus;
;;;1414   }
000076  bd10              POP      {r4,pc}
;;;1415   
                          ENDP


                          AREA ||i.CAN_GetITStatus||, CODE, READONLY, ALIGN=2

                  CAN_GetITStatus PROC
;;;1492     */
;;;1493   ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;1494   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1495     ITStatus itstatus = RESET;
000006  2600              MOVS     r6,#0
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1498     assert_param(IS_CAN_IT(CAN_IT));
;;;1499     
;;;1500     /* check the interrupt enable bit */
;;;1501    if((CANx->IER & CAN_IT) != RESET)
000008  6960              LDR      r0,[r4,#0x14]
00000a  4028              ANDS     r0,r0,r5
00000c  2800              CMP      r0,#0
00000e  d071              BEQ      |L9.244|
;;;1502    {
;;;1503      /* in case the Interrupt is enabled, .... */
;;;1504       switch (CAN_IT)
000010  f5b57f80          CMP      r5,#0x100
000014  d05c              BEQ      |L9.208|
000016  dc10              BGT      |L9.58|
000018  2d08              CMP      r5,#8
00001a  d035              BEQ      |L9.136|
00001c  dc06              BGT      |L9.44|
00001e  2d01              CMP      r5,#1
000020  d020              BEQ      |L9.100|
000022  2d02              CMP      r5,#2
000024  d024              BEQ      |L9.112|
000026  2d04              CMP      r5,#4
000028  d172              BNE      |L9.272|
00002a  e027              B        |L9.124|
                  |L9.44|
00002c  2d10              CMP      r5,#0x10
00002e  d031              BEQ      |L9.148|
000030  2d20              CMP      r5,#0x20
000032  d035              BEQ      |L9.160|
000034  2d40              CMP      r5,#0x40
000036  d16b              BNE      |L9.272|
000038  e038              B        |L9.172|
                  |L9.58|
00003a  f5b54f00          CMP      r5,#0x8000
00003e  d060              BEQ      |L9.258|
000040  dc09              BGT      |L9.86|
000042  f5b57f00          CMP      r5,#0x200
000046  d049              BEQ      |L9.220|
000048  f5b56f80          CMP      r5,#0x400
00004c  d04c              BEQ      |L9.232|
00004e  f5b56f00          CMP      r5,#0x800
000052  d15d              BNE      |L9.272|
000054  e04f              B        |L9.246|
                  |L9.86|
000056  f5b53f80          CMP      r5,#0x10000
00005a  d02d              BEQ      |L9.184|
00005c  f5b53f00          CMP      r5,#0x20000
000060  d156              BNE      |L9.272|
000062  e02f              B        |L9.196|
                  |L9.100|
;;;1505       {
;;;1506         case CAN_IT_TME:
;;;1507           /* Check CAN_TSR_RQCPx bits */
;;;1508           itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
000064  68a0              LDR      r0,[r4,#8]
000066  492d              LDR      r1,|L9.284|
000068  f7fffffe          BL       CheckITStatus
00006c  4606              MOV      r6,r0
;;;1509           break;
00006e  e051              B        |L9.276|
                  |L9.112|
;;;1510         case CAN_IT_FMP0:
;;;1511           /* Check CAN_RF0R_FMP0 bit */
;;;1512           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
000070  68e0              LDR      r0,[r4,#0xc]
000072  2103              MOVS     r1,#3
000074  f7fffffe          BL       CheckITStatus
000078  4606              MOV      r6,r0
;;;1513           break;
00007a  e04b              B        |L9.276|
                  |L9.124|
;;;1514         case CAN_IT_FF0:
;;;1515           /* Check CAN_RF0R_FULL0 bit */
;;;1516           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
00007c  68e0              LDR      r0,[r4,#0xc]
00007e  2108              MOVS     r1,#8
000080  f7fffffe          BL       CheckITStatus
000084  4606              MOV      r6,r0
;;;1517           break;
000086  e045              B        |L9.276|
                  |L9.136|
;;;1518         case CAN_IT_FOV0:
;;;1519           /* Check CAN_RF0R_FOVR0 bit */
;;;1520           itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
000088  68e0              LDR      r0,[r4,#0xc]
00008a  2110              MOVS     r1,#0x10
00008c  f7fffffe          BL       CheckITStatus
000090  4606              MOV      r6,r0
;;;1521           break;
000092  e03f              B        |L9.276|
                  |L9.148|
;;;1522         case CAN_IT_FMP1:
;;;1523           /* Check CAN_RF1R_FMP1 bit */
;;;1524           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
000094  6920              LDR      r0,[r4,#0x10]
000096  2103              MOVS     r1,#3
000098  f7fffffe          BL       CheckITStatus
00009c  4606              MOV      r6,r0
;;;1525           break;
00009e  e039              B        |L9.276|
                  |L9.160|
;;;1526         case CAN_IT_FF1:
;;;1527           /* Check CAN_RF1R_FULL1 bit */
;;;1528           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
0000a0  6920              LDR      r0,[r4,#0x10]
0000a2  2108              MOVS     r1,#8
0000a4  f7fffffe          BL       CheckITStatus
0000a8  4606              MOV      r6,r0
;;;1529           break;
0000aa  e033              B        |L9.276|
                  |L9.172|
;;;1530         case CAN_IT_FOV1:
;;;1531           /* Check CAN_RF1R_FOVR1 bit */
;;;1532           itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
0000ac  6920              LDR      r0,[r4,#0x10]
0000ae  2110              MOVS     r1,#0x10
0000b0  f7fffffe          BL       CheckITStatus
0000b4  4606              MOV      r6,r0
;;;1533           break;
0000b6  e02d              B        |L9.276|
                  |L9.184|
;;;1534         case CAN_IT_WKU:
;;;1535           /* Check CAN_MSR_WKUI bit */
;;;1536           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
0000b8  6860              LDR      r0,[r4,#4]
0000ba  2108              MOVS     r1,#8
0000bc  f7fffffe          BL       CheckITStatus
0000c0  4606              MOV      r6,r0
;;;1537           break;
0000c2  e027              B        |L9.276|
                  |L9.196|
;;;1538         case CAN_IT_SLK:
;;;1539           /* Check CAN_MSR_SLAKI bit */
;;;1540           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
0000c4  6860              LDR      r0,[r4,#4]
0000c6  2110              MOVS     r1,#0x10
0000c8  f7fffffe          BL       CheckITStatus
0000cc  4606              MOV      r6,r0
;;;1541           break;
0000ce  e021              B        |L9.276|
                  |L9.208|
;;;1542         case CAN_IT_EWG:
;;;1543           /* Check CAN_ESR_EWGF bit */
;;;1544           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
0000d0  69a0              LDR      r0,[r4,#0x18]
0000d2  2101              MOVS     r1,#1
0000d4  f7fffffe          BL       CheckITStatus
0000d8  4606              MOV      r6,r0
;;;1545           break;
0000da  e01b              B        |L9.276|
                  |L9.220|
;;;1546         case CAN_IT_EPV:
;;;1547           /* Check CAN_ESR_EPVF bit */
;;;1548           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
0000dc  69a0              LDR      r0,[r4,#0x18]
0000de  2102              MOVS     r1,#2
0000e0  f7fffffe          BL       CheckITStatus
0000e4  4606              MOV      r6,r0
;;;1549           break;
0000e6  e015              B        |L9.276|
                  |L9.232|
;;;1550         case CAN_IT_BOF:
;;;1551           /* Check CAN_ESR_BOFF bit */
;;;1552           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
0000e8  69a0              LDR      r0,[r4,#0x18]
0000ea  2104              MOVS     r1,#4
0000ec  f7fffffe          BL       CheckITStatus
0000f0  4606              MOV      r6,r0
;;;1553           break;
0000f2  e00f              B        |L9.276|
                  |L9.244|
0000f4  e00f              B        |L9.278|
                  |L9.246|
;;;1554         case CAN_IT_LEC:
;;;1555           /* Check CAN_ESR_LEC bit */
;;;1556           itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
0000f6  69a0              LDR      r0,[r4,#0x18]
0000f8  2170              MOVS     r1,#0x70
0000fa  f7fffffe          BL       CheckITStatus
0000fe  4606              MOV      r6,r0
;;;1557           break;
000100  e008              B        |L9.276|
                  |L9.258|
;;;1558         case CAN_IT_ERR:
;;;1559           /* Check CAN_MSR_ERRI bit */ 
;;;1560           itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
000102  6860              LDR      r0,[r4,#4]
000104  2104              MOVS     r1,#4
000106  f7fffffe          BL       CheckITStatus
00010a  4606              MOV      r6,r0
;;;1561           break;
00010c  e002              B        |L9.276|
00010e  e7ff              B        |L9.272|
                  |L9.272|
;;;1562         default:
;;;1563           /* in case of error, return RESET */
;;;1564           itstatus = RESET;
000110  2600              MOVS     r6,#0
;;;1565           break;
000112  bf00              NOP      
                  |L9.276|
000114  e000              B        |L9.280|
                  |L9.278|
;;;1566       }
;;;1567     }
;;;1568     else
;;;1569     {
;;;1570      /* in case the Interrupt is not enabled, return RESET */
;;;1571       itstatus  = RESET;
000116  2600              MOVS     r6,#0
                  |L9.280|
;;;1572     }
;;;1573     
;;;1574     /* Return the CAN_IT status */
;;;1575     return  itstatus;
000118  4630              MOV      r0,r6
;;;1576   }
00011a  bd70              POP      {r4-r6,pc}
;;;1577   
                          ENDP

                  |L9.284|
                          DCD      0x00010101

                          AREA ||i.CAN_GetLSBTransmitErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetLSBTransmitErrorCounter PROC
;;;1085     */
;;;1086   uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;1087   {
;;;1088     uint8_t counter=0;
000002  2000              MOVS     r0,#0
;;;1089     
;;;1090     /* Check the parameters */
;;;1091     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1092     
;;;1093     /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1094     counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
000004  698a              LDR      r2,[r1,#0x18]
000006  f3c24007          UBFX     r0,r2,#16,#8
;;;1095     
;;;1096     /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
;;;1097     return counter;
;;;1098   }
00000a  4770              BX       lr
;;;1099   /**
                          ENDP


                          AREA ||i.CAN_GetLastErrorCode||, CODE, READONLY, ALIGN=1

                  CAN_GetLastErrorCode PROC
;;;1040     */
;;;1041   uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;1042   {
;;;1043     uint8_t errorcode=0;
000002  2000              MOVS     r0,#0
;;;1044     
;;;1045     /* Check the parameters */
;;;1046     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1047     
;;;1048     /* Get the error code*/
;;;1049     errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
000004  698a              LDR      r2,[r1,#0x18]
000006  f0020070          AND      r0,r2,#0x70
;;;1050     
;;;1051     /* Return the error code*/
;;;1052     return errorcode;
;;;1053   }
00000a  4770              BX       lr
;;;1054   
                          ENDP


                          AREA ||i.CAN_GetReceiveErrorCounter||, CODE, READONLY, ALIGN=1

                  CAN_GetReceiveErrorCounter PROC
;;;1065     */
;;;1066   uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;1067   {
;;;1068     uint8_t counter=0;
000002  2000              MOVS     r0,#0
;;;1069     
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1072     
;;;1073     /* Get the Receive Error Counter*/
;;;1074     counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
000004  698a              LDR      r2,[r1,#0x18]
000006  0e10              LSRS     r0,r2,#24
;;;1075     
;;;1076     /* Return the Receive Error Counter*/
;;;1077     return counter;
;;;1078   }
000008  4770              BX       lr
;;;1079   
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;1292     */
;;;1293   void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L13.10|
;;;1294   {
;;;1295     /* Check the parameters */
;;;1296     assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;1297     assert_param(IS_CAN_IT(CAN_IT));
;;;1298     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1299   
;;;1300     if (NewState != DISABLE)
;;;1301     {
;;;1302       /* Enable the selected CANx interrupt */
;;;1303       CANx->IER |= CAN_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L13.16|
                  |L13.10|
;;;1304     }
;;;1305     else
;;;1306     {
;;;1307       /* Disable the selected CANx interrupt */
;;;1308       CANx->IER &= ~CAN_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L13.16|
;;;1309     }
;;;1310   }
000010  4770              BX       lr
;;;1311   /**
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;197      */
;;;198    uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;199    {
000002  4602              MOV      r2,r0
;;;200      uint8_t InitStatus = CAN_InitStatus_Failed;
000004  2000              MOVS     r0,#0
;;;201      uint32_t wait_ack = 0x00000000;
000006  2300              MOVS     r3,#0
;;;202      /* Check the parameters */
;;;203      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;204      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
;;;205      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
;;;206      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
;;;207      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
;;;208      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
;;;209      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
;;;210      assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
;;;211      assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
;;;212      assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
;;;213      assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
;;;214      assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
;;;215    
;;;216      /* Exit from sleep mode */
;;;217      CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
000008  6814              LDR      r4,[r2,#0]
00000a  f0240402          BIC      r4,r4,#2
00000e  6014              STR      r4,[r2,#0]
;;;218    
;;;219      /* Request initialisation */
;;;220      CANx->MCR |= CAN_MCR_INRQ ;
000010  6814              LDR      r4,[r2,#0]
000012  f0440401          ORR      r4,r4,#1
000016  6014              STR      r4,[r2,#0]
;;;221    
;;;222      /* Wait the acknowledge */
;;;223      while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
000018  e000              B        |L14.28|
                  |L14.26|
;;;224      {
;;;225        wait_ack++;
00001a  1c5b              ADDS     r3,r3,#1
                  |L14.28|
00001c  6854              LDR      r4,[r2,#4]            ;223
00001e  f0040401          AND      r4,r4,#1              ;223
000022  b91c              CBNZ     r4,|L14.44|
000024  f64f74ff          MOV      r4,#0xffff            ;223
000028  42a3              CMP      r3,r4                 ;223
00002a  d1f6              BNE      |L14.26|
                  |L14.44|
;;;226      }
;;;227    
;;;228      /* Check acknowledge */
;;;229      if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
00002c  6854              LDR      r4,[r2,#4]
00002e  f0040401          AND      r4,r4,#1
000032  b90c              CBNZ     r4,|L14.56|
;;;230      {
;;;231        InitStatus = CAN_InitStatus_Failed;
000034  2000              MOVS     r0,#0
000036  e06c              B        |L14.274|
                  |L14.56|
;;;232      }
;;;233      else 
;;;234      {
;;;235        /* Set the time triggered communication mode */
;;;236        if (CAN_InitStruct->CAN_TTCM == ENABLE)
000038  798c              LDRB     r4,[r1,#6]
00003a  2c01              CMP      r4,#1
00003c  d104              BNE      |L14.72|
;;;237        {
;;;238          CANx->MCR |= CAN_MCR_TTCM;
00003e  6814              LDR      r4,[r2,#0]
000040  f0440480          ORR      r4,r4,#0x80
000044  6014              STR      r4,[r2,#0]
000046  e003              B        |L14.80|
                  |L14.72|
;;;239        }
;;;240        else
;;;241        {
;;;242          CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
000048  6814              LDR      r4,[r2,#0]
00004a  f0240480          BIC      r4,r4,#0x80
00004e  6014              STR      r4,[r2,#0]
                  |L14.80|
;;;243        }
;;;244    
;;;245        /* Set the automatic bus-off management */
;;;246        if (CAN_InitStruct->CAN_ABOM == ENABLE)
000050  79cc              LDRB     r4,[r1,#7]
000052  2c01              CMP      r4,#1
000054  d104              BNE      |L14.96|
;;;247        {
;;;248          CANx->MCR |= CAN_MCR_ABOM;
000056  6814              LDR      r4,[r2,#0]
000058  f0440440          ORR      r4,r4,#0x40
00005c  6014              STR      r4,[r2,#0]
00005e  e003              B        |L14.104|
                  |L14.96|
;;;249        }
;;;250        else
;;;251        {
;;;252          CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
000060  6814              LDR      r4,[r2,#0]
000062  f0240440          BIC      r4,r4,#0x40
000066  6014              STR      r4,[r2,#0]
                  |L14.104|
;;;253        }
;;;254    
;;;255        /* Set the automatic wake-up mode */
;;;256        if (CAN_InitStruct->CAN_AWUM == ENABLE)
000068  7a0c              LDRB     r4,[r1,#8]
00006a  2c01              CMP      r4,#1
00006c  d104              BNE      |L14.120|
;;;257        {
;;;258          CANx->MCR |= CAN_MCR_AWUM;
00006e  6814              LDR      r4,[r2,#0]
000070  f0440420          ORR      r4,r4,#0x20
000074  6014              STR      r4,[r2,#0]
000076  e003              B        |L14.128|
                  |L14.120|
;;;259        }
;;;260        else
;;;261        {
;;;262          CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
000078  6814              LDR      r4,[r2,#0]
00007a  f0240420          BIC      r4,r4,#0x20
00007e  6014              STR      r4,[r2,#0]
                  |L14.128|
;;;263        }
;;;264    
;;;265        /* Set the no automatic retransmission */
;;;266        if (CAN_InitStruct->CAN_NART == ENABLE)
000080  7a4c              LDRB     r4,[r1,#9]
000082  2c01              CMP      r4,#1
000084  d104              BNE      |L14.144|
;;;267        {
;;;268          CANx->MCR |= CAN_MCR_NART;
000086  6814              LDR      r4,[r2,#0]
000088  f0440410          ORR      r4,r4,#0x10
00008c  6014              STR      r4,[r2,#0]
00008e  e003              B        |L14.152|
                  |L14.144|
;;;269        }
;;;270        else
;;;271        {
;;;272          CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
000090  6814              LDR      r4,[r2,#0]
000092  f0240410          BIC      r4,r4,#0x10
000096  6014              STR      r4,[r2,#0]
                  |L14.152|
;;;273        }
;;;274    
;;;275        /* Set the receive FIFO locked mode */
;;;276        if (CAN_InitStruct->CAN_RFLM == ENABLE)
000098  7a8c              LDRB     r4,[r1,#0xa]
00009a  2c01              CMP      r4,#1
00009c  d104              BNE      |L14.168|
;;;277        {
;;;278          CANx->MCR |= CAN_MCR_RFLM;
00009e  6814              LDR      r4,[r2,#0]
0000a0  f0440408          ORR      r4,r4,#8
0000a4  6014              STR      r4,[r2,#0]
0000a6  e003              B        |L14.176|
                  |L14.168|
;;;279        }
;;;280        else
;;;281        {
;;;282          CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
0000a8  6814              LDR      r4,[r2,#0]
0000aa  f0240408          BIC      r4,r4,#8
0000ae  6014              STR      r4,[r2,#0]
                  |L14.176|
;;;283        }
;;;284    
;;;285        /* Set the transmit FIFO priority */
;;;286        if (CAN_InitStruct->CAN_TXFP == ENABLE)
0000b0  7acc              LDRB     r4,[r1,#0xb]
0000b2  2c01              CMP      r4,#1
0000b4  d104              BNE      |L14.192|
;;;287        {
;;;288          CANx->MCR |= CAN_MCR_TXFP;
0000b6  6814              LDR      r4,[r2,#0]
0000b8  f0440404          ORR      r4,r4,#4
0000bc  6014              STR      r4,[r2,#0]
0000be  e003              B        |L14.200|
                  |L14.192|
;;;289        }
;;;290        else
;;;291        {
;;;292          CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
0000c0  6814              LDR      r4,[r2,#0]
0000c2  f0240404          BIC      r4,r4,#4
0000c6  6014              STR      r4,[r2,#0]
                  |L14.200|
;;;293        }
;;;294    
;;;295        /* Set the bit timing register */
;;;296        CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
0000c8  788c              LDRB     r4,[r1,#2]
0000ca  07a4              LSLS     r4,r4,#30
0000cc  78cd              LDRB     r5,[r1,#3]
0000ce  ea446405          ORR      r4,r4,r5,LSL #24
0000d2  790d              LDRB     r5,[r1,#4]
0000d4  ea444405          ORR      r4,r4,r5,LSL #16
0000d8  794d              LDRB     r5,[r1,#5]
0000da  ea445405          ORR      r4,r4,r5,LSL #20
0000de  880d              LDRH     r5,[r1,#0]
0000e0  1e6d              SUBS     r5,r5,#1
0000e2  432c              ORRS     r4,r4,r5
0000e4  61d4              STR      r4,[r2,#0x1c]
;;;297                    ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
;;;298                    ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
;;;299                    ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
;;;300                   ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
;;;301    
;;;302        /* Request leave initialisation */
;;;303        CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
0000e6  6814              LDR      r4,[r2,#0]
0000e8  f0240401          BIC      r4,r4,#1
0000ec  6014              STR      r4,[r2,#0]
;;;304    
;;;305       /* Wait the acknowledge */
;;;306       wait_ack = 0;
0000ee  2300              MOVS     r3,#0
;;;307    
;;;308       while (((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
0000f0  e000              B        |L14.244|
                  |L14.242|
;;;309       {
;;;310         wait_ack++;
0000f2  1c5b              ADDS     r3,r3,#1
                  |L14.244|
0000f4  6854              LDR      r4,[r2,#4]            ;308
0000f6  f0040401          AND      r4,r4,#1              ;308
0000fa  b11c              CBZ      r4,|L14.260|
0000fc  f64f74ff          MOV      r4,#0xffff            ;308
000100  42a3              CMP      r3,r4                 ;308
000102  d1f6              BNE      |L14.242|
                  |L14.260|
;;;311       }
;;;312    
;;;313        /* ...and check acknowledged */
;;;314        if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
000104  6854              LDR      r4,[r2,#4]
000106  f0040401          AND      r4,r4,#1
00010a  b10c              CBZ      r4,|L14.272|
;;;315        {
;;;316          InitStatus = CAN_InitStatus_Failed;
00010c  2000              MOVS     r0,#0
00010e  e000              B        |L14.274|
                  |L14.272|
;;;317        }
;;;318        else
;;;319        {
;;;320          InitStatus = CAN_InitStatus_Success ;
000110  2001              MOVS     r0,#1
                  |L14.274|
;;;321        }
;;;322      }
;;;323    
;;;324      /* At this step, return the status of initialization */
;;;325      return InitStatus;
;;;326    }
000112  bd30              POP      {r4,r5,pc}
;;;327    
                          ENDP


                          AREA ||i.CAN_MessagePending||, CODE, READONLY, ALIGN=1

                  CAN_MessagePending PROC
;;;822      */
;;;823    uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
000000  4602              MOV      r2,r0
;;;824    {
;;;825      uint8_t message_pending=0;
000002  2000              MOVS     r0,#0
;;;826      /* Check the parameters */
;;;827      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;828      assert_param(IS_CAN_FIFO(FIFONumber));
;;;829      if (FIFONumber == CAN_FIFO0)
000004  b919              CBNZ     r1,|L15.14|
;;;830      {
;;;831        message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
000006  68d3              LDR      r3,[r2,#0xc]
000008  f0030003          AND      r0,r3,#3
00000c  e006              B        |L15.28|
                  |L15.14|
;;;832      }
;;;833      else if (FIFONumber == CAN_FIFO1)
00000e  2901              CMP      r1,#1
000010  d103              BNE      |L15.26|
;;;834      {
;;;835        message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
000012  6913              LDR      r3,[r2,#0x10]
000014  f0030003          AND      r0,r3,#3
000018  e000              B        |L15.28|
                  |L15.26|
;;;836      }
;;;837      else
;;;838      {
;;;839        message_pending = 0;
00001a  2000              MOVS     r0,#0
                  |L15.28|
;;;840      }
;;;841      return message_pending;
;;;842    }
00001c  4770              BX       lr
;;;843    /**
                          ENDP


                          AREA ||i.CAN_OperatingModeRequest||, CODE, READONLY, ALIGN=1

                  CAN_OperatingModeRequest PROC
;;;872      */
;;;873    uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
000000  b510              PUSH     {r4,lr}
;;;874    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;875      uint8_t status = CAN_ModeStatus_Failed;
000006  2000              MOVS     r0,#0
;;;876      
;;;877      /* Timeout for INAK or also for SLAK bits*/
;;;878      uint32_t timeout = INAK_TIMEOUT; 
000008  f64f71ff          MOV      r1,#0xffff
;;;879    
;;;880      /* Check the parameters */
;;;881      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;882      assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
;;;883    
;;;884      if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
00000c  b9bb              CBNZ     r3,|L16.62|
;;;885      {
;;;886        /* Request initialisation */
;;;887        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
00000e  6814              LDR      r4,[r2,#0]
000010  f0240402          BIC      r4,r4,#2
000014  f0440401          ORR      r4,r4,#1
000018  6014              STR      r4,[r2,#0]
;;;888    
;;;889        /* Wait the acknowledge */
;;;890        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
00001a  e000              B        |L16.30|
                  |L16.28|
;;;891        {
;;;892          timeout--;
00001c  1e49              SUBS     r1,r1,#1
                  |L16.30|
00001e  6854              LDR      r4,[r2,#4]            ;890
000020  f0040403          AND      r4,r4,#3              ;890
000024  2c01              CMP      r4,#1                 ;890
000026  d001              BEQ      |L16.44|
000028  2900              CMP      r1,#0                 ;890
00002a  d1f7              BNE      |L16.28|
                  |L16.44|
;;;893        }
;;;894        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
00002c  6854              LDR      r4,[r2,#4]
00002e  f0040403          AND      r4,r4,#3
000032  2c01              CMP      r4,#1
000034  d001              BEQ      |L16.58|
;;;895        {
;;;896          status = CAN_ModeStatus_Failed;
000036  2000              MOVS     r0,#0
000038  e032              B        |L16.160|
                  |L16.58|
;;;897        }
;;;898        else
;;;899        {
;;;900          status = CAN_ModeStatus_Success;
00003a  2001              MOVS     r0,#1
00003c  e030              B        |L16.160|
                  |L16.62|
;;;901        }
;;;902      }
;;;903      else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
00003e  2b01              CMP      r3,#1
000040  d113              BNE      |L16.106|
;;;904      {
;;;905        /* Request leave initialisation and sleep mode  and enter Normal mode */
;;;906        CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
000042  6814              LDR      r4,[r2,#0]
000044  f0240403          BIC      r4,r4,#3
000048  6014              STR      r4,[r2,#0]
;;;907    
;;;908        /* Wait the acknowledge */
;;;909        while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
00004a  e000              B        |L16.78|
                  |L16.76|
;;;910        {
;;;911          timeout--;
00004c  1e49              SUBS     r1,r1,#1
                  |L16.78|
00004e  6854              LDR      r4,[r2,#4]            ;909
000050  f0040403          AND      r4,r4,#3              ;909
000054  b10c              CBZ      r4,|L16.90|
000056  2900              CMP      r1,#0                 ;909
000058  d1f8              BNE      |L16.76|
                  |L16.90|
;;;912        }
;;;913        if ((CANx->MSR & CAN_MODE_MASK) != 0)
00005a  6854              LDR      r4,[r2,#4]
00005c  f0040403          AND      r4,r4,#3
000060  b10c              CBZ      r4,|L16.102|
;;;914        {
;;;915          status = CAN_ModeStatus_Failed;
000062  2000              MOVS     r0,#0
000064  e01c              B        |L16.160|
                  |L16.102|
;;;916        }
;;;917        else
;;;918        {
;;;919          status = CAN_ModeStatus_Success;
000066  2001              MOVS     r0,#1
000068  e01a              B        |L16.160|
                  |L16.106|
;;;920        }
;;;921      }
;;;922      else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
00006a  2b02              CMP      r3,#2
00006c  d117              BNE      |L16.158|
;;;923      {
;;;924        /* Request Sleep mode */
;;;925        CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
00006e  6814              LDR      r4,[r2,#0]
000070  f0240401          BIC      r4,r4,#1
000074  f0440402          ORR      r4,r4,#2
000078  6014              STR      r4,[r2,#0]
;;;926    
;;;927        /* Wait the acknowledge */
;;;928        while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
00007a  e000              B        |L16.126|
                  |L16.124|
;;;929        {
;;;930          timeout--;
00007c  1e49              SUBS     r1,r1,#1
                  |L16.126|
00007e  6854              LDR      r4,[r2,#4]            ;928
000080  f0040403          AND      r4,r4,#3              ;928
000084  2c02              CMP      r4,#2                 ;928
000086  d001              BEQ      |L16.140|
000088  2900              CMP      r1,#0                 ;928
00008a  d1f7              BNE      |L16.124|
                  |L16.140|
;;;931        }
;;;932        if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
00008c  6854              LDR      r4,[r2,#4]
00008e  f0040403          AND      r4,r4,#3
000092  2c02              CMP      r4,#2
000094  d001              BEQ      |L16.154|
;;;933        {
;;;934          status = CAN_ModeStatus_Failed;
000096  2000              MOVS     r0,#0
000098  e002              B        |L16.160|
                  |L16.154|
;;;935        }
;;;936        else
;;;937        {
;;;938          status = CAN_ModeStatus_Success;
00009a  2001              MOVS     r0,#1
00009c  e000              B        |L16.160|
                  |L16.158|
;;;939        }
;;;940      }
;;;941      else
;;;942      {
;;;943        status = CAN_ModeStatus_Failed;
00009e  2000              MOVS     r0,#0
                  |L16.160|
;;;944      }
;;;945    
;;;946      return  (uint8_t) status;
;;;947    }
0000a0  bd10              POP      {r4,pc}
;;;948    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;750      */
;;;751    void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
000000  b510              PUSH     {r4,lr}
;;;752    {
;;;753      /* Check the parameters */
;;;754      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;755      assert_param(IS_CAN_FIFO(FIFONumber));
;;;756      /* Get the Id */
;;;757      RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
000002  f50073d8          ADD      r3,r0,#0x1b0
000006  eb031301          ADD      r3,r3,r1,LSL #4
00000a  681b              LDR      r3,[r3,#0]
00000c  f0030304          AND      r3,r3,#4
000010  7213              STRB     r3,[r2,#8]
;;;758      if (RxMessage->IDE == CAN_Id_Standard)
000012  7a13              LDRB     r3,[r2,#8]
000014  b953              CBNZ     r3,|L17.44|
;;;759      {
;;;760        RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
000016  f50073d8          ADD      r3,r0,#0x1b0
00001a  eb031301          ADD      r3,r3,r1,LSL #4
00001e  681b              LDR      r3,[r3,#0]
000020  f24074ff          MOV      r4,#0x7ff
000024  ea045353          AND      r3,r4,r3,LSR #21
000028  6013              STR      r3,[r2,#0]
00002a  e009              B        |L17.64|
                  |L17.44|
;;;761      }
;;;762      else
;;;763      {
;;;764        RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
00002c  f50073d8          ADD      r3,r0,#0x1b0
000030  eb031301          ADD      r3,r3,r1,LSL #4
000034  681b              LDR      r3,[r3,#0]
000036  f06f4460          MVN      r4,#0xe0000000
00003a  ea0403d3          AND      r3,r4,r3,LSR #3
00003e  6053              STR      r3,[r2,#4]
                  |L17.64|
;;;765      }
;;;766      
;;;767      RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
000040  f50073d8          ADD      r3,r0,#0x1b0
000044  eb031301          ADD      r3,r3,r1,LSL #4
000048  681b              LDR      r3,[r3,#0]
00004a  f0030302          AND      r3,r3,#2
00004e  7253              STRB     r3,[r2,#9]
;;;768      /* Get the DLC */
;;;769      RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
000050  f50073d8          ADD      r3,r0,#0x1b0
000054  eb031301          ADD      r3,r3,r1,LSL #4
000058  685b              LDR      r3,[r3,#4]
00005a  f003030f          AND      r3,r3,#0xf
00005e  7293              STRB     r3,[r2,#0xa]
;;;770      /* Get the FMI */
;;;771      RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
000060  f50073d8          ADD      r3,r0,#0x1b0
000064  eb031301          ADD      r3,r3,r1,LSL #4
000068  685b              LDR      r3,[r3,#4]
00006a  0a1b              LSRS     r3,r3,#8
00006c  74d3              STRB     r3,[r2,#0x13]
;;;772      /* Get the data field */
;;;773      RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
00006e  f50073d8          ADD      r3,r0,#0x1b0
000072  eb031301          ADD      r3,r3,r1,LSL #4
000076  689b              LDR      r3,[r3,#8]
000078  72d3              STRB     r3,[r2,#0xb]
;;;774      RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
00007a  f50073d8          ADD      r3,r0,#0x1b0
00007e  eb031301          ADD      r3,r3,r1,LSL #4
000082  689b              LDR      r3,[r3,#8]
000084  0a1c              LSRS     r4,r3,#8
000086  7314              STRB     r4,[r2,#0xc]
;;;775      RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
000088  f50073d8          ADD      r3,r0,#0x1b0
00008c  eb031301          ADD      r3,r3,r1,LSL #4
000090  689b              LDR      r3,[r3,#8]
000092  0c1c              LSRS     r4,r3,#16
000094  7354              STRB     r4,[r2,#0xd]
;;;776      RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
000096  f50073d8          ADD      r3,r0,#0x1b0
00009a  eb031301          ADD      r3,r3,r1,LSL #4
00009e  689b              LDR      r3,[r3,#8]
0000a0  0e1b              LSRS     r3,r3,#24
0000a2  7393              STRB     r3,[r2,#0xe]
;;;777      RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
0000a4  f50073d8          ADD      r3,r0,#0x1b0
0000a8  eb031301          ADD      r3,r3,r1,LSL #4
0000ac  68db              LDR      r3,[r3,#0xc]
0000ae  73d3              STRB     r3,[r2,#0xf]
;;;778      RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
0000b0  f50073d8          ADD      r3,r0,#0x1b0
0000b4  eb031301          ADD      r3,r3,r1,LSL #4
0000b8  68db              LDR      r3,[r3,#0xc]
0000ba  0a1c              LSRS     r4,r3,#8
0000bc  7414              STRB     r4,[r2,#0x10]
;;;779      RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
0000be  f50073d8          ADD      r3,r0,#0x1b0
0000c2  eb031301          ADD      r3,r3,r1,LSL #4
0000c6  68db              LDR      r3,[r3,#0xc]
0000c8  0c1c              LSRS     r4,r3,#16
0000ca  7454              STRB     r4,[r2,#0x11]
;;;780      RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
0000cc  f50073d8          ADD      r3,r0,#0x1b0
0000d0  eb031301          ADD      r3,r3,r1,LSL #4
0000d4  68db              LDR      r3,[r3,#0xc]
0000d6  0e1b              LSRS     r3,r3,#24
0000d8  7493              STRB     r3,[r2,#0x12]
;;;781      /* Release the FIFO */
;;;782      /* Release FIFO0 */
;;;783      if (FIFONumber == CAN_FIFO0)
0000da  b921              CBNZ     r1,|L17.230|
;;;784      {
;;;785        CANx->RF0R |= CAN_RF0R_RFOM0;
0000dc  68c3              LDR      r3,[r0,#0xc]
0000de  f0430320          ORR      r3,r3,#0x20
0000e2  60c3              STR      r3,[r0,#0xc]
0000e4  e003              B        |L17.238|
                  |L17.230|
;;;786      }
;;;787      /* Release FIFO1 */
;;;788      else /* FIFONumber == CAN_FIFO1 */
;;;789      {
;;;790        CANx->RF1R |= CAN_RF1R_RFOM1;
0000e6  6903              LDR      r3,[r0,#0x10]
0000e8  f0430320          ORR      r3,r3,#0x20
0000ec  6103              STR      r3,[r0,#0x10]
                  |L17.238|
;;;791      }
;;;792    }
0000ee  bd10              POP      {r4,pc}
;;;793    
                          ENDP


                          AREA ||i.CAN_SlaveStartBank||, CODE, READONLY, ALIGN=2

                  CAN_SlaveStartBank PROC
;;;468      */
;;;469    void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
000000  490b              LDR      r1,|L18.48|
;;;470    {
;;;471      /* Check the parameters */
;;;472      assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
;;;473      
;;;474      /* Enter Initialisation mode for the filter */
;;;475      CAN1->FMR |= FMR_FINIT;
000002  6809              LDR      r1,[r1,#0]
000004  f0410101          ORR      r1,r1,#1
000008  4a09              LDR      r2,|L18.48|
00000a  6011              STR      r1,[r2,#0]
;;;476      
;;;477      /* Select the start slave bank */
;;;478      CAN1->FMR &= (uint32_t)0xFFFFC0F1 ;
00000c  4611              MOV      r1,r2
00000e  6809              LDR      r1,[r1,#0]
000010  f643720e          MOV      r2,#0x3f0e
000014  4391              BICS     r1,r1,r2
000016  4a06              LDR      r2,|L18.48|
000018  6011              STR      r1,[r2,#0]
;;;479      CAN1->FMR |= (uint32_t)(CAN_BankNumber)<<8;
00001a  4611              MOV      r1,r2
00001c  6809              LDR      r1,[r1,#0]
00001e  ea412100          ORR      r1,r1,r0,LSL #8
000022  6011              STR      r1,[r2,#0]
;;;480      
;;;481      /* Leave Initialisation mode for the filter */
;;;482      CAN1->FMR &= ~FMR_FINIT;
000024  4611              MOV      r1,r2
000026  6809              LDR      r1,[r1,#0]
000028  f0210101          BIC      r1,r1,#1
00002c  6011              STR      r1,[r2,#0]
;;;483    }
00002e  4770              BX       lr
;;;484    
                          ENDP

                  |L18.48|
                          DCD      0x40006600

                          AREA ||i.CAN_Sleep||, CODE, READONLY, ALIGN=1

                  CAN_Sleep PROC
;;;953      */
;;;954    uint8_t CAN_Sleep(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;955    {
;;;956      uint8_t sleepstatus = CAN_Sleep_Failed;
000002  2000              MOVS     r0,#0
;;;957      
;;;958      /* Check the parameters */
;;;959      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;960        
;;;961      /* Request Sleep mode */
;;;962       CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
000004  680a              LDR      r2,[r1,#0]
000006  f0220201          BIC      r2,r2,#1
00000a  f0420202          ORR      r2,r2,#2
00000e  600a              STR      r2,[r1,#0]
;;;963       
;;;964      /* Sleep mode status */
;;;965      if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
000010  684a              LDR      r2,[r1,#4]
000012  f0020203          AND      r2,r2,#3
000016  2a02              CMP      r2,#2
000018  d100              BNE      |L19.28|
;;;966      {
;;;967        /* Sleep mode not entered */
;;;968        sleepstatus =  CAN_Sleep_Ok;
00001a  2001              MOVS     r0,#1
                  |L19.28|
;;;969      }
;;;970      /* return sleep mode status */
;;;971       return (uint8_t)sleepstatus;
;;;972    }
00001c  4770              BX       lr
;;;973    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;425      */
;;;426    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;427    {
;;;428      /* Reset CAN init structure parameters values */
;;;429      
;;;430      /* Initialize the time triggered communication mode */
;;;431      CAN_InitStruct->CAN_TTCM = DISABLE;
000002  7181              STRB     r1,[r0,#6]
;;;432      
;;;433      /* Initialize the automatic bus-off management */
;;;434      CAN_InitStruct->CAN_ABOM = DISABLE;
000004  71c1              STRB     r1,[r0,#7]
;;;435      
;;;436      /* Initialize the automatic wake-up mode */
;;;437      CAN_InitStruct->CAN_AWUM = DISABLE;
000006  7201              STRB     r1,[r0,#8]
;;;438      
;;;439      /* Initialize the no automatic retransmission */
;;;440      CAN_InitStruct->CAN_NART = DISABLE;
000008  7241              STRB     r1,[r0,#9]
;;;441      
;;;442      /* Initialize the receive FIFO locked mode */
;;;443      CAN_InitStruct->CAN_RFLM = DISABLE;
00000a  7281              STRB     r1,[r0,#0xa]
;;;444      
;;;445      /* Initialize the transmit FIFO priority */
;;;446      CAN_InitStruct->CAN_TXFP = DISABLE;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;447      
;;;448      /* Initialize the CAN_Mode member */
;;;449      CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
00000e  7081              STRB     r1,[r0,#2]
;;;450      
;;;451      /* Initialize the CAN_SJW member */
;;;452      CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
000010  70c1              STRB     r1,[r0,#3]
;;;453      
;;;454      /* Initialize the CAN_BS1 member */
;;;455      CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
000012  2103              MOVS     r1,#3
000014  7101              STRB     r1,[r0,#4]
;;;456      
;;;457      /* Initialize the CAN_BS2 member */
;;;458      CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
000016  2102              MOVS     r1,#2
000018  7141              STRB     r1,[r0,#5]
;;;459      
;;;460      /* Initialize the CAN_Prescaler member */
;;;461      CAN_InitStruct->CAN_Prescaler = 1;
00001a  2101              MOVS     r1,#1
00001c  8001              STRH     r1,[r0,#0]
;;;462    }
00001e  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.CAN_TTComModeCmd||, CODE, READONLY, ALIGN=1

                  CAN_TTComModeCmd PROC
;;;523      */
;;;524    void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
000000  b1e1              CBZ      r1,|L21.60|
;;;525    {
;;;526      /* Check the parameters */
;;;527      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;528      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;529      if (NewState != DISABLE)
;;;530      {
;;;531        /* Enable the TTCM mode */
;;;532        CANx->MCR |= CAN_MCR_TTCM;
000002  6802              LDR      r2,[r0,#0]
000004  f0420280          ORR      r2,r2,#0x80
000008  6002              STR      r2,[r0,#0]
;;;533    
;;;534        /* Set TGT bits */
;;;535        CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
00000a  f44f72c2          MOV      r2,#0x184
00000e  5812              LDR      r2,[r2,r0]
000010  f4427380          ORR      r3,r2,#0x100
000014  f44f72c2          MOV      r2,#0x184
000018  5013              STR      r3,[r2,r0]
;;;536        CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
00001a  f44f72ca          MOV      r2,#0x194
00001e  5812              LDR      r2,[r2,r0]
000020  f4427380          ORR      r3,r2,#0x100
000024  f44f72ca          MOV      r2,#0x194
000028  5013              STR      r3,[r2,r0]
;;;537        CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
00002a  f44f72d2          MOV      r2,#0x1a4
00002e  5812              LDR      r2,[r2,r0]
000030  f4427380          ORR      r3,r2,#0x100
000034  f44f72d2          MOV      r2,#0x1a4
000038  5013              STR      r3,[r2,r0]
00003a  e01b              B        |L21.116|
                  |L21.60|
;;;538      }
;;;539      else
;;;540      {
;;;541        /* Disable the TTCM mode */
;;;542        CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
00003c  6802              LDR      r2,[r0,#0]
00003e  f0220280          BIC      r2,r2,#0x80
000042  6002              STR      r2,[r0,#0]
;;;543    
;;;544        /* Reset TGT bits */
;;;545        CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
000044  f44f72c2          MOV      r2,#0x184
000048  5812              LDR      r2,[r2,r0]
00004a  f4227380          BIC      r3,r2,#0x100
00004e  f44f72c2          MOV      r2,#0x184
000052  5013              STR      r3,[r2,r0]
;;;546        CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
000054  f44f72ca          MOV      r2,#0x194
000058  5812              LDR      r2,[r2,r0]
00005a  f4227380          BIC      r3,r2,#0x100
00005e  f44f72ca          MOV      r2,#0x194
000062  5013              STR      r3,[r2,r0]
;;;547        CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
000064  f44f72d2          MOV      r2,#0x1a4
000068  5812              LDR      r2,[r2,r0]
00006a  f4227380          BIC      r3,r2,#0x100
00006e  f44f72d2          MOV      r2,#0x1a4
000072  5013              STR      r3,[r2,r0]
                  |L21.116|
;;;548      }
;;;549    }
000074  4770              BX       lr
;;;550    /**
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;577      */
;;;578    uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
000000  b510              PUSH     {r4,lr}
;;;579    {
000002  4602              MOV      r2,r0
;;;580      uint8_t transmit_mailbox = 0;
000004  2000              MOVS     r0,#0
;;;581      /* Check the parameters */
;;;582      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;583      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;584      assert_param(IS_CAN_RTR(TxMessage->RTR));
;;;585      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;586    
;;;587      /* Select one empty transmit mailbox */
;;;588      if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
000006  6893              LDR      r3,[r2,#8]
000008  f0036380          AND      r3,r3,#0x4000000
00000c  f1b36f80          CMP      r3,#0x4000000
000010  d100              BNE      |L22.20|
;;;589      {
;;;590        transmit_mailbox = 0;
000012  e010              B        |L22.54|
                  |L22.20|
;;;591      }
;;;592      else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
000014  6893              LDR      r3,[r2,#8]
000016  f0036300          AND      r3,r3,#0x8000000
00001a  f1b36f00          CMP      r3,#0x8000000
00001e  d101              BNE      |L22.36|
;;;593      {
;;;594        transmit_mailbox = 1;
000020  2001              MOVS     r0,#1
000022  e008              B        |L22.54|
                  |L22.36|
;;;595      }
;;;596      else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
000024  6893              LDR      r3,[r2,#8]
000026  f0035380          AND      r3,r3,#0x10000000
00002a  f1b35f80          CMP      r3,#0x10000000
00002e  d101              BNE      |L22.52|
;;;597      {
;;;598        transmit_mailbox = 2;
000030  2002              MOVS     r0,#2
000032  e000              B        |L22.54|
                  |L22.52|
;;;599      }
;;;600      else
;;;601      {
;;;602        transmit_mailbox = CAN_TxStatus_NoMailBox;
000034  2004              MOVS     r0,#4
                  |L22.54|
;;;603      }
;;;604    
;;;605      if (transmit_mailbox != CAN_TxStatus_NoMailBox)
000036  2804              CMP      r0,#4
000038  d074              BEQ      |L22.292|
;;;606      {
;;;607        /* Set up the Id */
;;;608        CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
00003a  f50273c0          ADD      r3,r2,#0x180
00003e  eb031300          ADD      r3,r3,r0,LSL #4
000042  681b              LDR      r3,[r3,#0]
000044  f0030401          AND      r4,r3,#1
000048  f50273c0          ADD      r3,r2,#0x180
00004c  eb031300          ADD      r3,r3,r0,LSL #4
000050  601c              STR      r4,[r3,#0]
;;;609        if (TxMessage->IDE == CAN_Id_Standard)
000052  7a0b              LDRB     r3,[r1,#8]
000054  b97b              CBNZ     r3,|L22.118|
;;;610        {
;;;611          assert_param(IS_CAN_STDID(TxMessage->StdId));  
;;;612          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
000056  7a4b              LDRB     r3,[r1,#9]
000058  880c              LDRH     r4,[r1,#0]
00005a  ea435344          ORR      r3,r3,r4,LSL #21
00005e  f50274c0          ADD      r4,r2,#0x180
000062  eb041400          ADD      r4,r4,r0,LSL #4
000066  6824              LDR      r4,[r4,#0]
000068  4323              ORRS     r3,r3,r4
00006a  f50274c0          ADD      r4,r2,#0x180
00006e  eb041400          ADD      r4,r4,r0,LSL #4
000072  6023              STR      r3,[r4,#0]
000074  e010              B        |L22.152|
                  |L22.118|
;;;613                                                      TxMessage->RTR);
;;;614        }
;;;615        else
;;;616        {
;;;617          assert_param(IS_CAN_EXTID(TxMessage->ExtId));
;;;618          CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
000076  7a0b              LDRB     r3,[r1,#8]
000078  684c              LDR      r4,[r1,#4]
00007a  ea4303c4          ORR      r3,r3,r4,LSL #3
00007e  7a4c              LDRB     r4,[r1,#9]
000080  4323              ORRS     r3,r3,r4
000082  f50274c0          ADD      r4,r2,#0x180
000086  eb041400          ADD      r4,r4,r0,LSL #4
00008a  6824              LDR      r4,[r4,#0]
00008c  4323              ORRS     r3,r3,r4
00008e  f50274c0          ADD      r4,r2,#0x180
000092  eb041400          ADD      r4,r4,r0,LSL #4
000096  6023              STR      r3,[r4,#0]
                  |L22.152|
;;;619                                                      TxMessage->IDE | \
;;;620                                                      TxMessage->RTR);
;;;621        }
;;;622        
;;;623        /* Set up the DLC */
;;;624        TxMessage->DLC &= (uint8_t)0x0000000F;
000098  7a8b              LDRB     r3,[r1,#0xa]
00009a  f003030f          AND      r3,r3,#0xf
00009e  728b              STRB     r3,[r1,#0xa]
;;;625        CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
0000a0  f50273c0          ADD      r3,r2,#0x180
0000a4  eb031300          ADD      r3,r3,r0,LSL #4
0000a8  685b              LDR      r3,[r3,#4]
0000aa  f023040f          BIC      r4,r3,#0xf
0000ae  f50273c0          ADD      r3,r2,#0x180
0000b2  eb031300          ADD      r3,r3,r0,LSL #4
0000b6  605c              STR      r4,[r3,#4]
;;;626        CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
0000b8  f50273c0          ADD      r3,r2,#0x180
0000bc  eb031300          ADD      r3,r3,r0,LSL #4
0000c0  685b              LDR      r3,[r3,#4]
0000c2  7a8c              LDRB     r4,[r1,#0xa]
0000c4  4323              ORRS     r3,r3,r4
0000c6  f50274c0          ADD      r4,r2,#0x180
0000ca  eb041400          ADD      r4,r4,r0,LSL #4
0000ce  6063              STR      r3,[r4,#4]
;;;627    
;;;628        /* Set up the data field */
;;;629        CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
0000d0  7b8b              LDRB     r3,[r1,#0xe]
0000d2  061c              LSLS     r4,r3,#24
0000d4  7b4b              LDRB     r3,[r1,#0xd]
0000d6  ea444403          ORR      r4,r4,r3,LSL #16
0000da  7b0b              LDRB     r3,[r1,#0xc]
0000dc  ea442303          ORR      r3,r4,r3,LSL #8
0000e0  7acc              LDRB     r4,[r1,#0xb]
0000e2  4323              ORRS     r3,r3,r4
0000e4  f50274c0          ADD      r4,r2,#0x180
0000e8  eb041400          ADD      r4,r4,r0,LSL #4
0000ec  60a3              STR      r3,[r4,#8]
;;;630                                                 ((uint32_t)TxMessage->Data[2] << 16) |
;;;631                                                 ((uint32_t)TxMessage->Data[1] << 8) | 
;;;632                                                 ((uint32_t)TxMessage->Data[0]));
;;;633        CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
0000ee  7c8b              LDRB     r3,[r1,#0x12]
0000f0  061c              LSLS     r4,r3,#24
0000f2  7c4b              LDRB     r3,[r1,#0x11]
0000f4  ea444403          ORR      r4,r4,r3,LSL #16
0000f8  7c0b              LDRB     r3,[r1,#0x10]
0000fa  ea442303          ORR      r3,r4,r3,LSL #8
0000fe  7bcc              LDRB     r4,[r1,#0xf]
000100  4323              ORRS     r3,r3,r4
000102  f50274c0          ADD      r4,r2,#0x180
000106  eb041400          ADD      r4,r4,r0,LSL #4
00010a  60e3              STR      r3,[r4,#0xc]
;;;634                                                 ((uint32_t)TxMessage->Data[6] << 16) |
;;;635                                                 ((uint32_t)TxMessage->Data[5] << 8) |
;;;636                                                 ((uint32_t)TxMessage->Data[4]));
;;;637        /* Request transmission */
;;;638        CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
00010c  f50273c0          ADD      r3,r2,#0x180
000110  eb031300          ADD      r3,r3,r0,LSL #4
000114  681b              LDR      r3,[r3,#0]
000116  f0430401          ORR      r4,r3,#1
00011a  f50273c0          ADD      r3,r2,#0x180
00011e  eb031300          ADD      r3,r3,r0,LSL #4
000122  601c              STR      r4,[r3,#0]
                  |L22.292|
;;;639      }
;;;640      return transmit_mailbox;
;;;641    }
000124  bd10              POP      {r4,pc}
;;;642    
                          ENDP


                          AREA ||i.CAN_TransmitStatus||, CODE, READONLY, ALIGN=2

                  CAN_TransmitStatus PROC
;;;649      */
;;;650    uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
000000  b510              PUSH     {r4,lr}
;;;651    {
000002  4602              MOV      r2,r0
;;;652      uint32_t state = 0;
000004  2300              MOVS     r3,#0
;;;653    
;;;654      /* Check the parameters */
;;;655      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;656      assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
;;;657     
;;;658      switch (TransmitMailbox)
000006  b121              CBZ      r1,|L23.18|
000008  2901              CMP      r1,#1
00000a  d007              BEQ      |L23.28|
00000c  2902              CMP      r1,#2
00000e  d10f              BNE      |L23.48|
000010  e009              B        |L23.38|
                  |L23.18|
;;;659      {
;;;660        case (CAN_TXMAILBOX_0): 
;;;661          state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
000012  6890              LDR      r0,[r2,#8]
000014  4c1d              LDR      r4,|L23.140|
000016  ea000304          AND      r3,r0,r4
;;;662          break;
00001a  e00b              B        |L23.52|
                  |L23.28|
;;;663        case (CAN_TXMAILBOX_1): 
;;;664          state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
00001c  6890              LDR      r0,[r2,#8]
00001e  4c1c              LDR      r4,|L23.144|
000020  ea000304          AND      r3,r0,r4
;;;665          break;
000024  e006              B        |L23.52|
                  |L23.38|
;;;666        case (CAN_TXMAILBOX_2): 
;;;667          state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
000026  6890              LDR      r0,[r2,#8]
000028  4c1a              LDR      r4,|L23.148|
00002a  ea000304          AND      r3,r0,r4
;;;668          break;
00002e  e001              B        |L23.52|
                  |L23.48|
;;;669        default:
;;;670          state = CAN_TxStatus_Failed;
000030  2300              MOVS     r3,#0
;;;671          break;
000032  bf00              NOP      
                  |L23.52|
000034  bf00              NOP                            ;662
;;;672      }
;;;673      switch (state)
000036  4c18              LDR      r4,|L23.152|
000038  1b18              SUBS     r0,r3,r4
00003a  42a3              CMP      r3,r4
00003c  d016              BEQ      |L23.108|
00003e  dc07              BGT      |L23.80|
000040  b183              CBZ      r3,|L23.100|
000042  f06f6080          MVN      r0,#0x4000000
000046  4418              ADD      r0,r0,r3
000048  b170              CBZ      r0,|L23.104|
00004a  2802              CMP      r0,#2
00004c  d118              BNE      |L23.128|
00004e  e011              B        |L23.116|
                  |L23.80|
000050  f5b07f00          CMP      r0,#0x200
000054  d010              BEQ      |L23.120|
000056  4c11              LDR      r4,|L23.156|
000058  4420              ADD      r0,r0,r4
00005a  b148              CBZ      r0,|L23.112|
00005c  f5b03f00          CMP      r0,#0x20000
000060  d10e              BNE      |L23.128|
000062  e00b              B        |L23.124|
                  |L23.100|
;;;674      {
;;;675          /* transmit pending  */
;;;676        case (0x0): state = CAN_TxStatus_Pending;
000064  2302              MOVS     r3,#2
;;;677          break;
000066  e00d              B        |L23.132|
                  |L23.104|
;;;678          /* transmit failed  */
;;;679         case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
000068  2300              MOVS     r3,#0
;;;680          break;
00006a  e00b              B        |L23.132|
                  |L23.108|
;;;681         case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
00006c  2300              MOVS     r3,#0
;;;682          break;
00006e  e009              B        |L23.132|
                  |L23.112|
;;;683         case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
000070  2300              MOVS     r3,#0
;;;684          break;
000072  e007              B        |L23.132|
                  |L23.116|
;;;685          /* transmit succeeded  */
;;;686        case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
000074  2301              MOVS     r3,#1
;;;687          break;
000076  e005              B        |L23.132|
                  |L23.120|
;;;688        case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
000078  2301              MOVS     r3,#1
;;;689          break;
00007a  e003              B        |L23.132|
                  |L23.124|
;;;690        case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
00007c  2301              MOVS     r3,#1
;;;691          break;
00007e  e001              B        |L23.132|
                  |L23.128|
;;;692        default: state = CAN_TxStatus_Failed;
000080  2300              MOVS     r3,#0
;;;693          break;
000082  bf00              NOP      
                  |L23.132|
000084  bf00              NOP                            ;677
;;;694      }
;;;695      return (uint8_t) state;
000086  b2d8              UXTB     r0,r3
;;;696    }
000088  bd10              POP      {r4,pc}
;;;697    
                          ENDP

00008a  0000              DCW      0x0000
                  |L23.140|
                          DCD      0x04000003
                  |L23.144|
                          DCD      0x08000300
                  |L23.148|
                          DCD      0x10030000
                  |L23.152|
                          DCD      0x08000100
                  |L23.156|
                          DCD      0xf7ff0100

                          AREA ||i.CAN_WakeUp||, CODE, READONLY, ALIGN=1

                  CAN_WakeUp PROC
;;;978      */
;;;979    uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;980    {
;;;981      uint32_t wait_slak = SLAK_TIMEOUT;
000002  f64f72ff          MOV      r2,#0xffff
;;;982      uint8_t wakeupstatus = CAN_WakeUp_Failed;
000006  2000              MOVS     r0,#0
;;;983      
;;;984      /* Check the parameters */
;;;985      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;986        
;;;987      /* Wake up request */
;;;988      CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
000008  680b              LDR      r3,[r1,#0]
00000a  f0230302          BIC      r3,r3,#2
00000e  600b              STR      r3,[r1,#0]
;;;989        
;;;990      /* Sleep mode status */
;;;991      while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
000010  e000              B        |L24.20|
                  |L24.18|
;;;992      {
;;;993       wait_slak--;
000012  1e52              SUBS     r2,r2,#1
                  |L24.20|
000014  684b              LDR      r3,[r1,#4]            ;991
000016  f0030302          AND      r3,r3,#2              ;991
00001a  2b02              CMP      r3,#2                 ;991
00001c  d101              BNE      |L24.34|
00001e  2a00              CMP      r2,#0                 ;991
000020  d1f7              BNE      |L24.18|
                  |L24.34|
;;;994      }
;;;995      if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
000022  684b              LDR      r3,[r1,#4]
000024  f0030302          AND      r3,r3,#2
000028  2b02              CMP      r3,#2
00002a  d000              BEQ      |L24.46|
;;;996      {
;;;997       /* wake up done : Sleep mode exited */
;;;998        wakeupstatus = CAN_WakeUp_Ok;
00002c  2001              MOVS     r0,#1
                  |L24.46|
;;;999      }
;;;1000     /* return wakeup status */
;;;1001     return (uint8_t)wakeupstatus;
;;;1002   }
00002e  4770              BX       lr
;;;1003   /**
                          ENDP


                          AREA ||i.CheckITStatus||, CODE, READONLY, ALIGN=1

                  CheckITStatus PROC
;;;1674     */
;;;1675   static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
000000  4602              MOV      r2,r0
;;;1676   {
;;;1677     ITStatus pendingbitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1678     
;;;1679     if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
000004  ea020301          AND      r3,r2,r1
000008  b10b              CBZ      r3,|L25.14|
;;;1680     {
;;;1681       /* CAN_IT is set */
;;;1682       pendingbitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L25.16|
                  |L25.14|
;;;1683     }
;;;1684     else
;;;1685     {
;;;1686       /* CAN_IT is reset */
;;;1687       pendingbitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L25.16|
;;;1688     }
;;;1689     return pendingbitstatus;
;;;1690   }
000010  4770              BX       lr
;;;1691   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_can_c_347dae01____REV16|
#line 463 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_can_c_347dae01____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_can_c_347dae01____REVSH|
#line 478
|__asm___15_stm32f2xx_can_c_347dae01____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_can_c_347dae01____RRX|
#line 665
|__asm___15_stm32f2xx_can_c_347dae01____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
