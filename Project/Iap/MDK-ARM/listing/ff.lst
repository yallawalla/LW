L 1 "..\..\..\Utilities\FatFs_R0.09a\ff.c"
N/*----------------------------------------------------------------------------/
N/  FatFs - FAT file system module  R0.09a                 (C)ChaN, 2012
N/-----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following terms.
N/
N/  Copyright (C) 2012, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial products UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/
N/-----------------------------------------------------------------------------/
N/ Feb 26,'06 R0.00  Prototype.
N/
N/ Apr 29,'06 R0.01  First stable version.
N/
N/ Jun 01,'06 R0.02  Added FAT12 support.
N/                   Removed unbuffered mode.
N/                   Fixed a problem on small (<32M) partition.
N/ Jun 10,'06 R0.02a Added a configuration option (_FS_MINIMUM).
N/
N/ Sep 22,'06 R0.03  Added f_rename().
N/                   Changed option _FS_MINIMUM to _FS_MINIMIZE.
N/ Dec 11,'06 R0.03a Improved cluster scan algorithm to write files fast.
N/                   Fixed f_mkdir() creates incorrect directory on FAT32.
N/
N/ Feb 04,'07 R0.04  Supported multiple drive system.
N/                   Changed some interfaces for multiple drive system.
N/                   Changed f_mountdrv() to f_mount().
N/                   Added f_mkfs().
N/ Apr 01,'07 R0.04a Supported multiple partitions on a physical drive.
N/                   Added a capability of extending file size to f_lseek().
N/                   Added minimization level 3.
N/                   Fixed an endian sensitive code in f_mkfs().
N/ May 05,'07 R0.04b Added a configuration option _USE_NTFLAG.
N/                   Added FSInfo support.
N/                   Fixed DBCS name can result FR_INVALID_NAME.
N/                   Fixed short seek (<= csize) collapses the file object.
N/
N/ Aug 25,'07 R0.05  Changed arguments of f_read(), f_write() and f_mkfs().
N/                   Fixed f_mkfs() on FAT32 creates incorrect FSInfo.
N/                   Fixed f_mkdir() on FAT32 creates incorrect directory.
N/ Feb 03,'08 R0.05a Added f_truncate() and f_utime().
N/                   Fixed off by one error at FAT sub-type determination.
N/                   Fixed btr in f_read() can be mistruncated.
N/                   Fixed cached sector is not flushed when create and close without write.
N/
N/ Apr 01,'08 R0.06  Added fputc(), fputs(), fprintf() and fgets().
N/                   Improved performance of f_lseek() on moving to the same or following cluster.
N/
N/ Apr 01,'09 R0.07  Merged Tiny-FatFs as a configuration option. (_FS_TINY)
N/                   Added long file name feature.
N/                   Added multiple code page feature.
N/                   Added re-entrancy for multitask operation.
N/                   Added auto cluster size selection to f_mkfs().
N/                   Added rewind option to f_readdir().
N/                   Changed result code of critical errors.
N/                   Renamed string functions to avoid name collision.
N/ Apr 14,'09 R0.07a Separated out OS dependent code on reentrant cfg.
N/                   Added multiple sector size feature.
N/ Jun 21,'09 R0.07c Fixed f_unlink() can return FR_OK on error.
N/                   Fixed wrong cache control in f_lseek().
N/                   Added relative path feature.
N/                   Added f_chdir() and f_chdrive().
N/                   Added proper case conversion to extended char.
N/ Nov 03,'09 R0.07e Separated out configuration options from ff.h to ffconf.h.
N/                   Fixed f_unlink() fails to remove a sub-dir on _FS_RPATH.
N/                   Fixed name matching error on the 13 char boundary.
N/                   Added a configuration option, _LFN_UNICODE.
N/                   Changed f_readdir() to return the SFN with always upper case on non-LFN cfg.
N/
N/ May 15,'10 R0.08  Added a memory configuration option. (_USE_LFN = 3)
N/                   Added file lock feature. (_FS_SHARE)
N/                   Added fast seek feature. (_USE_FASTSEEK)
N/                   Changed some types on the API, XCHAR->TCHAR.
N/                   Changed fname member in the FILINFO structure on Unicode cfg.
N/                   String functions support UTF-8 encoding files on Unicode cfg.
N/ Aug 16,'10 R0.08a Added f_getcwd(). (_FS_RPATH = 2)
N/                   Added sector erase feature. (_USE_ERASE)
N/                   Moved file lock semaphore table from fs object to the bss.
N/                   Fixed a wrong directory entry is created on non-LFN cfg when the given name contains ';'.
N/                   Fixed f_mkfs() creates wrong FAT32 volume.
N/ Jan 15,'11 R0.08b Fast seek feature is also applied to f_read() and f_write().
N/                   f_lseek() reports required table size on creating CLMP.
N/                   Extended format syntax of f_printf function.
N/                   Ignores duplicated directory separators in given path name.
N/
N/ Sep 06,'11 R0.09  f_mkfs() supports multiple partition to finish the multiple partition feature.
N/                   Added f_fdisk(). (_MULTI_PARTITION = 2)
N/ Aug 27,'12 R0.09a Fixed assertion failure due to OS/2 EA on FAT12/16 volume.
N/                   Changed f_open() and f_opendir reject null object pointer to avoid crash.
N/                   Changed option name _FS_SHARE to _FS_LOCK.
N/---------------------------------------------------------------------------*/
N
N#include <stdio.h>	/* FatFs configurations and declarations */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060019
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 99 "..\..\..\Utilities\FatFs_R0.09a\ff.c" 2
N#include "ff.h"			/* FatFs configurations and declarations */
L 1 "..\..\..\Utilities\FatFs_R0.09a\ff.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module include file  R0.09a    (C)ChaN, 2012
N/----------------------------------------------------------------------------/
N/ FatFs module is a generic FAT file system module for small embedded systems.
N/ This is a free software that opened for education, research and commercial
N/ developments under license policy of following terms.
N/
N/  Copyright (C) 2012, ChaN, all right reserved.
N/
N/ * The FatFs module is a free software and there is NO WARRANTY.
N/ * No restriction on use. You can use, modify and redistribute it for
N/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
N/ * Redistributions of source code must retain the above copyright notice.
N/
N/----------------------------------------------------------------------------*/
N
N#ifndef _FATFS
N#define _FATFS	4004	/* Revision ID */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "integer.h"	/* Basic integer types */
L 1 "..\..\..\Utilities\FatFs_R0.09a\integer.h" 1
N/*-------------------------------------------*/
N/* Integer type definitions for FatFs module */
N/*-------------------------------------------*/
N
N#ifndef _INTEGER
N#define _INTEGER
N
N#ifdef _WIN32	/* FatFs development platform */
S
S#include <windows.h>
S#include <tchar.h>
S
N#else			/* Embedded platform */
N
N/* These types must be 16-bit, 32-bit or larger integer */
Ntypedef int							INT;
Ntypedef unsigned int		UINT;
N
N/* These types must be 8-bit integer */
Ntypedef char						CHAR;
Ntypedef unsigned char		UCHAR;
Ntypedef unsigned char		BYTE;
N
N/* These types must be 16-bit integer */
Ntypedef short						SHORT;
Ntypedef unsigned short	USHORT;
Ntypedef unsigned short	WORD;
Ntypedef unsigned short	WCHAR;
N
N/* These types must be 32-bit integer */
Ntypedef long						LONG;
Ntypedef unsigned long		ULONG;
Ntypedef unsigned long		DWORD;
N
N#endif
N
N#endif
L 25 "..\..\..\Utilities\FatFs_R0.09a\ff.h" 2
N#include "ffconf.h"		/* FatFs configuration options */
L 1 "..\Inc\ffconf.h" 1
N/*---------------------------------------------------------------------------/
N/  FatFs - FAT file system module configuration file  R0.09a (C)ChaN, 2012
N/----------------------------------------------------------------------------/
N/
N/ CAUTION! Do not forget to make clean the project after any changes to
N/ the configuration options.
N/
N/----------------------------------------------------------------------------*/
N#ifndef _FFCONF
N#define _FFCONF 4004	/* Revision ID */
N
N
N/*---------------------------------------------------------------------------/
N/ Functions and Buffer Configurations
N/----------------------------------------------------------------------------*/
N
N#define	_FS_TINY		0	/* 0:Normal or 1:Tiny */
N/* When _FS_TINY is set to 1, FatFs uses the sector buffer in the file system
N/  object instead of the sector buffer in the individual file object for file
N/  data transfer. This reduces memory consumption 512 bytes each file object. */
N
N
N#define _FS_READONLY	1	/* 0:Read/Write or 1:Read only */
N/* Setting _FS_READONLY to 1 defines read only configuration. This removes
N/  writing functions, f_write, f_sync, f_unlink, f_mkdir, f_chmod, f_rename,
N/  f_truncate and useless f_getfree. */
N
N
N#define _FS_MINIMIZE	0	/* 0 to 3 */
N/* The _FS_MINIMIZE option defines minimization level to remove some functions.
N/
N/   0: Full function.
N/   1: f_stat, f_getfree, f_unlink, f_mkdir, f_chmod, f_truncate and f_rename
N/      are removed.
N/   2: f_opendir and f_readdir are removed in addition to 1.
N/   3: f_lseek is removed in addition to 2. */
N
N
N#define	_USE_STRFUNC	1	/* 0:Disable or 1-2:Enable */
N/* To enable string functions, set _USE_STRFUNC to 1 or 2. */
N
N
N#define	_USE_MKFS		1	/* 0:Disable or 1:Enable */
N/* To enable f_mkfs function, set _USE_MKFS to 1 and set _FS_READONLY to 0 */
N
N
N#define	_USE_FORWARD	0	/* 0:Disable or 1:Enable */
N/* To enable f_forward function, set _USE_FORWARD to 1 and set _FS_TINY to 1. */
N
N
N#define	_USE_FASTSEEK	0	/* 0:Disable or 1:Enable */
N/* To enable fast seek feature, set _USE_FASTSEEK to 1. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ Locale and Namespace Configurations
N/----------------------------------------------------------------------------*/
N
N#define _CODE_PAGE	1250
N/* The _CODE_PAGE specifies the OEM code page to be used on the target system.
N/  Incorrect setting of the code page can cause a file open failure.
N/
N/   932  - Japanese Shift-JIS (DBCS, OEM, Windows)
N/   936  - Simplified Chinese GBK (DBCS, OEM, Windows)
N/   949  - Korean (DBCS, OEM, Windows)
N/   950  - Traditional Chinese Big5 (DBCS, OEM, Windows)
N/   1250 - Central Europe (Windows)
N/   1251 - Cyrillic (Windows)
N/   1252 - Latin 1 (Windows)
N/   1253 - Greek (Windows)
N/   1254 - Turkish (Windows)
N/   1255 - Hebrew (Windows)
N/   1256 - Arabic (Windows)
N/   1257 - Baltic (Windows)
N/   1258 - Vietnam (OEM, Windows)
N/   437  - U.S. (OEM)
N/   720  - Arabic (OEM)
N/   737  - Greek (OEM)
N/   775  - Baltic (OEM)
N/   850  - Multilingual Latin 1 (OEM)
N/   858  - Multilingual Latin 1 + Euro (OEM)
N/   852  - Latin 2 (OEM)
N/   855  - Cyrillic (OEM)
N/   866  - Russian (OEM)
N/   857  - Turkish (OEM)
N/   862  - Hebrew (OEM)
N/   874  - Thai (OEM, Windows)
N/	1    - ASCII only (Valid for non LFN cfg.)
N*/
N
N
N#define	_USE_LFN	2		/* 0 to 3 */
N#define	_MAX_LFN	255		/* Maximum LFN length to handle (12 to 255) */
N/* The _USE_LFN option switches the LFN support.
N/
N/   0: Disable LFN feature. _MAX_LFN and _LFN_UNICODE have no effect.
N/   1: Enable LFN with static working buffer on the BSS. Always NOT reentrant.
N/   2: Enable LFN with dynamic working buffer on the STACK.
N/   3: Enable LFN with dynamic working buffer on the HEAP.
N/
N/  The LFN working buffer occupies (_MAX_LFN + 1) * 2 bytes. To enable LFN,
N/  Unicode handling functions ff_convert() and ff_wtoupper() must be added
N/  to the project. When enable to use heap, memory control functions
N/  ff_memalloc() and ff_memfree() must be added to the project. */
N
N
N#define	_LFN_UNICODE	0	/* 0:ANSI/OEM or 1:Unicode */
N/* To switch the character code set on FatFs API to Unicode,
N/  enable LFN feature and set _LFN_UNICODE to 1. */
N
N
N#define _FS_RPATH		2	/* 0 to 2 */
N/* The _FS_RPATH option configures relative path feature.
N/
N/   0: Disable relative path feature and remove related functions.
N/   1: Enable relative path. f_chdrive() and f_chdir() are available.
N/   2: f_getcwd() is available in addition to 1.
N/
N/  Note that output of the f_readdir fnction is affected by this option. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ Physical Drive Configurations
N/----------------------------------------------------------------------------*/
N
N#define _VOLUMES	2
N/* Number of volumes (logical drives) to be used. */
N
N
N#define	_MAX_SS		512		/* 512, 1024, 2048 or 4096 */
N/* Maximum sector size to be handled.
N/  Always set 512 for memory card and hard disk but a larger value may be
N/  required for on-board flash memory, floppy disk and optical disk.
N/  When _MAX_SS is larger than 512, it configures FatFs to variable sector size
N/  and GET_SECTOR_SIZE command must be implememted to the disk_ioctl function. */
N
N
N#define	_MULTI_PARTITION	0	/* 0:Single partition, 1/2:Enable multiple partition */
N/* When set to 0, each volume is bound to the same physical drive number and
N/ it can mount only first primaly partition. When it is set to 1, each volume
N/ is tied to the partitions listed in VolToPart[]. */
N
N
N#define	_USE_ERASE	0	/* 0:Disable or 1:Enable */
N/* To enable sector erase feature, set _USE_ERASE to 1. CTRL_ERASE_SECTOR command
N/  should be added to the disk_ioctl functio. */
N
N
N
N/*---------------------------------------------------------------------------/
N/ System Configurations
N/----------------------------------------------------------------------------*/
N
N#define _WORD_ACCESS	0	/* 0 or 1 */
N/* Set 0 first and it is always compatible with all platforms. The _WORD_ACCESS
N/  option defines which access method is used to the word data on the FAT volume.
N/
N/   0: Byte-by-byte access.
N/   1: Word access. Do not choose this unless following condition is met.
N/
N/  When the byte order on the memory is big-endian or address miss-aligned word
N/  access results incorrect behavior, the _WORD_ACCESS must be set to 0.
N/  If it is not the case, the value can also be set to 1 to improve the
N/  performance and code size.
N*/
N
N
N/* A header file that defines sync object types on the O/S, such as
N/  windows.h, ucos_ii.h and semphr.h, must be included prior to ff.h. */
N
N#define _FS_REENTRANT	0		/* 0:Disable or 1:Enable */
N#define _FS_TIMEOUT		1000	/* Timeout period in unit of time ticks */
N#define	_SYNC_t			HANDLE	/* O/S dependent type of sync object. e.g. HANDLE, OS_EVENT*, ID and etc.. */
N
N/* The _FS_REENTRANT option switches the reentrancy (thread safe) of the FatFs module.
N/
N/   0: Disable reentrancy. _SYNC_t and _FS_TIMEOUT have no effect.
N/   1: Enable reentrancy. Also user provided synchronization handlers,
N/      ff_req_grant, ff_rel_grant, ff_del_syncobj and ff_cre_syncobj
N/      function must be added to the project. */
N
N
N#define	_FS_LOCK	0	/* 0:Disable or >=1:Enable */
N/* To enable file lock control feature, set _FS_LOCK to 1 or greater.
N   The value defines how many files can be opened simultaneously. */
N
N
N#endif /* _FFCONFIG */
L 26 "..\..\..\Utilities\FatFs_R0.09a\ff.h" 2
N
N#if _FATFS != _FFCONF
X#if 4004 != 4004
S#error Wrong configuration file (ffconf.h).
N#endif
N
N
N
N/* Definitions of volume management */
N
N#if _MULTI_PARTITION		/* Multiple partition configuration */
X#if 0		 
Stypedef struct {
S	BYTE pd;	/* Physical drive number */
S	BYTE pt;	/* Partition: 0:Auto detect, 1-4:Forced partition) */
S} PARTITION;
Sextern PARTITION VolToPart[];	/* Volume - Partition resolution table */
S#define LD2PD(vol) (VolToPart[vol].pd)	/* Get physical drive number */
S#define LD2PT(vol) (VolToPart[vol].pt)	/* Get partition index */
S
N#else							/* Single partition configuration */
N#define LD2PD(vol) (BYTE)(vol)	/* Each logical drive is bound to the same physical drive number */
N#define LD2PT(vol) 0			/* Always mounts the 1st partition or in SFD */
N
N#endif
N
N
N
N/* Type of path name strings on FatFs API */
N
N#if _LFN_UNICODE			/* Unicode string */
X#if 0			 
S#if !_USE_LFN
S#error _LFN_UNICODE must be 0 in non-LFN cfg.
S#endif
S#ifndef _INC_TCHAR
Stypedef WCHAR TCHAR;
S#define _T(x) L ## x
S#define _TEXT(x) L ## x
S#endif
S
N#else						/* ANSI/OEM string */
N#ifndef _INC_TCHAR
Ntypedef char TCHAR;
N#define _T(x) x
N#define _TEXT(x) x
N#endif
N
N#endif
N
N
N/* File system object structure (FATFS) */
N
Ntypedef struct {
N	BYTE	fs_type;		/* FAT sub-type (0:Not mounted) */
N	BYTE	drv;			/* Physical drive number */
N	BYTE	csize;			/* Sectors per cluster (1,2,4...128) */
N	BYTE	n_fats;			/* Number of FAT copies (1,2) */
N	BYTE	wflag;			/* win[] dirty flag (1:must be written back) */
N	BYTE	fsi_flag;		/* fsinfo dirty flag (1:must be written back) */
N	WORD	id;				/* File system mount ID */
N	WORD	n_rootdir;		/* Number of root directory entries (FAT12/16) */
N#if _MAX_SS != 512
X#if 512 != 512
S	WORD	ssize;			/* Bytes per sector (512, 1024, 2048 or 4096) */
N#endif
N#if _FS_REENTRANT
X#if 0
S	_SYNC_t	sobj;			/* Identifier of sync object */
N#endif
N#if !_FS_READONLY
X#if !1
S	DWORD	last_clust;		/* Last allocated cluster */
S	DWORD	free_clust;		/* Number of free clusters */
S	DWORD	fsi_sector;		/* fsinfo sector (FAT32) */
N#endif
N#if _FS_RPATH
X#if 2
N	DWORD	cdir;			/* Current directory start cluster (0:root) */
N#endif
N	DWORD	n_fatent;		/* Number of FAT entries (= number of clusters + 2) */
N	DWORD	fsize;			/* Sectors per FAT */
N	DWORD	fatbase;		/* FAT start sector */
N	DWORD	dirbase;		/* Root directory start sector (FAT32:Cluster#) */
N	DWORD	database;		/* Data start sector */
N	DWORD	winsect;		/* Current sector appearing in the win[] */
N	BYTE	win[_MAX_SS];	/* Disk access window for Directory, FAT (and Data on tiny cfg) */
X	BYTE	win[512];	 
N} FATFS;
N
N
N
N/* File object structure (FIL) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the related file system object */
N	WORD	id;				/* File system mount ID of the related file system object */
N	BYTE	flag;			/* File status flags */
N	BYTE	pad1;
N	DWORD	fptr;			/* File read/write pointer (0ed on file open) */
N	DWORD	fsize;			/* File size */
N	DWORD	sclust;			/* File data start cluster (0:no data cluster, always 0 when fsize is 0) */
N	DWORD	clust;			/* Current cluster of fpter */
N	DWORD	dsect;			/* Current data sector of fpter */
N#if !_FS_READONLY
X#if !1
S	DWORD	dir_sect;		/* Sector containing the directory entry */
S	BYTE*	dir_ptr;		/* Pointer to the directory entry in the window */
N#endif
N#if _USE_FASTSEEK
X#if 0
S	DWORD*	cltbl;			/* Pointer to the cluster link map table (null on file open) */
N#endif
N#if _FS_LOCK
X#if 0
S	UINT	lockid;			/* File lock ID (index of file semaphore table Files[]) */
N#endif
N#if !_FS_TINY
X#if !0
N	BYTE	buf[_MAX_SS];	/* File data read/write buffer */
X	BYTE	buf[512];	 
N#endif
N} FIL;
N
N
N
N/* Directory object structure (DIR) */
N
Ntypedef struct {
N	FATFS*	fs;				/* Pointer to the owner file system object */
N	WORD	id;				/* Owner file system mount ID */
N	WORD	index;			/* Current read/write index number */
N	DWORD	sclust;			/* Table start cluster (0:Root dir) */
N	DWORD	clust;			/* Current cluster */
N	DWORD	sect;			/* Current sector */
N	BYTE*	dir;			/* Pointer to the current SFN entry in the win[] */
N	BYTE*	fn;				/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */
N#if _USE_LFN
X#if 2
N	WCHAR*	lfn;			/* Pointer to the LFN working buffer */
N	WORD	lfn_idx;		/* Last matched LFN index number (0xFFFF:No LFN) */
N#endif
N} DIR;
N
N
N
N/* File status structure (FILINFO) */
N
Ntypedef struct {
N	DWORD	fsize;			/* File size */
N	WORD	fdate;			/* Last modified date */
N	WORD	ftime;			/* Last modified time */
N	BYTE	fattrib;		/* Attribute */
N	TCHAR	fname[13];		/* Short file name (8.3 format) */
N#if _USE_LFN
X#if 2
N	TCHAR*	lfname;			/* Pointer to the LFN buffer */
N	UINT 	lfsize;			/* Size of LFN buffer in TCHAR */
N#endif
N} FILINFO;
N
N
N
N/* File function return code (FRESULT) */
N
Ntypedef enum {
N	FR_OK = 0,				/* (0) Succeeded */
N	FR_DISK_ERR,			/* (1) A hard error occurred in the low level disk I/O layer */
N	FR_INT_ERR,				/* (2) Assertion failed */
N	FR_NOT_READY,			/* (3) The physical drive cannot work */
N	FR_NO_FILE,				/* (4) Could not find the file */
N	FR_NO_PATH,				/* (5) Could not find the path */
N	FR_INVALID_NAME,		/* (6) The path name format is invalid */
N	FR_DENIED,				/* (7) Access denied due to prohibited access or directory full */
N	FR_EXIST,				/* (8) Access denied due to prohibited access */
N	FR_INVALID_OBJECT,		/* (9) The file/directory object is invalid */
N	FR_WRITE_PROTECTED,		/* (10) The physical drive is write protected */
N	FR_INVALID_DRIVE,		/* (11) The logical drive number is invalid */
N	FR_NOT_ENABLED,			/* (12) The volume has no work area */
N	FR_NO_FILESYSTEM,		/* (13) There is no valid FAT volume */
N	FR_MKFS_ABORTED,		/* (14) The f_mkfs() aborted due to any parameter error */
N	FR_TIMEOUT,				/* (15) Could not get a grant to access the volume within defined period */
N	FR_LOCKED,				/* (16) The operation is rejected according to the file sharing policy */
N	FR_NOT_ENOUGH_CORE,		/* (17) LFN working buffer could not be allocated */
N	FR_TOO_MANY_OPEN_FILES,	/* (18) Number of open files > _FS_SHARE */
N	FR_INVALID_PARAMETER	/* (19) Given parameter is invalid */
N} FRESULT;
N
N
N
N/*--------------------------------------------------------------*/
N/* FatFs module application interface                           */
N
NFRESULT f_mount (BYTE, FATFS*);						/* Mount/Unmount a logical drive */
NFRESULT f_open (FIL*, const TCHAR*, BYTE);			/* Open or create a file */
NFRESULT f_read (FIL*, void*, UINT, UINT*);			/* Read data from a file */
NFRESULT f_lseek (FIL*, DWORD);						/* Move file pointer of a file object */
NFRESULT f_close (FIL*);								/* Close an open file object */
NFRESULT f_opendir (DIR*, const TCHAR*);				/* Open an existing directory */
NFRESULT f_readdir (DIR*, FILINFO*);					/* Read a directory item */
NFRESULT f_stat (const TCHAR*, FILINFO*);			/* Get file status */
NFRESULT f_write (FIL*, const void*, UINT, UINT*);	/* Write data to a file */
NFRESULT f_getfree (const TCHAR*, DWORD*, FATFS**);	/* Get number of free clusters on the drive */
NFRESULT f_truncate (FIL*);							/* Truncate file */
NFRESULT f_sync (FIL*);								/* Flush cached data of a writing file */
NFRESULT f_unlink (const TCHAR*);					/* Delete an existing file or directory */
NFRESULT	f_mkdir (const TCHAR*);						/* Create a new directory */
NFRESULT f_chmod (const TCHAR*, BYTE, BYTE);			/* Change attribute of the file/dir */
NFRESULT f_utime (const TCHAR*, const FILINFO*);		/* Change times-tamp of the file/dir */
NFRESULT f_rename (const TCHAR*, const TCHAR*);		/* Rename/Move a file or directory */
NFRESULT f_chdrive (BYTE);							/* Change current drive */
NFRESULT f_chdir (const TCHAR*);						/* Change current directory */
NFRESULT f_getcwd (TCHAR*, UINT);					/* Get current directory */
NFRESULT f_forward (FIL*, UINT(*)(const BYTE*,UINT), UINT, UINT*);	/* Forward data to the stream */
NFRESULT f_mkfs (BYTE, BYTE, UINT);					/* Create a file system on the drive */
NFRESULT	f_fdisk (BYTE, const DWORD[], void*);		/* Divide a physical drive into some partitions */
Nint f_putc (TCHAR, FIL*);							/* Put a character to the file */
Nint f_puts (const TCHAR*, FIL*);					/* Put a string to the file */
Nint f_printf (FIL*, const TCHAR*, ...);				/* Put a formatted string to the file */
NTCHAR* f_gets (TCHAR*, int, FIL*);					/* Get a string from the file */
N
N#define f_eof(fp) (((fp)->fptr == (fp)->fsize) ? 1 : 0)
N#define f_error(fp) (((fp)->flag & FA__ERROR) ? 1 : 0)
N#define f_tell(fp) ((fp)->fptr)
N#define f_size(fp) ((fp)->fsize)
N
N#ifndef EOF
S#define EOF (-1)
N#endif
N
N
N/*--------------------------------------------------------------*/
N/* Additional user defined functions                            */
N
N/* RTC function */
N#if !_FS_READONLY
X#if !1
SDWORD get_fattime (void);
N#endif
N
N/* Unicode support functions */
N#if _USE_LFN						/* Unicode - OEM code conversion */
X#if 2						 
NWCHAR ff_convert (WCHAR, UINT);		/* OEM-Unicode bidirectional conversion */
NWCHAR ff_wtoupper (WCHAR);			/* Unicode upper-case conversion */
N#if _USE_LFN == 3					/* Memory functions */
X#if 2 == 3					 
Svoid* ff_memalloc (UINT);			/* Allocate memory block */
Svoid ff_memfree (void*);			/* Free memory block */
N#endif
N#endif
N
N/* Sync functions */
N#if _FS_REENTRANT
X#if 0
Sint ff_cre_syncobj (BYTE, _SYNC_t*);/* Create a sync object */
Sint ff_req_grant (_SYNC_t);			/* Lock sync object */
Svoid ff_rel_grant (_SYNC_t);		/* Unlock sync object */
Sint ff_del_syncobj (_SYNC_t);		/* Delete a sync object */
N#endif
N
N/*--------------------------------------------------------------*/
N/* Flags and offset address                                     */
N
N
N/* File access control and file status flags (FIL.flag) */
N
N#define	FA_READ				0x01
N#define	FA_OPEN_EXISTING	0x00
N#define FA__ERROR			0x80
N
N#if !_FS_READONLY
X#if !1
S#define	FA_WRITE			0x02
S#define	FA_CREATE_NEW		0x04
S#define	FA_CREATE_ALWAYS	0x08
S#define	FA_OPEN_ALWAYS		0x10
S#define FA__WRITTEN			0x20
S#define FA__DIRTY			0x40
N#endif
N
N/* FAT sub type (FATFS.fs_type) */
N
N#define FS_FAT12	1
N#define FS_FAT16	2
N#define FS_FAT32	3
N
N
N/* File attribute bits for directory entry */
N
N#define	AM_RDO	0x01	/* Read only */
N#define	AM_HID	0x02	/* Hidden */
N#define	AM_SYS	0x04	/* System */
N#define	AM_VOL	0x08	/* Volume label */
N#define AM_LFN	0x0F	/* LFN entry */
N#define AM_DIR	0x10	/* Directory */
N#define AM_ARC	0x20	/* Archive */
N#define AM_MASK	0x3F	/* Mask of defined bits */
N
N/* Fast seek feature */
N#define CREATE_LINKMAP	0xFFFFFFFF
N
N/*--------------------------------*/
N/* Multi-byte word access macros  */
N
N#if _WORD_ACCESS == 1	/* Enable word access to the FAT structure */
X#if 0 == 1	 
S#define	LD_WORD(ptr)		(WORD)(*(WORD*)(BYTE*)(ptr))
S#define	LD_DWORD(ptr)		(DWORD)(*(DWORD*)(BYTE*)(ptr))
S#define	ST_WORD(ptr,val)	*(WORD*)(BYTE*)(ptr)=(WORD)(val)
S#define	ST_DWORD(ptr,val)	*(DWORD*)(BYTE*)(ptr)=(DWORD)(val)
N#else					/* Use byte-by-byte access to the FAT structure */
N#define	LD_WORD(ptr)		(WORD)(((WORD)*((BYTE*)(ptr)+1)<<8)|(WORD)*(BYTE*)(ptr))
N#define	LD_DWORD(ptr)		(DWORD)(((DWORD)*((BYTE*)(ptr)+3)<<24)|((DWORD)*((BYTE*)(ptr)+2)<<16)|((WORD)*((BYTE*)(ptr)+1)<<8)|*(BYTE*)(ptr))
N#define	ST_WORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8)
N#define	ST_DWORD(ptr,val)	*(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)>>8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)>>16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)>>24)
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* _FATFS */
L 100 "..\..\..\Utilities\FatFs_R0.09a\ff.c" 2
N#include "diskio.h"	/* Declarations of low level disk I/O functions */
L 1 "..\..\..\Utilities\FatFs_R0.09a\diskio.h" 1
N/*-----------------------------------------------------------------------
N/  Low level disk interface modlue include file   (C)ChaN, 2012
N/-----------------------------------------------------------------------*/
N
N#ifndef _DISKIO_DEFINED
N#define _DISKIO_DEFINED
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define _USE_WRITE	1	/* 1: Enable disk_write function */
N#define _USE_IOCTL	1	/* 1: Enable disk_ioctl fucntion */
N
N#include "integer.h"
N#include "stdint.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 17 "..\..\..\Utilities\FatFs_R0.09a\diskio.h" 2
N	
N
N#define	PAGE_SIZE					0x20000
N#define	PAGE_COUNT				5
N	
N#define	SECTOR_SIZE				512
N#define	CLUSTER_SIZE			4096
N#define	SECTOR_COUNT			((int)PAGE_SIZE*PAGE_COUNT/(SECTOR_SIZE+4))
N
Nint8_t	STORAGE_Init (uint8_t);
Nint8_t	STORAGE_GetCapacity (uint8_t, uint32_t *, uint32_t *);
Nint8_t	STORAGE_IsReady (uint8_t);
Nint8_t	STORAGE_IsWriteProtected (uint8_t);
Nint8_t	STORAGE_Read (uint8_t, uint8_t *, uint32_t, uint16_t);
Nint8_t	STORAGE_Write (uint8_t, uint8_t *, uint32_t, uint16_t);
Nint8_t	STORAGE_GetMaxLun (void);
N
N/* Status of Disk Functions */
Ntypedef BYTE	DSTATUS;
N
N/* Results of Disk Functions */
Ntypedef enum {
N	RES_OK = 0,		/* 0: Successful */
N	RES_ERROR,		/* 1: R/W Error */
N	RES_WRPRT,		/* 2: Write Protected */
N	RES_NOTRDY,		/* 3: Not Ready */
N	RES_PARERR		/* 4: Invalid Parameter */
N} DRESULT;
N
N
N/*---------------------------------------*/
N/* Prototypes for disk control functions */
N
N
NDSTATUS disk_initialize (BYTE);
NDSTATUS disk_status (BYTE);
NDRESULT disk_read (BYTE, BYTE*, DWORD, BYTE);
N#if	_READONLY == 0
NDRESULT disk_write (BYTE, const BYTE*, DWORD, BYTE);
N#endif
NDRESULT disk_ioctl (BYTE, BYTE, void*);
N
N
N/* Disk Status Bits (DSTATUS) */
N#define STA_NOINIT		0x01	/* Drive not initialized */
N#define STA_NODISK		0x02	/* No medium in the drive */
N#define STA_PROTECT		0x04	/* Write protected */
N
N
N/* Command code for disk_ioctrl fucntion */
N
N/* Generic command (used by FatFs) */
N#define CTRL_SYNC			0	/* Flush disk cache (for write functions) */
N#define GET_SECTOR_COUNT	1	/* Get media size (for only f_mkfs()) */
N#define GET_SECTOR_SIZE		2	/* Get sector size (for multiple sector size (_MAX_SS >= 1024)) */
N#define GET_BLOCK_SIZE		3	/* Get erase block size (for only f_mkfs()) */
N#define CTRL_ERASE_SECTOR	4	/* Force erased a block of sectors (for only _USE_ERASE) */
N
N/* Generic command (not used by FatFs) */
N#define CTRL_POWER			5	/* Get/Set power status */
N#define CTRL_LOCK			6	/* Lock/Unlock media removal */
N#define CTRL_EJECT			7	/* Eject media */
N#define CTRL_FORMAT			8	/* Create physical format on the media */
N
N/* MMC/SDC specific ioctl command */
N#define MMC_GET_TYPE		10	/* Get card type */
N#define MMC_GET_CSD			11	/* Get CSD */
N#define MMC_GET_CID			12	/* Get CID */
N#define MMC_GET_OCR			13	/* Get OCR */
N#define MMC_GET_SDSTAT		14	/* Get SD status */
N
N/* ATA/CF specific ioctl command */
N#define ATA_GET_REV			20	/* Get F/W revision */
N#define ATA_GET_MODEL		21	/* Get model name */
N#define ATA_GET_SN			22	/* Get serial number */
N
N
N/* MMC card type flags (MMC_GET_TYPE) */
N#define CT_MMC		0x01		/* MMC ver 3 */
N#define CT_SD1		0x02		/* SD ver 1 */
N#define CT_SD2		0x04		/* SD ver 2 */
N#define CT_SDC		(CT_SD1|CT_SD2)	/* SD */
N#define CT_BLOCK	0x08		/* Block addressing */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 101 "..\..\..\Utilities\FatFs_R0.09a\ff.c" 2
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Definitions
N
N---------------------------------------------------------------------------*/
N
N#if _FATFS != 4004	/* Revision ID */
X#if 4004 != 4004	 
S#error Wrong include file (ff.h).
N#endif
N
N
N/* Definitions on sector size */
N#if _MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096
X#if 512 != 512 && 512 != 1024 && 512 != 2048 && 512 != 4096
S#error Wrong sector size.
N#endif
N#if _MAX_SS != 512
X#if 512 != 512
S#define	SS(fs)	((fs)->ssize)	/* Variable sector size */
N#else
N#define	SS(fs)	512U			/* Fixed sector size */
N#endif
N
N
N/* Reentrancy related */
N#if _FS_REENTRANT
X#if 0
S#if _USE_LFN == 1
S#error Static LFN work area must not be used in re-entrant configuration.
S#endif
S#define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
S#define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
N#else
N#define	ENTER_FF(fs)
N#define LEAVE_FF(fs, res)	return res
N#endif
N
N#define	ABORT(fs, res)		{ fp->flag |= FA__ERROR; LEAVE_FF(fs, res); }
N
N
N/* File access control feature */
N#if _FS_LOCK
X#if 0
S#if _FS_READONLY
S#error _FS_LOCK must be 0 on read-only cfg.
S#endif
Stypedef struct {
S	FATFS *fs;				/* File ID 1, volume (NULL:blank entry) */
S	DWORD clu;				/* File ID 2, directory */
S	WORD idx;				/* File ID 3, directory index */
S	WORD ctr;				/* File open counter, 0:none, 0x01..0xFF:read open count, 0x100:write mode */
S} FILESEM;
N#endif
N
N
N
N/* DBCS code ranges and SBCS extend char conversion table */
N
N#if _CODE_PAGE == 932	/* Japanese Shift-JIS */
X#if 1250 == 932	 
S#define _DF1S	0x81	/* DBC 1st byte range 1 start */
S#define _DF1E	0x9F	/* DBC 1st byte range 1 end */
S#define _DF2S	0xE0	/* DBC 1st byte range 2 start */
S#define _DF2E	0xFC	/* DBC 1st byte range 2 end */
S#define _DS1S	0x40	/* DBC 2nd byte range 1 start */
S#define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
S#define _DS2S	0x80	/* DBC 2nd byte range 2 start */
S#define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
S
S#elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
X#elif 1250 == 936	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0x80
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 949	/* Korean */
X#elif 1250 == 949	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x41
S#define _DS1E	0x5A
S#define _DS2S	0x61
S#define _DS2E	0x7A
S#define _DS3S	0x81
S#define _DS3E	0xFE
S
S#elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
X#elif 1250 == 950	 
S#define _DF1S	0x81
S#define _DF1E	0xFE
S#define _DS1S	0x40
S#define _DS1E	0x7E
S#define _DS2S	0xA1
S#define _DS2E	0xFE
S
S#elif _CODE_PAGE == 437	/* U.S. (OEM) */
X#elif 1250 == 437	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F,0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 720	/* Arabic (OEM) */
X#elif 1250 == 720	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x45,0x41,0x84,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x49,0x49,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 737	/* Greek (OEM) */
X#elif 1250 == 737	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
S				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, 				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xE7,0xE8,0xF1,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 775	/* Baltic (OEM) */
X#elif 1250 == 775	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 850	/* Multilingual Latin 1 (OEM) */
X#elif 1250 == 850	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 852	/* Latin 2 (OEM) */
X#elif 1250 == 852	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F,0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
S
S#elif _CODE_PAGE == 855	/* Cyrillic (OEM) */
X#elif 1250 == 855	 
S#define _DF1S	0
S#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
S				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
S				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F,0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, 				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, 				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 857	/* Turkish (OEM) */
X#elif 1250 == 857	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x98,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0x59,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 858	/* Multilingual Latin 1 + Euro (OEM) */
X#elif 1250 == 858	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
S				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0xDE,0x8E,0x8F,0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x59,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, 				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD1,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE7,0xE9,0xEA,0xEB,0xED,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 862	/* Hebrew (OEM) */
X#elif 1250 == 862	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0x21,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 866	/* Russian (OEM) */
X#elif 1250 == 866	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F,0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 874	/* Thai (OEM, Windows) */
X#elif 1250 == 874	 
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
N#elif _CODE_PAGE == 1250 /* Central Europe (Windows) */
X#elif 1250 == 1250  
N#define _DF1S	0
N#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
N				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, \
N				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
N				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
N
N#elif _CODE_PAGE == 1251 /* Cyrillic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, \
S				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
X#define _EXCVT {0x80,0x81,0x82,0x82,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x80,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 				0xA0,0xA2,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB2,0xA5,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xA3,0xBD,0xBD,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF}
S
S#elif _CODE_PAGE == 1252 /* Latin 1 (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0xAd,0x9B,0x8C,0x9D,0xAE,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1253 /* Greek (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, \
S				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xA2,0xB8,0xB9,0xBA, 				0xE0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xFB,0xBC,0xFD,0xBF,0xFF}
S
S#elif _CODE_PAGE == 1254 /* Turkish (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0x9F}
S
S#elif _CODE_PAGE == 1255 /* Hebrew (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF,0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1256 /* Arabic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x8C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0x41,0xE1,0x41,0xE3,0xE4,0xE5,0xE6,0x43,0x45,0x45,0x45,0x45,0xEC,0xED,0x49,0x49,0xF0,0xF1,0xF2,0xF3,0x4F,0xF5,0xF6,0xF7,0xF8,0x55,0xFA,0x55,0x55,0xFD,0xFE,0xFF}
S
S#elif _CODE_PAGE == 1257 /* Baltic (Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
S				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, 				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xA8,0xB9,0xAA,0xBB,0xBC,0xBD,0xBE,0xAF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF}
S
S#elif _CODE_PAGE == 1258 /* Vietnam (OEM, Windows) */
S#define _DF1S	0
S#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, \
S				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
S				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
X#define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0xAC,0x9D,0x9E,0x9F, 				0xA0,0x21,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xEC,0xCD,0xCE,0xCF,0xD0,0xD1,0xF2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xFE,0x9F}
S
S#elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
S#if _USE_LFN
S#error Cannot use LFN feature without valid code page.
S#endif
S#define _DF1S	0
S
S#else
S#error Unknown code page
S
N#endif
N
N
N/* Character code support macros */
N#define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
N#define IsLower(c)	(((c)>='a')&&((c)<='z'))
N#define IsDigit(c)	(((c)>='0')&&((c)<='9'))
N
N#if _DF1S		/* Code page is DBCS */
X#if 0		 
S
S#ifdef _DF2S	/* Two 1st byte areas */
S#define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
S#else			/* One 1st byte area */
S#define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
S#endif
S
S#ifdef _DS3S	/* Three 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
S#else			/* Two 2nd byte areas */
S#define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
S#endif
S
N#else			/* Code page is SBCS */
N
N#define IsDBCS1(c)	0
N#define IsDBCS2(c)	0
N
N#endif /* _DF1S */
N
N
N/* Name status flags */
N#define NS				11		/* Index of name status byte in fn[] */
N#define NS_LOSS		0x01	/* Out of 8.3 format */
N#define NS_LFN		0x02	/* Force to create LFN entry */
N#define NS_LAST		0x04	/* Last segment */
N#define NS_BODY		0x08	/* Lower case flag (body) */
N#define NS_EXT		0x10	/* Lower case flag (ext) */
N#define NS_DOT		0x20	/* Dot entry */
N
N
N/* FAT sub-type boundaries */
N/* Note that the FAT spec by Microsoft says 4085 but Windows works with 4087! */
N#define MIN_FAT16	4086	/* Minimum number of clusters for FAT16 */
N#define	MIN_FAT32	65526	/* Minimum number of clusters for FAT32 */
N
N
N/* FatFs refers the members in the FAT structures as byte array instead of
N/ structure member because the structure is not binary compatible between
N/ different platforms */
N
N#define BS_jmpBoot			0		/* Jump instruction (3) */
N#define BS_OEMName			3		/* OEM name (8) */
N#define BPB_BytsPerSec	11	/* Sector size [byte] (2) */
N#define BPB_SecPerClus	13	/* Cluster size [sector] (1) */
N#define BPB_RsvdSecCnt	14	/* Size of reserved area [sector] (2) */
N#define BPB_NumFATs			16	/* Number of FAT copies (1) */
N#define BPB_RootEntCnt	17	/* Number of root dir entries for FAT12/16 (2) */
N#define BPB_TotSec16		19	/* Volume size [sector] (2) */
N#define BPB_Media				21	/* Media descriptor (1) */
N#define BPB_FATSz16			22	/* FAT size [sector] (2) */
N#define BPB_SecPerTrk		24	/* Track size [sector] (2) */
N#define BPB_NumHeads		26	/* Number of heads (2) */
N#define BPB_HiddSec			28	/* Number of special hidden sectors (4) */
N#define BPB_TotSec32		32	/* Volume size [sector] (4) */
N#define BS_DrvNum				36	/* Physical drive number (2) */
N#define BS_BootSig			38	/* Extended boot signature (1) */
N#define BS_VolID				39	/* Volume serial number (4) */
N#define BS_VolLab				43	/* Volume label (8) */
N#define BS_FilSysType		54	/* File system type (1) */
N#define BPB_FATSz32			36	/* FAT size [sector] (4) */
N#define BPB_ExtFlags		40	/* Extended flags (2) */
N#define BPB_FSVer				42	/* File system version (2) */
N#define BPB_RootClus		44	/* Root dir first cluster (4) */
N#define BPB_FSInfo			48	/* Offset of FSInfo sector (2) */
N#define BPB_BkBootSec		50	/* Offset of backup boot sector (2) */
N#define BS_DrvNum32			64	/* Physical drive number (2) */
N#define BS_BootSig32		66	/* Extended boot signature (1) */
N#define BS_VolID32			67	/* Volume serial number (4) */
N#define BS_VolLab32			71	/* Volume label (8) */
N#define BS_FilSysType32	82	/* File system type (1) */
N#define	FSI_LeadSig			0		/* FSI: Leading signature (4) */
N#define	FSI_StrucSig		484	/* FSI: Structure signature (4) */
N#define	FSI_Free_Count	488	/* FSI: Number of free clusters (4) */
N#define	FSI_Nxt_Free		492	/* FSI: Last allocated cluster (4) */
N#define MBR_Table				446	/* MBR: Partition table offset (2) */
N#define	SZ_PTE					16	/* MBR: Size of a partition table entry */
N#define BS_55AA					510	/* Boot sector signature (2) */
N
N#define	DIR_Name				0		/* Short file name (11) */
N#define	DIR_Attr				11	/* Attribute (1) */
N#define	DIR_NTres				12	/* NT flag (1) */
N#define DIR_CrtTimeTenth13	/* Created time sub-second (1) */
N#define	DIR_CrtTime			14	/* Created time (2) */
N#define	DIR_CrtDate			16	/* Created date (2) */
N#define DIR_LstAccDate	18	/* Last accessed date (2) */
N#define	DIR_FstClusHI		20	/* Higher 16-bit of first cluster (2) */
N#define	DIR_WrtTime			22	/* Modified time (2) */
N#define	DIR_WrtDate			24	/* Modified date (2) */
N#define	DIR_FstClusLO		26	/* Lower 16-bit of first cluster (2) */
N#define	DIR_FileSize		28	/* File size (4) */
N#define	LDIR_Ord				0		/* LFN entry order and LLE flag (1) */
N#define	LDIR_Attr				11	/* LFN attribute (1) */
N#define	LDIR_Type				12	/* LFN type (1) */
N#define	LDIR_Chksum			13	/* Sum of corresponding SFN entry */
N#define	LDIR_FstClusLO	26	/* Filled by zero (0) */
N#define	SZ_DIR					32	/* Size of a directory entry */
N#define	LLE							0x40	/* Last long entry flag in LDIR_Ord */
N#define	DDE							0xE5	/* Deleted directory entry mark in DIR_Name[0] */
N#define	NDDE						0x05	/* Replacement of the character collides with DDE */
N
N
N/*------------------------------------------------------------*/
N/* Module private work area                                   */
N/*------------------------------------------------------------*/
N/* Note that uninitialized variables with static duration are
N/  zeroed/nulled at start-up. If not, the compiler or start-up
N/  routine is out of ANSI-C standard.
N*/
N
N#if _VOLUMES
X#if 2
Nstatic
NFATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
XFATFS *FatFs[2];	 
N#else
S#error Number of volumes must not be 0.
N#endif
N
Nstatic
NWORD Fsid;				/* File system mount ID */
N
N#if _FS_RPATH
X#if 2
Nstatic
NBYTE CurrVol;			/* Current drive */
N#endif
N
N#if _FS_LOCK
X#if 0
Sstatic
SFILESEM	Files[_FS_LOCK];	/* File lock semaphores */
N#endif
N
N#if _USE_LFN == 0			/* No LFN feature */
X#if 2 == 0			 
S#define	DEF_NAMEBUF			BYTE sfn[12]
S#define INIT_BUF(dobj)		(dobj).fn = sfn
S#define	FREE_BUF()
S
S#elif _USE_LFN == 1			/* LFN feature with static working buffer */
X#elif 2 == 1			 
Sstatic WCHAR LfnBuf[_MAX_LFN+1];
S#define	DEF_NAMEBUF			BYTE sfn[12]
S#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = LfnBuf; }
S#define	FREE_BUF()
S
N#elif _USE_LFN == 2 		/* LFN feature with dynamic working buffer on the stack */
X#elif 2 == 2 		 
N#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
N#define INIT_BUF(dobj)		{ (dobj).fn = sfn; (dobj).lfn = lbuf; }
N#define	FREE_BUF()
N
N#elif _USE_LFN == 3 		/* LFN feature with dynamic working buffer on the heap */
S#define	DEF_NAMEBUF			BYTE sfn[12]; WCHAR *lfn
S#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); \
S							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); \
S							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
X#define INIT_BUF(dobj)		{ lfn = ff_memalloc((_MAX_LFN + 1) * 2); 							  if (!lfn) LEAVE_FF((dobj).fs, FR_NOT_ENOUGH_CORE); 							  (dobj).lfn = lfn;	(dobj).fn = sfn; }
S#define	FREE_BUF()			ff_memfree(lfn)
S
S#else
S#error Wrong LFN configuration.
N#endif
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Module Private Functions
N
N---------------------------------------------------------------------------*/
N
N
N/*-----------------------------------------------------------------------*/
N/* String functions                                                      */
N/*-----------------------------------------------------------------------*/
N
N/* Copy memory to memory */
Nstatic
Nvoid mem_cpy (void* dst, const void* src, UINT cnt) {
N	BYTE *d = (BYTE*)dst;
N	const BYTE *s = (const BYTE*)src;
N
N#if _WORD_ACCESS == 1
X#if 0 == 1
S	while (cnt >= sizeof (int)) {
S		*(int*)d = *(int*)s;
S		d += sizeof (int); s += sizeof (int);
S		cnt -= sizeof (int);
S	}
N#endif
N	while (cnt--)
N		*d++ = *s++;
N}
N
N/* Fill memory */
Nstatic
Nvoid mem_set (void* dst, int val, UINT cnt) {
N	BYTE *d = (BYTE*)dst;
N
N	while (cnt--)
N		*d++ = (BYTE)val;
N}
N
N/* Compare memory to memory */
Nstatic
Nint mem_cmp (const void* dst, const void* src, UINT cnt) {
N	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
N	int r = 0;
N
N	while (cnt-- && (r = *d++ - *s++) == 0) ;
N	return r;
N}
N
N/* Check if chr is contained in the string */
Nstatic
Nint chk_chr (const char* str, int chr) {
N	while (*str && *str != chr) str++;
N	return *str;
N}
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Request/Release grant to access the volume                            */
N/*-----------------------------------------------------------------------*/
N#if _FS_REENTRANT
X#if 0
S
Sstatic
Sint lock_fs (
S	FATFS *fs		/* File system object */
S)
S{
S	return ff_req_grant(fs->sobj);
S}
S
S
Sstatic
Svoid unlock_fs (
S	FATFS *fs,		/* File system object */
S	FRESULT res		/* Result code to be returned */
S)
S{
S	if (fs &&
S		res != FR_NOT_ENABLED &&
S		res != FR_INVALID_DRIVE &&
S		res != FR_INVALID_OBJECT &&
S		res != FR_TIMEOUT) {
S		ff_rel_grant(fs->sobj);
S	}
S}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* File lock control functions                                           */
N/*-----------------------------------------------------------------------*/
N#if _FS_LOCK
X#if 0
S
Sstatic
SFRESULT chk_lock (	/* Check if the file can be accessed */
S	DIR* dj,		/* Directory object pointing the file to be checked */
S	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
S)
S{
S	UINT i, be;
S
S	/* Search file semaphore table */
S	for (i = be = 0; i < _FS_LOCK; i++) {
S		if (Files[i].fs) {	/* Existing entry */
S			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
S				Files[i].clu == dj->sclust &&
S				Files[i].idx == dj->index) break;
S		} else {			/* Blank entry */
S			be++;
S		}
S	}
S	if (i == _FS_LOCK)	/* The file is not opened */
S		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
S
S	/* The file has been opened. Reject any open against writing file and all write mode open */
S	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
S}
S
S
Sstatic
Sint enq_lock (void)	/* Check if an entry is available for a new file */
S{
S	UINT i;
S
S	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
S	return (i == _FS_LOCK) ? 0 : 1;
S}
S
S
Sstatic
SUINT inc_lock (	/* Increment file open counter and returns its index (0:int error) */
S	DIR* dj,	/* Directory object pointing the file to register or increment */
S	int acc		/* Desired access mode (0:Read, !0:Write) */
S)
S{
S	UINT i;
S
S
S	for (i = 0; i < _FS_LOCK; i++) {	/* Find the file */
S		if (Files[i].fs == dj->fs &&
S			Files[i].clu == dj->sclust &&
S			Files[i].idx == dj->index) break;
S	}
S
S	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
S		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
S		if (i == _FS_LOCK) return 0;	/* No space to register (int err) */
S		Files[i].fs = dj->fs;
S		Files[i].clu = dj->sclust;
S		Files[i].idx = dj->index;
S		Files[i].ctr = 0;
S	}
S
S	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
S
S	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
S
S	return i + 1;
S}
S
S
Sstatic
SFRESULT dec_lock (	/* Decrement file open counter */
S	UINT i			/* Semaphore index */
S)
S{
S	WORD n;
S	FRESULT res;
S
S
S	if (--i < _FS_LOCK) {
S		n = Files[i].ctr;
S		if (n == 0x100) n = 0;
S		if (n) n--;
S		Files[i].ctr = n;
S		if (!n) Files[i].fs = 0;
S		res = FR_OK;
S	} else {
S		res = FR_INT_ERR;
S	}
S	return res;
S}
S
S
Sstatic
Svoid clear_lock (	/* Clear lock entries of the volume */
S	FATFS *fs
S)
S{
S	UINT i;
S
S	for (i = 0; i < _FS_LOCK; i++) {
S		if (Files[i].fs == fs) Files[i].fs = 0;
S	}
S}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Change window offset                                                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT move_window (
N	FATFS *fs,		/* File system object */
N	DWORD sector	/* Sector number to make appearance in the fs->win[] */
N)					/* Move to zero only writes back dirty window */
N{
N	DWORD wsect;
N
N
N	wsect = fs->winsect;
N	if (wsect != sector) {	/* Changed current window */
N#if !_FS_READONLY
X#if !1
S		if (fs->wflag) {	/* Write back dirty window if needed */
S			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
S				return FR_DISK_ERR;
S			fs->wflag = 0;
S			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
S				BYTE nf;
S				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
S					wsect += fs->fsize;
S					disk_write(fs->drv, fs->win, wsect, 1);
S				}
S			}
S		}
N#endif
N		if (sector) {
N			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
N				return FR_DISK_ERR;
N			fs->winsect = sector;
N		}
N	}
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Clean-up cached data                                                  */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !1
Sstatic
SFRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
S	FATFS *fs	/* File system object */
S)
S{
S	FRESULT res;
S
S
S	res = move_window(fs, 0);
S	if (res == FR_OK) {
S		/* Update FSInfo sector if needed */
S		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
S			fs->winsect = 0;
S			/* Create FSInfo structure */
S			mem_set(fs->win, 0, 512);
S			ST_WORD(fs->win+BS_55AA, 0xAA55);
S			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
S			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
S			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
S			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
S			/* Write it into the FSInfo sector */
S			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
S			fs->fsi_flag = 0;
S		}
S		/* Make sure that no pending write process in the physical drive */
S		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
S			res = FR_DISK_ERR;
S	}
S
S	return res;
S}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get sector# from cluster#                                             */
N/*-----------------------------------------------------------------------*/
N
N
NDWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
N	FATFS *fs,		/* File system object */
N	DWORD clst		/* Cluster# to be converted */
N)
N{
N	clst -= 2;
N	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
N	return clst * fs->csize + fs->database;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT access - Read value of a FAT entry                                */
N/*-----------------------------------------------------------------------*/
N
N
NDWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
N	FATFS *fs,	/* File system object */
N	DWORD clst	/* Cluster# to get the link information */
N)
N{
N	UINT wc, bc;
N	BYTE *p;
N
N
N	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
N		return 1;
N
N	switch (fs->fs_type) {
N	case FS_FAT12 :
X	case 1 :
N		bc = (UINT)clst; bc += bc / 2;
N		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
X		if (move_window(fs, fs->fatbase + (bc / 512U))) break;
N		wc = fs->win[bc % SS(fs)]; bc++;
X		wc = fs->win[bc % 512U]; bc++;
N		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
X		if (move_window(fs, fs->fatbase + (bc / 512U))) break;
N		wc |= fs->win[bc % SS(fs)] << 8;
X		wc |= fs->win[bc % 512U] << 8;
N		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
N
N	case FS_FAT16 :
X	case 2 :
N		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
X		if (move_window(fs, fs->fatbase + (clst / (512U / 2)))) break;
N		p = &fs->win[clst * 2 % SS(fs)];
X		p = &fs->win[clst * 2 % 512U];
N		return LD_WORD(p);
X		return (WORD)(((WORD)*((BYTE*)(p)+1)<<8)|(WORD)*(BYTE*)(p));
N
N	case FS_FAT32 :
X	case 3 :
N		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
X		if (move_window(fs, fs->fatbase + (clst / (512U / 4)))) break;
N		p = &fs->win[clst * 4 % SS(fs)];
X		p = &fs->win[clst * 4 % 512U];
N		return LD_DWORD(p) & 0x0FFFFFFF;
X		return (DWORD)(((DWORD)*((BYTE*)(p)+3)<<24)|((DWORD)*((BYTE*)(p)+2)<<16)|((WORD)*((BYTE*)(p)+1)<<8)| *(BYTE*)(p)) & 0x0FFFFFFF;
N	}
N
N	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT access - Change value of a FAT entry                              */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !1
S
SFRESULT put_fat (
S	FATFS *fs,	/* File system object */
S	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
S	DWORD val	/* New value to mark the cluster */
S)
S{
S	UINT bc;
S	BYTE *p;
S	FRESULT res;
S
S
S	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
S		res = FR_INT_ERR;
S
S	} else {
S		switch (fs->fs_type) {
S		case FS_FAT12 :
S			bc = (UINT)clst; bc += bc / 2;
S			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
S			if (res != FR_OK) break;
S			p = &fs->win[bc % SS(fs)];
S			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
S			bc++;
S			fs->wflag = 1;
S			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
S			if (res != FR_OK) break;
S			p = &fs->win[bc % SS(fs)];
S			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
S			break;
S
S		case FS_FAT16 :
S			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
S			if (res != FR_OK) break;
S			p = &fs->win[clst * 2 % SS(fs)];
S			ST_WORD(p, (WORD)val);
S			break;
S
S		case FS_FAT32 :
S			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
S			if (res != FR_OK) break;
S			p = &fs->win[clst * 4 % SS(fs)];
S			val |= LD_DWORD(p) & 0xF0000000;
S			ST_DWORD(p, val);
S			break;
S
S		default :
S			res = FR_INT_ERR;
S		}
S		fs->wflag = 1;
S	}
S
S	return res;
S}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Remove a cluster chain                                 */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !1
Sstatic
SFRESULT remove_chain (
S	FATFS *fs,			/* File system object */
S	DWORD clst			/* Cluster# to remove a chain from */
S)
S{
S	FRESULT res;
S	DWORD nxt;
S#if _USE_ERASE
S	DWORD scl = clst, ecl = clst, rt[2];
S#endif
S
S	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
S		res = FR_INT_ERR;
S
S	} else {
S		res = FR_OK;
S		while (clst < fs->n_fatent) {			/* Not a last link? */
S			nxt = get_fat(fs, clst);			/* Get cluster status */
S			if (nxt == 0) break;				/* Empty cluster? */
S			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
S			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
S			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
S			if (res != FR_OK) break;
S			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
S				fs->free_clust++;
S				fs->fsi_flag = 1;
S			}
S#if _USE_ERASE
S			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
S				ecl = nxt;
S			} else {				/* End of contiguous clusters */ 
S				rt[0] = clust2sect(fs, scl);					/* Start sector */
S				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
S				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
S				scl = ecl = nxt;
S			}
S#endif
S			clst = nxt;	/* Next cluster */
S		}
S	}
S
S	return res;
S}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Stretch or Create a cluster chain                      */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !1
Sstatic
SDWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
S	FATFS *fs,			/* File system object */
S	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
S)
S{
S	DWORD cs, ncl, scl;
S	FRESULT res;
S
S
S	if (clst == 0) {		/* Create a new chain */
S		scl = fs->last_clust;			/* Get suggested start point */
S		if (!scl || scl >= fs->n_fatent) scl = 1;
S	}
S	else {					/* Stretch the current chain */
S		cs = get_fat(fs, clst);			/* Check the cluster status */
S		if (cs < 2) return 1;			/* It is an invalid cluster */
S		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
S		scl = clst;
S	}
S
S	ncl = scl;				/* Start cluster */
S	for (;;) {
S		ncl++;							/* Next cluster */
S		if (ncl >= fs->n_fatent) {		/* Wrap around */
S			ncl = 2;
S			if (ncl > scl) return 0;	/* No free cluster */
S		}
S		cs = get_fat(fs, ncl);			/* Get the cluster status */
S		if (cs == 0) break;				/* Found a free cluster */
S		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
S			return cs;
S		if (ncl == scl) return 0;		/* No free cluster */
S	}
S
S	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
S	if (res == FR_OK && clst != 0) {
S		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
S	}
S	if (res == FR_OK) {
S		fs->last_clust = ncl;			/* Update FSINFO */
S		if (fs->free_clust != 0xFFFFFFFF) {
S			fs->free_clust--;
S			fs->fsi_flag = 1;
S		}
S	} else {
S		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
S	}
S
S	return ncl;		/* Return new cluster number or error code */
S}
N#endif /* !_FS_READONLY */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* FAT handling - Convert offset into cluster with link map table        */
N/*-----------------------------------------------------------------------*/
N
N#if _USE_FASTSEEK
X#if 0
Sstatic
SDWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
S	FIL* fp,		/* Pointer to the file object */
S	DWORD ofs		/* File offset to be converted to cluster# */
S)
S{
S	DWORD cl, ncl, *tbl;
S
S
S	tbl = fp->cltbl + 1;	/* Top of CLMT */
S	cl = ofs / SS(fp->fs) / fp->fs->csize;	/* Cluster order from top of the file */
S	for (;;) {
S		ncl = *tbl++;			/* Number of cluters in the fragment */
S		if (!ncl) return 0;		/* End of table? (error) */
S		if (cl < ncl) break;	/* In this fragment? */
S		cl -= ncl; tbl++;		/* Next fragment */
S	}
S	return cl + *tbl;	/* Return the cluster number */
S}
N#endif	/* _USE_FASTSEEK */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Set directory index                              */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_sdi (
N	DIR *dj,		/* Pointer to directory object */
N	WORD idx		/* Index of directory table */
N)
N{
N	DWORD clst;
N	WORD ic;
N
N
N	dj->index = idx;
N	clst = dj->sclust;
N	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
N		return FR_INT_ERR;
N	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
X	if (!clst && dj->fs->fs_type == 3)	 
N		clst = dj->fs->dirbase;
N
N	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
N		dj->clust = clst;
N		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
N			return FR_INT_ERR;
N		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
X		dj->sect = dj->fs->dirbase + idx / (512U / 32);	 
N	}
N	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
N		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
X		ic = 512U / 32 * dj->fs->csize;	 
N		while (idx >= ic) {	/* Follow cluster chain */
N			clst = get_fat(dj->fs, clst);				/* Get next cluster */
N			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
N			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
N				return FR_INT_ERR;
N			idx -= ic;
N		}
N		dj->clust = clst;
N		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
X		dj->sect = clust2sect(dj->fs, clst) + idx / (512U / 32);	 
N	}
N
N	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
X	dj->dir = dj->fs->win + (idx % (512U / 32)) * 32;	 
N
N	return FR_OK;	/* Seek succeeded */
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Move directory table index next                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
N	DIR *dj,		/* Pointer to directory object */
N	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
N)
N{
N	DWORD clst;
N	WORD i;
N
N
N	stretch = stretch;		/* To suppress warning on read-only cfg. */
N	i = dj->index + 1;
N	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
N		return FR_NO_FILE;
N
N	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
X	if (!(i % (512U / 32))) {	 
N		dj->sect++;					/* Next sector */
N
N		if (dj->clust == 0) {	/* Static table */
N			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
N				return FR_NO_FILE;
N		}
N		else {					/* Dynamic table */
N			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
X			if (((i / (512U / 32)) & (dj->fs->csize - 1)) == 0) {	 
N				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
N				if (clst <= 1) return FR_INT_ERR;
N				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
N				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
N#if !_FS_READONLY
X#if !1
S					BYTE c;
S					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
S					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
S					if (clst == 0) return FR_DENIED;			/* No free cluster */
S					if (clst == 1) return FR_INT_ERR;
S					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
S					/* Clean-up stretched table */
S					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
S					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
S					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
S					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
S						dj->fs->wflag = 1;
S						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
S						dj->fs->winsect++;
S					}
S					dj->fs->winsect -= c;						/* Rewind window address */
N#else
N					return FR_NO_FILE;			/* Report EOT */
N#endif
N				}
N				dj->clust = clst;				/* Initialize data for new cluster */
N				dj->sect = clust2sect(dj->fs, clst);
N			}
N		}
N	}
N
N	dj->index = i;
N	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
X	dj->dir = dj->fs->win + (i % (512U / 32)) * 32;
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Load/Store start cluster number                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NDWORD ld_clust (
N	FATFS *fs,	/* Pointer to the fs object */
N	BYTE *dir	/* Pointer to the directory entry */
N)
N{
N	DWORD cl;
N
N	cl = LD_WORD(dir+DIR_FstClusLO);
X	cl = (WORD)(((WORD)*((BYTE*)(dir+26)+1)<<8)|(WORD)*(BYTE*)(dir+26));
N	if (fs->fs_type == FS_FAT32)
X	if (fs->fs_type == 3)
N		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
X		cl |= (DWORD)(WORD)(((WORD)*((BYTE*)(dir+20)+1)<<8)|(WORD)*(BYTE*)(dir+20)) << 16;
N
N	return cl;
N}
N
N
N#if !_FS_READONLY
X#if !1
Sstatic
Svoid st_clust (
S	BYTE *dir,	/* Pointer to the directory entry */
S	DWORD cl	/* Value to be set */
S)
S{
S	ST_WORD(dir+DIR_FstClusLO, cl);
S	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
S}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* LFN handling - Test/Pick/Fit an LFN segment from/to directory entry   */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 2
Nstatic
Nconst BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN chars in the directory entry */
N
N
Nstatic
Nint cmp_lfn (			/* 1:Matched, 0:Not matched */
N	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
N	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
N)
N{
N	UINT i, s;
N	WCHAR wc, uc;
N
N
N	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
X	i = ((dir[0] & ~0x40) - 1) * 13;	 
N	s = 0; wc = 1;
N	do {
N		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
X		uc = (WORD)(((WORD)*((BYTE*)(dir+LfnOfs[s])+1)<<8)|(WORD)*(BYTE*)(dir+LfnOfs[s]));	 
N		if (wc) {	/* Last char has not been processed */
N			wc = ff_wtoupper(uc);		/* Convert it to upper case */
N			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
X			if (i >= 255 || wc != ff_wtoupper(lfnbuf[i++]))	 
N				return 0;				/* Not matched */
N		} else {
N			if (uc != 0xFFFF) return 0;	/* Check filler */
N		}
N	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
N
N	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
X	if ((dir[0] & 0x40) && wc && lfnbuf[i])	 
N		return 0;
N
N	return 1;						/* The part of LFN matched */
N}
N
N
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
Nstatic
Nint pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
N	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
N	BYTE *dir			/* Pointer to the directory entry */
N)
N{
N	UINT i, s;
N	WCHAR wc, uc;
N
N
N	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
X	i = ((dir[0] & 0x3F) - 1) * 13;	 
N
N	s = 0; wc = 1;
N	do {
N		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
X		uc = (WORD)(((WORD)*((BYTE*)(dir+LfnOfs[s])+1)<<8)|(WORD)*(BYTE*)(dir+LfnOfs[s]));		 
N		if (wc) {	/* Last char has not been processed */
N			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
X			if (i >= 255) return 0;	 
N			lfnbuf[i++] = wc = uc;			/* Store it */
N		} else {
N			if (uc != 0xFFFF) return 0;		/* Check filler */
N		}
N	} while (++s < 13);						/* Read all character in the entry */
N
N	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
X	if (dir[0] & 0x40) {				 
N		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
X		if (i >= 255) return 0;		 
N		lfnbuf[i] = 0;
N	}
N
N	return 1;
N}
N#endif
N
N#if !_FS_READONLY
X#if !1
Sstatic
Svoid fit_lfn (
S	const WCHAR *lfnbuf,	/* Pointer to the LFN buffer */
S	BYTE *dir,				/* Pointer to the directory entry */
S	BYTE ord,				/* LFN order (1-20) */
S	BYTE sum				/* SFN sum */
S)
S{
S	UINT i, s;
S	WCHAR wc;
S
S
S	dir[LDIR_Chksum] = sum;			/* Set check sum */
S	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
S	dir[LDIR_Type] = 0;
S	ST_WORD(dir+LDIR_FstClusLO, 0);
S
S	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
S	s = wc = 0;
S	do {
S		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
S		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
S		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
S	} while (++s < 13);
S	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
S	dir[LDIR_Ord] = ord;			/* Set the LFN order */
S}
S
N#endif
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Create numbered name                                                  */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 2
Nvoid gen_numname (
N	BYTE *dst,			/* Pointer to generated SFN */
N	const BYTE *src,	/* Pointer to source SFN to be modified */
N	const WCHAR *lfn,	/* Pointer to LFN */
N	WORD seq			/* Sequence number */
N)
N{
N	BYTE ns[8], c;
N	UINT i, j;
N
N
N	mem_cpy(dst, src, 11);
N
N	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
N		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
N	}
N
N	/* itoa (hexdecimal) */
N	i = 7;
N	do {
N		c = (seq % 16) + '0';
N		if (c > '9') c += 7;
N		ns[i--] = c;
N		seq /= 16;
N	} while (seq);
N	ns[i] = '~';
N
N	/* Append the number */
N	for (j = 0; j < i && dst[j] != ' '; j++) {
N		if (IsDBCS1(dst[j])) {
X		if (0) {
N			if (j == i - 1) break;
N			j++;
N		}
N	}
N	do {
N		dst[j++] = (i < 8) ? ns[i++] : ' ';
N	} while (j < 8);
N}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Calculate sum of an SFN                                               */
N/*-----------------------------------------------------------------------*/
N#if _USE_LFN
X#if 2
Nstatic
NBYTE sum_sfn (
N	const BYTE *dir		/* Ptr to directory entry */
N)
N{
N	BYTE sum = 0;
N	UINT n = 11;
N
N	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
N	return sum;
N}
N#endif
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Directory handling - Find an object in the directory                  */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT dir_find (
N	DIR *dj			/* Pointer to the directory object linked to the file name */
N)
N{
N	FRESULT res;
N	BYTE c, *dir;
N#if _USE_LFN
X#if 2
N	BYTE a, ord, sum;
N#endif
N
N	res = dir_sdi(dj, 0);			/* Rewind directory object */
N	if (res != FR_OK) return res;
N
N#if _USE_LFN
X#if 2
N	ord = sum = 0xFF;
N#endif
N	do {
N		res = move_window(dj->fs, dj->sect);
N		if (res != FR_OK) break;
N		dir = dj->dir;					/* Ptr to the directory entry of current index */
N		c = dir[DIR_Name];
X		c = dir[0];
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
N#if _USE_LFN	/* LFN configuration */
X#if 2	 
N		a = dir[DIR_Attr] & AM_MASK;
X		a = dir[11] & 0x3F;
N		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
X		if (c == 0xE5 || ((a & 0x08) && a != 0x0F)) {	 
N			ord = 0xFF;
N		} else {
N			if (a == AM_LFN) {			/* An LFN entry is found */
X			if (a == 0x0F) {			 
N				if (dj->lfn) {
N					if (c & LLE) {		/* Is it start of LFN sequence? */
X					if (c & 0x40) {		 
N						sum = dir[LDIR_Chksum];
X						sum = dir[13];
N						c &= ~LLE; ord = c;	/* LFN start order */
X						c &= ~0x40; ord = c;	 
N						dj->lfn_idx = dj->index;
N					}
N					/* Check validity of the LFN entry and compare it with given name */
N					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
X					ord = (c == ord && sum == dir[13] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
N				}
N			} else {					/* An SFN entry is found */
N				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
N				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
N				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
X				if (!(dj->fn[11] & 0x01) && !mem_cmp(dir, dj->fn, 11)) break;	 
N			}
N		}
N#else		/* Non LFN configuration */
S		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
S			break;
N#endif
N		res = dir_next(dj, 0);		/* Next entry */
N	} while (res == FR_OK);
N
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read an object from the directory                                     */
N/*-----------------------------------------------------------------------*/
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
Nstatic
NFRESULT dir_read (
N	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
N)
N{
N	FRESULT res;
N	BYTE c, *dir;
N#if _USE_LFN
X#if 2
N	BYTE a, ord = 0xFF, sum = 0xFF;
N#endif
N
N	res = FR_NO_FILE;
N	while (dj->sect) {
N		res = move_window(dj->fs, dj->sect);
N		if (res != FR_OK) break;
N		dir = dj->dir;					/* Ptr to the directory entry of current index */
N		c = dir[DIR_Name];
X		c = dir[0];
N		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
N#if _USE_LFN	/* LFN configuration */
X#if 2	 
N		a = dir[DIR_Attr] & AM_MASK;
X		a = dir[11] & 0x3F;
N		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
X		if (c == 0xE5 || (!2 && c == '.') || ((a & 0x08) && a != 0x0F)) {	 
N			ord = 0xFF;
N		} else {
N			if (a == AM_LFN) {			/* An LFN entry is found */
X			if (a == 0x0F) {			 
N				if (c & LLE) {			/* Is it start of LFN sequence? */
X				if (c & 0x40) {			 
N					sum = dir[LDIR_Chksum];
X					sum = dir[13];
N					c &= ~LLE; ord = c;
X					c &= ~0x40; ord = c;
N					dj->lfn_idx = dj->index;
N				}
N				/* Check LFN validity and capture it */
N				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
X				ord = (c == ord && sum == dir[13] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
N			} else {					/* An SFN entry is found */
N				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
N					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
N				break;
N			}
N		}
N#else		/* Non LFN configuration */
S		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
S			break;
N#endif
N		res = dir_next(dj, 0);				/* Next entry */
N		if (res != FR_OK) break;
N	}
N
N	if (res != FR_OK) dj->sect = 0;
N
N	return res;
N}
N#endif
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Register an object to the directory                                   */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY
X#if !1
Sstatic
SFRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
S	DIR *dj				/* Target directory with object name to be created */
S)
S{
S	FRESULT res;
S	BYTE c, *dir;
S#if _USE_LFN	/* LFN configuration */
S	WORD n, ne, is;
S	BYTE sn[12], *fn, sum;
S	WCHAR *lfn;
S
S
S	fn = dj->fn; lfn = dj->lfn;
S	mem_cpy(sn, fn, 12);
S
S	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
S		return FR_INVALID_NAME;
S
S	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
S		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
S		for (n = 1; n < 100; n++) {
S			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
S			res = dir_find(dj);				/* Check if the name collides with existing SFN */
S			if (res != FR_OK) break;
S		}
S		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
S		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
S		fn[NS] = sn[NS]; dj->lfn = lfn;
S	}
S
S	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
S		for (ne = 0; lfn[ne]; ne++) ;
S		ne = (ne + 25) / 13;
S	} else {						/* Otherwise reserve only an SFN entry. */
S		ne = 1;
S	}
S
S	/* Reserve contiguous entries */
S	res = dir_sdi(dj, 0);
S	if (res != FR_OK) return res;
S	n = is = 0;
S	do {
S		res = move_window(dj->fs, dj->sect);
S		if (res != FR_OK) break;
S		c = *dj->dir;				/* Check the entry status */
S		if (c == DDE || c == 0) {	/* Is it a blank entry? */
S			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
S			if (++n == ne) break;	/* A contiguous entry that required count is found */
S		} else {
S			n = 0;					/* Not a blank entry. Restart to search */
S		}
S		res = dir_next(dj, 1);		/* Next entry with table stretch */
S	} while (res == FR_OK);
S
S	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
S		res = dir_sdi(dj, is);
S		if (res == FR_OK) {
S			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
S			ne--;
S			do {					/* Store LFN entries in bottom first */
S				res = move_window(dj->fs, dj->sect);
S				if (res != FR_OK) break;
S				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
S				dj->fs->wflag = 1;
S				res = dir_next(dj, 0);	/* Next entry */
S			} while (res == FR_OK && --ne);
S		}
S	}
S
S#else	/* Non LFN configuration */
S	res = dir_sdi(dj, 0);
S	if (res == FR_OK) {
S		do {	/* Find a blank entry for the SFN */
S			res = move_window(dj->fs, dj->sect);
S			if (res != FR_OK) break;
S			c = *dj->dir;
S			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
S			res = dir_next(dj, 1);			/* Next entry with table stretch */
S		} while (res == FR_OK);
S	}
S#endif
S
S	if (res == FR_OK) {		/* Initialize the SFN entry */
S		res = move_window(dj->fs, dj->sect);
S		if (res == FR_OK) {
S			dir = dj->dir;
S			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
S			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
S#if _USE_LFN
S			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
S#endif
S			dj->fs->wflag = 1;
S		}
S	}
S
S	return res;
S}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Remove an object from the directory                                   */
N/*-----------------------------------------------------------------------*/
N#if !_FS_READONLY && !_FS_MINIMIZE
X#if !1 && !0
Sstatic
SFRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
S	DIR *dj				/* Directory object pointing the entry to be removed */
S)
S{
S	FRESULT res;
S#if _USE_LFN	/* LFN configuration */
S	WORD i;
S
S	i = dj->index;	/* SFN index */
S	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
S	if (res == FR_OK) {
S		do {
S			res = move_window(dj->fs, dj->sect);
S			if (res != FR_OK) break;
S			*dj->dir = DDE;			/* Mark the entry "deleted" */
S			dj->fs->wflag = 1;
S			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
S			res = dir_next(dj, 0);		/* Next entry */
S		} while (res == FR_OK);
S		if (res == FR_NO_FILE) res = FR_INT_ERR;
S	}
S
S#else			/* Non LFN configuration */
S	res = dir_sdi(dj, dj->index);
S	if (res == FR_OK) {
S		res = move_window(dj->fs, dj->sect);
S		if (res == FR_OK) {
S			*dj->dir = DDE;			/* Mark the entry "deleted" */
S			dj->fs->wflag = 1;
S		}
S	}
S#endif
S
S	return res;
S}
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Pick a segment and create the object name in directory form           */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT create_name (
N	DIR *dj,			/* Pointer to the directory object */
N	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
N)
N{
N#ifdef _EXCVT
N	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
X	static const BYTE excvt[] = {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x8A,0x9B,0x8C,0x8D,0x8E,0x8F, 0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF,0xB0,0xB1,0xB2,0xA3,0xB4,0xB5,0xB6,0xB7,0xB8,0xA5,0xAA,0xBB,0xBC,0xBD,0xBC,0xAF, 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, 0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xF7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xFF};	 
N#endif
N
N#if _USE_LFN	/* LFN configuration */
X#if 2	 
N	BYTE b, cf;
N	WCHAR w, *lfn;
N	UINT i, ni, si, di;
N	const TCHAR *p;
N
N	/* Create LFN in Unicode */
N	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
N	lfn = dj->lfn;
N	si = di = 0;
N	for (;;) {
N		w = p[si++];					/* Get a character */
N		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
N		if (di >= _MAX_LFN)				/* Reject too long name */
X		if (di >= 255)				 
N			return FR_INVALID_NAME;
N#if !_LFN_UNICODE
X#if !0
N		w &= 0xFF;
N		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
X		if (0) {				 
N			b = (BYTE)p[si++];			/* Get 2nd byte */
N			if (!IsDBCS2(b))
X			if (!0)
N				return FR_INVALID_NAME;	/* Reject invalid sequence */
N			else
N				w = (w << 8) + b;			/* Create a DBC */
N		}
N		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
N		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
N#endif
N		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
N			return FR_INVALID_NAME;
N		lfn[di++] = w;					/* Store the Unicode char */
N	}
N	*path = &p[si];						/* Return pointer to the next segment */
N	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
X	cf = (w < ' ') ? 0x04 : 0;		 
N#if _FS_RPATH
X#if 2
N	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
N		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
N		lfn[di] = 0;
N		for (i = 0; i < 11; i++)
N			dj->fn[i] = (i < di) ? '.' : ' ';
N		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
X		dj->fn[i] = cf | 0x20;		 
N		return FR_OK;
N	}
N#endif
N	while (di) {						/* Strip trailing spaces and dots */
N		w = lfn[di-1];
N		if (w != ' ' && w != '.') break;
N		di--;
N	}
N	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
N
N	lfn[di] = 0;						/* LFN is created */
N
N	/* Create SFN in directory form */
N	mem_set(dj->fn, ' ', 11);
N	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
N	if (si) cf |= NS_LOSS | NS_LFN;
X	if (si) cf |= 0x01 | 0x02;
N	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
N
N	b = i = 0; ni = 8;
N	for (;;) {
N		w = lfn[si++];					/* Get an LFN char */
N		if (!w) break;					/* Break on end of the LFN */
N		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
N			cf |= NS_LOSS | NS_LFN; continue;
X			cf |= 0x01 | 0x02; continue;
N		}
N
N		if (i >= ni || si == di) {		/* Extension or end of SFN */
N			if (ni == 11) {				/* Long extension */
N				cf |= NS_LOSS | NS_LFN; break;
X				cf |= 0x01 | 0x02; break;
N			}
N			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
X			if (si != di) cf |= 0x01 | 0x02;	 
N			if (si > di) break;			/* No extension */
N			si = di; i = 8; ni = 11;	/* Enter extension section */
N			b <<= 2; continue;
N		}
N
N		if (w >= 0x80) {				/* Non ASCII char */
N#ifdef _EXCVT
N			w = ff_convert(w, 0);		/* Unicode -> OEM code */
N			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
N#else
S			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
N#endif
N			cf |= NS_LFN;				/* Force create LFN entry */
X			cf |= 0x02;				 
N		}
N
N		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
X		if (0 && w >= 0x100) {		 
N			if (i >= ni - 1) {
N				cf |= NS_LOSS | NS_LFN; i = ni; continue;
X				cf |= 0x01 | 0x02; i = ni; continue;
N			}
N			dj->fn[i++] = (BYTE)(w >> 8);
N		} else {						/* Single byte char */
N			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
N				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
X				w = '_'; cf |= 0x01 | 0x02; 
N			} else {
N				if (IsUpper(w)) {		/* ASCII large capital */
X				if ((((w)>= 'A')&&((w)<= 'Z'))) {		 
N					b |= 2;
N				} else {
N					if (IsLower(w)) {	/* ASCII small capital */
X					if ((((w)>= 'a')&&((w)<= 'z'))) {	 
N						b |= 1; w -= 0x20;
N					}
N				}
N			}
N		}
N		dj->fn[i++] = (BYTE)w;
N	}
N
N	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
X	if (dj->fn[0] == 0xE5) dj->fn[0] = 0x05;	 
N
N	if (ni == 8) b <<= 2;
N	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
N		cf |= NS_LFN;
X		cf |= 0x02;
N	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
X	if (!(cf & 0x02)) {						 
N		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
X		if ((b & 0x03) == 0x01) cf |= 0x10;	 
N		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
X		if ((b & 0x0C) == 0x04) cf |= 0x08;	 
N	}
N
N	dj->fn[NS] = cf;	/* SFN is created */
X	dj->fn[11] = cf;	 
N
N	return FR_OK;
N
N
N#else	/* Non-LFN configuration */
S	BYTE b, c, d, *sfn;
S	UINT ni, si, i;
S	const char *p;
S
S	/* Create file name in directory form */
S	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
S	sfn = dj->fn;
S	mem_set(sfn, ' ', 11);
S	si = i = b = 0; ni = 8;
S#if _FS_RPATH
S	if (p[si] == '.') { /* Is this a dot entry? */
S		for (;;) {
S			c = (BYTE)p[si++];
S			if (c != '.' || si >= 3) break;
S			sfn[i++] = c;
S		}
S		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
S		*path = &p[si];									/* Return pointer to the next segment */
S		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
S		return FR_OK;
S	}
S#endif
S	for (;;) {
S		c = (BYTE)p[si++];
S		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
S		if (c == '.' || i >= ni) {
S			if (ni != 8 || c != '.') return FR_INVALID_NAME;
S			i = 8; ni = 11;
S			b <<= 2; continue;
S		}
S		if (c >= 0x80) {				/* Extended char? */
S			b |= 3;						/* Eliminate NT flag */
S#ifdef _EXCVT
S			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
S#else
S#if !_DF1S	/* ASCII only cfg */
S			return FR_INVALID_NAME;
S#endif
S#endif
S		}
S		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
S			d = (BYTE)p[si++];			/* Get 2nd byte */
S			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
S				return FR_INVALID_NAME;
S			sfn[i++] = c;
S			sfn[i++] = d;
S		} else {						/* Single byte code */
S			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
S				return FR_INVALID_NAME;
S			if (IsUpper(c)) {			/* ASCII large capital? */
S				b |= 2;
S			} else {
S				if (IsLower(c)) {		/* ASCII small capital? */
S					b |= 1; c -= 0x20;
S				}
S			}
S			sfn[i++] = c;
S		}
S	}
S	*path = &p[si];						/* Return pointer to the next segment */
S	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
S
S	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
S	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
S
S	if (ni == 8) b <<= 2;
S	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
S	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
S
S	sfn[NS] = c;		/* Store NT flag, File name is created */
S
S	return FR_OK;
N#endif
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Get file information from directory entry                             */
N/*-----------------------------------------------------------------------*/
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
Nstatic
Nvoid get_fileinfo (		/* No return code */
N	DIR *dj,			/* Pointer to the directory object */
N	FILINFO *fno	 	/* Pointer to the file information to be filled */
N)
N{
N	UINT i;
N	BYTE nt, *dir;
N	TCHAR *p, c;
N
N
N	p = fno->fname;
N	if (dj->sect) {
N		dir = dj->dir;
N		nt = dir[DIR_NTres];		/* NT flag */
X		nt = dir[12];		 
N		for (i = 0; i < 8; i++) {	/* Copy name body */
N			c = dir[i];
N			if (c == ' ') break;
N			if (c == NDDE) c = (TCHAR)DDE;
X			if (c == 0x05) c = (TCHAR)0xE5;
N			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
X			if (2 && (nt & 0x08) && (((c)>= 'A')&&((c)<= 'Z'))) c += 0x20;
N#if _LFN_UNICODE
X#if 0
S			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
S				c = (c << 8) | dir[++i];
S			c = ff_convert(c, 1);
S			if (!c) c = '?';
N#endif
N			*p++ = c;
N		}
N		if (dir[8] != ' ') {		/* Copy name extension */
N			*p++ = '.';
N			for (i = 8; i < 11; i++) {
N				c = dir[i];
N				if (c == ' ') break;
N				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
X				if (2 && (nt & 0x10) && (((c)>= 'A')&&((c)<= 'Z'))) c += 0x20;
N#if _LFN_UNICODE
X#if 0
S				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
S					c = (c << 8) | dir[++i];
S				c = ff_convert(c, 1);
S				if (!c) c = '?';
N#endif
N				*p++ = c;
N			}
N		}
N		fno->fattrib = dir[DIR_Attr];				/* Attribute */
X		fno->fattrib = dir[11];				 
N		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
X		fno->fsize = (DWORD)(((DWORD)*((BYTE*)(dir+28)+3)<<24)|((DWORD)*((BYTE*)(dir+28)+2)<<16)|((WORD)*((BYTE*)(dir+28)+1)<<8)| *(BYTE*)(dir+28));	 
N		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
X		fno->fdate = (WORD)(((WORD)*((BYTE*)(dir+24)+1)<<8)|(WORD)*(BYTE*)(dir+24));		 
N		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
X		fno->ftime = (WORD)(((WORD)*((BYTE*)(dir+22)+1)<<8)|(WORD)*(BYTE*)(dir+22));		 
N	}
N	*p = 0;		/* Terminate SFN str by a \0 */
N
N#if _USE_LFN
X#if 2
N	if (fno->lfname && fno->lfsize) {
N		TCHAR *tp = fno->lfname;
N		WCHAR w, *lfn;
N
N		i = 0;
N		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
N			lfn = dj->lfn;
N			while ((w = *lfn++) != 0) {			/* Get an LFN char */
N#if !_LFN_UNICODE
X#if !0
N				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
N				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
N				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
X				if (0 && w >= 0x100)		 
N					tp[i++] = (TCHAR)(w >> 8);
N#endif
N				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
N				tp[i++] = (TCHAR)w;
N			}
N		}
N		tp[i] = 0;	/* Terminate the LFN str by a \0 */
N	}
N#endif
N}
N#endif /* _FS_MINIMIZE <= 1 */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Follow a file path                                                    */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
N	DIR *dj,			/* Directory object to return last directory and found object */
N	const TCHAR *path	/* Full-path string to find a file or directory */
N)
N{
N	FRESULT res;
N	BYTE *dir, ns;
N
N
N#if _FS_RPATH
X#if 2
N	if (*path == '/' || *path == '\\') { /* There is a heading separator */
N		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
N	} else {							/* No heading separator */
N		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
N	}
N#else
S	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
S		path++;
S	dj->sclust = 0;						/* Start from the root dir */
N#endif
N
N	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
N		res = dir_sdi(dj, 0);
N		dj->dir = 0;
N	} else {							/* Follow path */
N		for (;;) {
N			res = create_name(dj, &path);	/* Get a segment */
N			if (res != FR_OK) break;
N			res = dir_find(dj);				/* Find it */
N			ns = *(dj->fn+NS);
X			ns = *(dj->fn+11);
N			if (res != FR_OK) {				/* Failed to find the object */
N				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
N				/* Object not found */
N				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
X				if (2 && (ns & 0x20)) {	 
N					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
N					res = FR_OK;
N					if (!(ns & NS_LAST)) continue;
X					if (!(ns & 0x04)) continue;
N				} else {							/* Could not find the object */
N					if (!(ns & NS_LAST)) res = FR_NO_PATH;
X					if (!(ns & 0x04)) res = FR_NO_PATH;
N				}
N				break;
N			}
N			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
X			if (ns & 0x04) break;			 
N			dir = dj->dir;						/* There is next segment. Follow the sub directory */
N			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
X			if (!(dir[11] & 0x10)) {	 
N				res = FR_NO_PATH; break;
N			}
N			dj->sclust = ld_clust(dj->fs, dir);
N		}
N	}
N
N	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Load a sector and check if it is an FAT Volume Boot Record            */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NBYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
N	FATFS *fs,	/* File system object */
N	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
N)
N{
N	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
N		return 3;
N	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
X	if ((WORD)(((WORD)*((BYTE*)(&fs->win[510])+1)<<8)|(WORD)*(BYTE*)(&fs->win[510])) != 0xAA55)		 
N		return 2;
N
N	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
X	if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[54])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[54])+2)<<16)|((WORD)*((BYTE*)(&fs->win[54])+1)<<8)| *(BYTE*)(&fs->win[54])) & 0xFFFFFF) == 0x544146)	 
N		return 0;
N	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
X	if (((DWORD)(((DWORD)*((BYTE*)(&fs->win[82])+3)<<24)|((DWORD)*((BYTE*)(&fs->win[82])+2)<<16)|((WORD)*((BYTE*)(&fs->win[82])+1)<<8)| *(BYTE*)(&fs->win[82])) & 0xFFFFFF) == 0x544146)
N		return 0;
N
N	return 1;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Check if the file system object is valid or not                       */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
N	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
N	FATFS **rfs,		/* Pointer to pointer to the found file system object */
N	BYTE wmode			/* !=0: Check write protection for write access */
N)
N{
N	BYTE fmt, b, pi, *tbl;
N	UINT vol;
N	DSTATUS stat;
N	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
N	WORD nrsv;
N	const TCHAR *p = *path;
N	FATFS *fs;
N
N
N										/* Get logical drive number from the path name */
N	vol = p[0] - '0';					/* Is there a drive number? */
N	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
N		p += 2; *path = p;				/* Return pointer to the path name */
N	} else {							/* No drive number is given */
N#if _FS_RPATH
X#if 2
N		vol = CurrVol;					/* Use current drive */
N#else
S		vol = 0;						/* Use drive 0 */
N#endif
N	}
N
N	/* Check if the file system object is valid or not */
N	*rfs = 0;
N	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
X	if (vol >= 2) 				 
N		return FR_INVALID_DRIVE;
N	fs = FatFs[vol];					/* Get corresponding file system object */
N	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
N
N	ENTER_FF(fs);						/* Lock file system */
X	;						 
N
N	*rfs = fs;							/* Return pointer to the corresponding file system object */
N	if (fs->fs_type) {					/* If the volume has been mounted */
N		stat = disk_status(fs->drv);
N		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
X		if (!(stat & 0x01)) {		 
N			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
X			if (!1 && wmode && (stat & 0x04))	 
N				return FR_WRITE_PROTECTED;
N			return FR_OK;				/* The file system object is valid */
N		}
N	}
N
N	/* The file system object is not valid. */
N	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
N
N	fs->fs_type = 0;					/* Clear the file system object */
N	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
X	fs->drv = (BYTE)(vol);				 
N	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
N	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
X	if (stat & 0x01)				 
N		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
N	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
X	if (!1 && wmode && (stat & 0x04))	 
N		return FR_WRITE_PROTECTED;
N#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
X#if 512 != 512						 
S	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
S		return FR_DISK_ERR;
N#endif
N	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
N	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
N	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
X	if (0 && !fmt) fmt = 1;	 
N	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
N		/* Check the partition listed in the partition table */
N		pi = LD2PT(vol);
X		pi = 0;
N		if (pi) pi--;
N		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
X		tbl = &fs->win[446 + pi * 16]; 
N		if (tbl[4]) {						/* Is the partition existing? */
N			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
X			bsect = (DWORD)(((DWORD)*((BYTE*)(&tbl[8])+3)<<24)|((DWORD)*((BYTE*)(&tbl[8])+2)<<16)|((WORD)*((BYTE*)(&tbl[8])+1)<<8)| *(BYTE*)(&tbl[8]));		 
N			fmt = check_fs(fs, bsect);		/* Check the partition */
N		}
N	}
N	if (fmt == 3) return FR_DISK_ERR;
N	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
N
N	/* An FAT volume is found. Following code initializes the file system object */
N
N	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
X	if ((WORD)(((WORD)*((BYTE*)(fs->win+11)+1)<<8)|(WORD)*(BYTE*)(fs->win+11)) != 512U)		 
N		return FR_NO_FILESYSTEM;
N
N	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
X	fasize = (WORD)(((WORD)*((BYTE*)(fs->win+22)+1)<<8)|(WORD)*(BYTE*)(fs->win+22));				 
N	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
X	if (!fasize) fasize = (DWORD)(((DWORD)*((BYTE*)(fs->win+36)+3)<<24)|((DWORD)*((BYTE*)(fs->win+36)+2)<<16)|((WORD)*((BYTE*)(fs->win+36)+1)<<8)| *(BYTE*)(fs->win+36));
N	fs->fsize = fasize;
N
N	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
X	fs->n_fats = b = fs->win[16];				 
N	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
N	fasize *= b;										/* Number of sectors for FAT area */
N
N	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
X	fs->csize = b = fs->win[13];			 
N	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
N
N	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
X	fs->n_rootdir = (WORD)(((WORD)*((BYTE*)(fs->win+17)+1)<<8)|(WORD)*(BYTE*)(fs->win+17));	 
N	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
X	if (fs->n_rootdir % (512U / 32)) return FR_NO_FILESYSTEM;	 
N
N	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
X	tsect = (WORD)(((WORD)*((BYTE*)(fs->win+19)+1)<<8)|(WORD)*(BYTE*)(fs->win+19));				 
N	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
X	if (!tsect) tsect = (DWORD)(((DWORD)*((BYTE*)(fs->win+32)+3)<<24)|((DWORD)*((BYTE*)(fs->win+32)+2)<<16)|((WORD)*((BYTE*)(fs->win+32)+1)<<8)| *(BYTE*)(fs->win+32));
N
N	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
X	nrsv = (WORD)(((WORD)*((BYTE*)(fs->win+14)+1)<<8)|(WORD)*(BYTE*)(fs->win+14));				 
N	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
N
N	/* Determine the FAT sub type */
N	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
X	sysect = nrsv + fasize + fs->n_rootdir / (512U / 32);	 
N	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
N	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
N	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
N	fmt = FS_FAT12;
X	fmt = 1;
N	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
X	if (nclst >= 4086) fmt = 2;
N	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
X	if (nclst >= 65526) fmt = 3;
N
N	/* Boundaries and Limits */
N	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
N	fs->database = bsect + sysect;						/* Data start sector */
N	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
N	if (fmt == FS_FAT32) {
X	if (fmt == 3) {
N		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
N		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
X		fs->dirbase = (DWORD)(((DWORD)*((BYTE*)(fs->win+44)+3)<<24)|((DWORD)*((BYTE*)(fs->win+44)+2)<<16)|((WORD)*((BYTE*)(fs->win+44)+1)<<8)| *(BYTE*)(fs->win+44));	 
N		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
N	} else {
N		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
N		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
N		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
X		szbfat = (fmt == 2) ?					 
N			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
N	}
N	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
X	if (fs->fsize < (szbfat + (512U - 1)) / 512U)	 
N		return FR_NO_FILESYSTEM;
N
N#if !_FS_READONLY
X#if !1
S	/* Initialize cluster allocation information */
S	fs->free_clust = 0xFFFFFFFF;
S	fs->last_clust = 0;
S
S	/* Get fsinfo if available */
S	if (fmt == FS_FAT32) {
S	 	fs->fsi_flag = 0;
S		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
S		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
S			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
S			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
S			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
S				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
S				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
S		}
S	}
N#endif
N	fs->fs_type = fmt;		/* FAT sub-type */
N	fs->id = ++Fsid;		/* File system mount ID */
N	fs->winsect = 0;		/* Invalidate sector cache */
N	fs->wflag = 0;
N#if _FS_RPATH
X#if 2
N	fs->cdir = 0;			/* Current directory (root dir) */
N#endif
N#if _FS_LOCK				/* Clear file lock semaphores */
X#if 0				 
S	clear_lock(fs);
N#endif
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Check if the file/dir object is valid or not                          */
N/*-----------------------------------------------------------------------*/
N
Nstatic
NFRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
N	void* obj		/* Pointer to the object FIL/DIR to check validity */
N)
N{
N	FIL *fil;
N
N	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
N	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
N		return FR_INVALID_OBJECT;
N
N	ENTER_FF(fil->fs);		/* Lock file system */
X	;		 
N
N	if (disk_status(fil->fs->drv) & STA_NOINIT)
X	if (disk_status(fil->fs->drv) & 0x01)
N		return FR_NOT_READY;
N
N	return FR_OK;
N}
N
N
N
N
N/*--------------------------------------------------------------------------
N
N   Public Functions
N
N--------------------------------------------------------------------------*/
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Mount/Unmount a Logical Drive                                         */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_mount (
N	BYTE vol,		/* Logical drive number to be mounted/unmounted */
N	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
N)
N{
N	FATFS *rfs;
N
N
N	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
X	if (vol >= 2)		 
N		return FR_INVALID_DRIVE;
N	rfs = FatFs[vol];			/* Get current fs object */
N
N	if (rfs) {
N#if _FS_LOCK
X#if 0
S		clear_lock(rfs);
N#endif
N#if _FS_REENTRANT				/* Discard sync object of the current volume */
X#if 0				 
S		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
N#endif
N		rfs->fs_type = 0;		/* Clear old fs object */
N	}
N
N	if (fs) {
N		fs->fs_type = 0;		/* Clear new fs object */
N#if _FS_REENTRANT				/* Create sync object for the new volume */
X#if 0				 
S		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
N#endif
N	}
N	FatFs[vol] = fs;			/* Register new fs object */
N
N	return FR_OK;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Open or Create a File                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_open (
N	FIL *fp,			/* Pointer to the blank file object */
N	const TCHAR *path,	/* Pointer to the file name */
N	BYTE mode			/* Access mode and file open mode flags */
N)
N{
N	FRESULT res;
N	DIR dj;
N	BYTE *dir;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N
N	if (!fp) return FR_INVALID_OBJECT;
N	fp->fs = 0;			/* Clear file object */
N
N#if !_FS_READONLY
X#if !1
S	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
S	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
N#else
N	mode &= FA_READ;
X	mode &= 0x01;
N	res = chk_mounted(&path, &dj.fs, 0);
N#endif
N	if (res == FR_OK) {
N		INIT_BUF(dj);
X		{ (dj). fn = sfn; (dj). lfn = lbuf; };
N		res = follow_path(&dj, path);	/* Follow the file path */
N		dir = dj.dir;
N#if !_FS_READONLY	/* R/W configuration */
X#if !1	 
S		if (res == FR_OK) {
S			if (!dir)	/* Current dir itself */
S				res = FR_INVALID_NAME;
S#if _FS_LOCK
S			else
S				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
S#endif
S		}
S		/* Create or Open a file */
S		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
S			DWORD dw, cl;
S
S			if (res != FR_OK) {					/* No file, create new */
S				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
S#if _FS_LOCK
S					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
S#else
S					res = dir_register(&dj);
S#endif
S				mode |= FA_CREATE_ALWAYS;		/* File is created */
S				dir = dj.dir;					/* New entry */
S			}
S			else {								/* Any object is already existing */
S				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
S					res = FR_DENIED;
S				} else {
S					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
S						res = FR_EXIST;
S				}
S			}
S			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
S				dw = get_fattime();					/* Created time */
S				ST_DWORD(dir+DIR_CrtTime, dw);
S				dir[DIR_Attr] = 0;					/* Reset attribute */
S				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
S				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
S				st_clust(dir, 0);					/* cluster = 0 */
S				dj.fs->wflag = 1;
S				if (cl) {							/* Remove the cluster chain if exist */
S					dw = dj.fs->winsect;
S					res = remove_chain(dj.fs, cl);
S					if (res == FR_OK) {
S						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
S						res = move_window(dj.fs, dw);
S					}
S				}
S			}
S		}
S		else {	/* Open an existing file */
S			if (res == FR_OK) {						/* Follow succeeded */
S				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
S					res = FR_NO_FILE;
S				} else {
S					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
S						res = FR_DENIED;
S				}
S			}
S		}
S		if (res == FR_OK) {
S			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
S				mode |= FA__WRITTEN;
S			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
S			fp->dir_ptr = dir;
S#if _FS_LOCK
S			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
S			if (!fp->lockid) res = FR_INT_ERR;
S#endif
S		}
S
N#else				/* R/O configuration */
N		if (res == FR_OK) {					/* Follow succeeded */
N			dir = dj.dir;
N			if (!dir) {						/* Current dir itself */
N				res = FR_INVALID_NAME;
N			} else {
N				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
X				if (dir[11] & 0x10)	 
N					res = FR_NO_FILE;
N			}
N		}
N#endif
N		FREE_BUF();
X		;
N
N		if (res == FR_OK) {
N			fp->flag = mode;					/* File access mode */
N			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
N			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
X			fp->fsize = (DWORD)(((DWORD)*((BYTE*)(dir+28)+3)<<24)|((DWORD)*((BYTE*)(dir+28)+2)<<16)|((WORD)*((BYTE*)(dir+28)+1)<<8)| *(BYTE*)(dir+28));	 
N			fp->fptr = 0;						/* File pointer */
N			fp->dsect = 0;
N#if _USE_FASTSEEK
X#if 0
S			fp->cltbl = 0;						/* Normal seek mode */
N#endif
N			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
N		}
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read File                                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_read (
N	FIL *fp, 		/* Pointer to the file object */
N	void *buff,		/* Pointer to data buffer */
N	UINT btr,		/* Number of bytes to read */
N	UINT *br		/* Pointer to number of bytes read */
N)
N{
N	FRESULT res;
N	DWORD clst, sect, remain;
N	UINT rcnt, cc;
N	BYTE csect, *rbuff = buff;
N
N
N	*br = 0;	/* Clear read byte counter */
N
N	res = validate(fp);							/* Check validity */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)					/* Aborted file? */
X	if (fp->flag & 0x80)					 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N	if (!(fp->flag & FA_READ)) 					/* Check access mode */
X	if (!(fp->flag & 0x01)) 					 
N		LEAVE_FF(fp->fs, FR_DENIED);
X		return FR_DENIED;
N	remain = fp->fsize - fp->fptr;
N	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
N
N	for ( ;  btr;								/* Repeat until all data read */
N		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
N		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
X		if ((fp->fptr % 512U) == 0) {		 
N			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
X			csect = (BYTE)(fp->fptr / 512U & (fp->fs->csize - 1));	 
N			if (!csect) {						/* On the cluster boundary? */
N				if (fp->fptr == 0) {			/* On the top of the file? */
N					clst = fp->sclust;			/* Follow from the origin */
N				} else {						/* Middle or end of the file */
N#if _USE_FASTSEEK
X#if 0
S					if (fp->cltbl)
S						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
S					else
N#endif
N						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
N				}
N				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
X				if (clst < 2) { fp->flag |= 0x80; return FR_INT_ERR; };
N				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X				if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N				fp->clust = clst;				/* Update current cluster */
N			}
N			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
N			if (!sect) ABORT(fp->fs, FR_INT_ERR);
X			if (!sect) { fp->flag |= 0x80; return FR_INT_ERR; };
N			sect += csect;
N			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
X			cc = btr / 512U;				 
N			if (cc) {							/* Read maximum contiguous sectors directly */
N				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
N					cc = fp->fs->csize - csect;
N				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
X#if !1 && 0 <= 2			 
S#if _FS_TINY
S				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
S					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
S#else
S				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
S					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
S#endif
N#endif
N				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
X				rcnt = 512U * cc;			 
N				continue;
N			}
N#if !_FS_TINY
X#if !0
N			if (fp->dsect != sect) {			/* Load data sector if not in cache */
N#if !_FS_READONLY
X#if !1
S				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
S					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
S						ABORT(fp->fs, FR_DISK_ERR);
S					fp->flag &= ~FA__DIRTY;
S				}
N#endif
N				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
N					ABORT(fp->fs, FR_DISK_ERR);
X					{ fp->flag |= 0x80; return FR_DISK_ERR; };
N			}
N#endif
N			fp->dsect = sect;
N		}
N		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
X		rcnt = 512U - ((UINT)fp->fptr % 512U);	 
N		if (rcnt > btr) rcnt = btr;
N#if _FS_TINY
X#if 0
S		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
N#else
N		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
X		mem_cpy(rbuff, &fp->buf[fp->fptr % 512U], rcnt);	 
N#endif
N	}
N
N	LEAVE_FF(fp->fs, FR_OK);
X	return FR_OK;
N}
N
N
N
N
N#if !_FS_READONLY
X#if !1
S/*-----------------------------------------------------------------------*/
S/* Write File                                                            */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_write (
S	FIL *fp,			/* Pointer to the file object */
S	const void *buff,	/* Pointer to the data to be written */
S	UINT btw,			/* Number of bytes to write */
S	UINT *bw			/* Pointer to number of bytes written */
S)
S{
S	FRESULT res;
S	DWORD clst, sect;
S	UINT wcnt, cc;
S	const BYTE *wbuff = buff;
S	BYTE csect;
S
S
S	*bw = 0;	/* Clear write byte counter */
S
S	res = validate(fp);						/* Check validity */
S	if (res != FR_OK) LEAVE_FF(fp->fs, res);
S	if (fp->flag & FA__ERROR)				/* Aborted file? */
S		LEAVE_FF(fp->fs, FR_INT_ERR);
S	if (!(fp->flag & FA_WRITE))				/* Check access mode */
S		LEAVE_FF(fp->fs, FR_DENIED);
S	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
S
S	for ( ;  btw;							/* Repeat until all data written */
S		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
S		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
S			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
S			if (!csect) {					/* On the cluster boundary? */
S				if (fp->fptr == 0) {		/* On the top of the file? */
S					clst = fp->sclust;		/* Follow from the origin */
S					if (clst == 0)			/* When no cluster is allocated, */
S						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
S				} else {					/* Middle or end of the file */
S#if _USE_FASTSEEK
S					if (fp->cltbl)
S						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
S					else
S#endif
S						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
S				}
S				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
S				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
S				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
S				fp->clust = clst;			/* Update current cluster */
S			}
S#if _FS_TINY
S			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
S				ABORT(fp->fs, FR_DISK_ERR);
S#else
S			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
S				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
S					ABORT(fp->fs, FR_DISK_ERR);
S				fp->flag &= ~FA__DIRTY;
S			}
S#endif
S			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
S			if (!sect) ABORT(fp->fs, FR_INT_ERR);
S			sect += csect;
S			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
S			if (cc) {						/* Write maximum contiguous sectors directly */
S				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
S					cc = fp->fs->csize - csect;
S				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
S					ABORT(fp->fs, FR_DISK_ERR);
S#if _FS_TINY
S				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
S					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
S					fp->fs->wflag = 0;
S				}
S#else
S				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
S					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
S					fp->flag &= ~FA__DIRTY;
S				}
S#endif
S				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
S				continue;
S			}
S#if _FS_TINY
S			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
S				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
S				fp->fs->winsect = sect;
S			}
S#else
S			if (fp->dsect != sect) {		/* Fill sector cache with file data */
S				if (fp->fptr < fp->fsize &&
S					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
S						ABORT(fp->fs, FR_DISK_ERR);
S			}
S#endif
S			fp->dsect = sect;
S		}
S		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
S		if (wcnt > btw) wcnt = btw;
S#if _FS_TINY
S		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
S		fp->fs->wflag = 1;
S#else
S		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
S		fp->flag |= FA__DIRTY;
S#endif
S	}
S
S	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
S	fp->flag |= FA__WRITTEN;						/* Set file change flag */
S
S	LEAVE_FF(fp->fs, FR_OK);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Synchronize the File Object                                           */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_sync (
S	FIL *fp		/* Pointer to the file object */
S)
S{
S	FRESULT res;
S	DWORD tim;
S	BYTE *dir;
S
S
S	res = validate(fp);					/* Check validity of the object */
S	if (res == FR_OK) {
S		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
S#if !_FS_TINY	/* Write-back dirty buffer */
S			if (fp->flag & FA__DIRTY) {
S				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
S					LEAVE_FF(fp->fs, FR_DISK_ERR);
S				fp->flag &= ~FA__DIRTY;
S			}
S#endif
S			/* Update the directory entry */
S			res = move_window(fp->fs, fp->dir_sect);
S			if (res == FR_OK) {
S				dir = fp->dir_ptr;
S				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
S				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
S				st_clust(dir, fp->sclust);					/* Update start cluster */
S				tim = get_fattime();						/* Update updated time */
S				ST_DWORD(dir+DIR_WrtTime, tim);
S				ST_WORD(dir+DIR_LstAccDate, 0);
S				fp->flag &= ~FA__WRITTEN;
S				fp->fs->wflag = 1;
S				res = sync(fp->fs);
S			}
S		}
S	}
S
S	LEAVE_FF(fp->fs, res);
S}
S
N#endif /* !_FS_READONLY */
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Close File                                                            */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_close (
N	FIL *fp		/* Pointer to the file object to be closed */
N)
N{
N	FRESULT res;
N
N
N#if _FS_READONLY
X#if 1
N	res = validate(fp);
N	{
N#if _FS_REENTRANT
X#if 0
S		FATFS *fs = fp->fs;
N#endif
N		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
N		LEAVE_FF(fs, res);
X		return res;
N	}
N#else
S	res = f_sync(fp);		/* Flush cached data */
S#if _FS_LOCK
S	if (res == FR_OK) {		/* Decrement open counter */
S#if _FS_REENTRANT
S		FATFS *fs = fp->fs;;
S		res = validate(fp);
S		if (res == FR_OK) {
S			res = dec_lock(fp->lockid);	
S			unlock_fs(fs, FR_OK);
S		}
S#else
S		res = dec_lock(fp->lockid);
S#endif
S	}
S#endif
S	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
S	return res;
N#endif
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Current Drive/Directory Handlings                                     */
N/*-----------------------------------------------------------------------*/
N
N#if _FS_RPATH >= 1
X#if 2 >= 1
N
NFRESULT f_chdrive (
N	BYTE drv		/* Drive number */
N)
N{
N	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
X	if (drv >= 2) return FR_INVALID_DRIVE;
N
N	CurrVol = drv;
N
N	return FR_OK;
N}
N
N
N
NFRESULT f_chdir (
N	const TCHAR *path	/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	DIR dj;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N
N	res = chk_mounted(&path, &dj.fs, 0);
N	if (res == FR_OK) {
N		INIT_BUF(dj);
X		{ (dj). fn = sfn; (dj). lfn = lbuf; };
N		res = follow_path(&dj, path);		/* Follow the path */
N		FREE_BUF();
X		;
N		if (res == FR_OK) {					/* Follow completed */
N			if (!dj.dir) {
N				dj.fs->cdir = dj.sclust;	/* Start directory itself */
N			} else {
N				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
X				if (dj.dir[11] & 0x10)	 
N					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
N				else
N					res = FR_NO_PATH;		/* Reached but a file */
N			}
N		}
N		if (res == FR_NO_FILE) res = FR_NO_PATH;
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N#if _FS_RPATH >= 2
X#if 2 >= 2
NFRESULT f_getcwd (
N	TCHAR *path,	/* Pointer to the directory path */
N	UINT sz_path	/* Size of path */
N)
N{
N	FRESULT res;
N	DIR dj;
N	UINT i, n;
N	DWORD ccl;
N	TCHAR *tp;
N	FILINFO fno;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N
N	*path = 0;
N	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
N	if (res == FR_OK) {
N		INIT_BUF(dj);
X		{ (dj). fn = sfn; (dj). lfn = lbuf; };
N		i = sz_path;		/* Bottom of buffer (dir stack base) */
N		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
N		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
N			res = dir_sdi(&dj, 1);			/* Get parent dir */
N			if (res != FR_OK) break;
N			res = dir_read(&dj);
N			if (res != FR_OK) break;
N			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
N			res = dir_sdi(&dj, 0);
N			if (res != FR_OK) break;
N			do {							/* Find the entry links to the child dir */
N				res = dir_read(&dj);
N				if (res != FR_OK) break;
N				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
N				res = dir_next(&dj, 0);	
N			} while (res == FR_OK);
N			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
N			if (res != FR_OK) break;
N#if _USE_LFN
X#if 2
N			fno.lfname = path;
N			fno.lfsize = i;
N#endif
N			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
N			tp = fno.fname;
N			if (_USE_LFN && *path) tp = path;
X			if (2 && *path) tp = path;
N			for (n = 0; tp[n]; n++) ;
N			if (i < n + 3) {
N				res = FR_NOT_ENOUGH_CORE; break;
N			}
N			while (n) path[--i] = tp[--n];
N			path[--i] = '/';
N		}
N		tp = path;
N		if (res == FR_OK) {
N			*tp++ = '0' + CurrVol;			/* Put drive number */
N			*tp++ = ':';
N			if (i == sz_path) {				/* Root-dir */
N				*tp++ = '/';
N			} else {						/* Sub-dir */
N				do		/* Add stacked path str */
N					*tp++ = path[i++];
N				while (i < sz_path);
N			}
N		}
N		*tp = 0;
N		FREE_BUF();
X		;
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N#endif /* _FS_RPATH >= 2 */
N#endif /* _FS_RPATH >= 1 */
N
N
N
N#if _FS_MINIMIZE <= 2
X#if 0 <= 2
N/*-----------------------------------------------------------------------*/
N/* Seek File R/W Pointer                                                 */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_lseek (
N	FIL *fp,		/* Pointer to the file object */
N	DWORD ofs		/* File pointer from top of file */
N)
N{
N	FRESULT res;
N
N
N	res = validate(fp);					/* Check validity of the object */
N	if (res != FR_OK) LEAVE_FF(fp->fs, res);
X	if (res != FR_OK) return res;
N	if (fp->flag & FA__ERROR)			/* Check abort flag */
X	if (fp->flag & 0x80)			 
N		LEAVE_FF(fp->fs, FR_INT_ERR);
X		return FR_INT_ERR;
N
N#if _USE_FASTSEEK
X#if 0
S	if (fp->cltbl) {	/* Fast seek */
S		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
S
S		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
S			tbl = fp->cltbl;
S			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
S			cl = fp->sclust;			/* Top of the chain */
S			if (cl) {
S				do {
S					/* Get a fragment */
S					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
S					do {
S						pcl = cl; ncl++;
S						cl = get_fat(fp->fs, cl);
S						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
S						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
S					} while (cl == pcl + 1);
S					if (ulen <= tlen) {		/* Store the length and top of the fragment */
S						*tbl++ = ncl; *tbl++ = tcl;
S					}
S				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
S			}
S			*fp->cltbl = ulen;	/* Number of items used */
S			if (ulen <= tlen)
S				*tbl = 0;		/* Terminate table */
S			else
S				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
S
S		} else {						/* Fast seek */
S			if (ofs > fp->fsize)		/* Clip offset at the file size */
S				ofs = fp->fsize;
S			fp->fptr = ofs;				/* Set file pointer */
S			if (ofs) {
S				fp->clust = clmt_clust(fp, ofs - 1);
S				dsc = clust2sect(fp->fs, fp->clust);
S				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
S				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
S				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
S#if !_FS_TINY
S#if !_FS_READONLY
S					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
S						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
S							ABORT(fp->fs, FR_DISK_ERR);
S						fp->flag &= ~FA__DIRTY;
S					}
S#endif
S					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
S						ABORT(fp->fs, FR_DISK_ERR);
S#endif
S					fp->dsect = dsc;
S				}
S			}
S		}
S	} else
N#endif
N
N	/* Normal Seek */
N	{
N		DWORD clst, bcs, nsect, ifptr;
N
N		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
N#if !_FS_READONLY
X#if !1
S			 && !(fp->flag & FA_WRITE)
N#endif
N			) ofs = fp->fsize;
N
N		ifptr = fp->fptr;
N		fp->fptr = nsect = 0;
N		if (ofs) {
N			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
X			bcs = (DWORD)fp->fs->csize * 512U;	 
N			if (ifptr > 0 &&
N				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
N				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
N				ofs -= fp->fptr;
N				clst = fp->clust;
N			} else {									/* When seek to back cluster, */
N				clst = fp->sclust;						/* start from the first cluster */
N#if !_FS_READONLY
X#if !1
S				if (clst == 0) {						/* If no cluster chain, create a new chain */
S					clst = create_chain(fp->fs, 0);
S					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
S					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
S					fp->sclust = clst;
S				}
N#endif
N				fp->clust = clst;
N			}
N			if (clst != 0) {
N				while (ofs > bcs) {						/* Cluster following loop */
N#if !_FS_READONLY
X#if !1
S					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
S						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
S						if (clst == 0) {				/* When disk gets full, clip file size */
S							ofs = bcs; break;
S						}
S					} else
N#endif
N						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
N					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
X					if (clst == 0xFFFFFFFF) { fp->flag |= 0x80; return FR_DISK_ERR; };
N					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
X					if (clst <= 1 || clst >= fp->fs->n_fatent) { fp->flag |= 0x80; return FR_INT_ERR; };
N					fp->clust = clst;
N					fp->fptr += bcs;
N					ofs -= bcs;
N				}
N				fp->fptr += ofs;
N				if (ofs % SS(fp->fs)) {
X				if (ofs % 512U) {
N					nsect = clust2sect(fp->fs, clst);	/* Current sector */
N					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
X					if (!nsect) { fp->flag |= 0x80; return FR_INT_ERR; };
N					nsect += ofs / SS(fp->fs);
X					nsect += ofs / 512U;
N				}
N			}
N		}
N		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
X		if (fp->fptr % 512U && nsect != fp->dsect) {	 
N#if !_FS_TINY
X#if !0
N#if !_FS_READONLY
X#if !1
S			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
S				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
S					ABORT(fp->fs, FR_DISK_ERR);
S				fp->flag &= ~FA__DIRTY;
S			}
N#endif
N			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
N				ABORT(fp->fs, FR_DISK_ERR);
X				{ fp->flag |= 0x80; return FR_DISK_ERR; };
N#endif
N			fp->dsect = nsect;
N		}
N#if !_FS_READONLY
X#if !1
S		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
S			fp->fsize = fp->fptr;
S			fp->flag |= FA__WRITTEN;
S		}
N#endif
N	}
N
N	LEAVE_FF(fp->fs, res);
X	return res;
N}
N
N
N
N#if _FS_MINIMIZE <= 1
X#if 0 <= 1
N/*-----------------------------------------------------------------------*/
N/* Create a Directory Object                                             */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_opendir (
N	DIR *dj,			/* Pointer to directory object to create */
N	const TCHAR *path	/* Pointer to the directory path */
N)
N{
N	FRESULT res;
N	FATFS *fs;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N
N	if (!dj) return FR_INVALID_OBJECT;
N
N	res = chk_mounted(&path, &dj->fs, 0);
N	fs = dj->fs;
N	if (res == FR_OK) {
N		INIT_BUF(*dj);
X		{ (*dj). fn = sfn; (*dj). lfn = lbuf; };
N		res = follow_path(dj, path);			/* Follow the path to the directory */
N		FREE_BUF();
X		;
N		if (res == FR_OK) {						/* Follow completed */
N			if (dj->dir) {						/* It is not the root dir */
N				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
X				if (dj->dir[11] & 0x10) {	 
N					dj->sclust = ld_clust(fs, dj->dir);
N				} else {						/* The object is not a directory */
N					res = FR_NO_PATH;
N				}
N			}
N			if (res == FR_OK) {
N				dj->id = fs->id;
N				res = dir_sdi(dj, 0);			/* Rewind dir */
N			}
N		}
N		if (res == FR_NO_FILE) res = FR_NO_PATH;
N		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
N	} else {
N		dj->fs = 0;
N	}
N
N	LEAVE_FF(fs, res);
X	return res;
N}
N
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Read Directory Entry in Sequence                                      */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_readdir (
N	DIR *dj,			/* Pointer to the open directory object */
N	FILINFO *fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N
N	res = validate(dj);						/* Check validity of the object */
N	if (res == FR_OK) {
N		if (!fno) {
N			res = dir_sdi(dj, 0);			/* Rewind the directory object */
N		} else {
N			INIT_BUF(*dj);
X			{ (*dj). fn = sfn; (*dj). lfn = lbuf; };
N			res = dir_read(dj);				/* Read an directory item */
N			if (res == FR_NO_FILE) {		/* Reached end of dir */
N				dj->sect = 0;
N				res = FR_OK;
N			}
N			if (res == FR_OK) {				/* A valid entry is found */
N				get_fileinfo(dj, fno);		/* Get the object information */
N				res = dir_next(dj, 0);		/* Increment index for next */
N				if (res == FR_NO_FILE) {
N					dj->sect = 0;
N					res = FR_OK;
N				}
N			}
N			FREE_BUF();
X			;
N		}
N	}
N	LEAVE_FF(dj->fs, res);
X	return res;
N}
N
N
N
N#if _FS_MINIMIZE == 0
X#if 0 == 0
N/*-----------------------------------------------------------------------*/
N/* Get File Status                                                       */
N/*-----------------------------------------------------------------------*/
N
NFRESULT f_stat (
N	const TCHAR *path,	/* Pointer to the file path */
N	FILINFO *fno		/* Pointer to file information to return */
N)
N{
N	FRESULT res;
N	DIR dj;
N	DEF_NAMEBUF;
X	BYTE sfn[12]; WCHAR lbuf[255+1];
N
N	res = chk_mounted(&path, &dj.fs, 0);
N	if (res == FR_OK) {
N		INIT_BUF(dj);
X		{ (dj). fn = sfn; (dj). lfn = lbuf; };
N		res = follow_path(&dj, path);	/* Follow the file path */
N		if (res == FR_OK) {				/* Follow completed */
N			if (dj.dir)		/* Found an object */
N				get_fileinfo(&dj, fno);
N			else			/* It is root dir */
N				res = FR_INVALID_NAME;
N		}
N		FREE_BUF();
X		;
N	}
N
N	LEAVE_FF(dj.fs, res);
X	return res;
N}
N
N
N
N#if !_FS_READONLY
X#if !1
S/*-----------------------------------------------------------------------*/
S/* Get Number of Free Clusters                                           */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_getfree (
S	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
S	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
S	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
S)
S{
S	FRESULT res;
S	FATFS *fs;
S	DWORD n, clst, sect, stat;
S	UINT i;
S	BYTE fat, *p;
S
S
S	/* Get drive number */
S	res = chk_mounted(&path, fatfs, 0);
S	fs = *fatfs;
S	if (res == FR_OK) {
S		/* If free_clust is valid, return it without full cluster scan */
S		if (fs->free_clust <= fs->n_fatent - 2) {
S			*nclst = fs->free_clust;
S		} else {
S			/* Get number of free clusters */
S			fat = fs->fs_type;
S			n = 0;
S			if (fat == FS_FAT12) {
S				clst = 2;
S				do {
S					stat = get_fat(fs, clst);
S					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
S					if (stat == 1) { res = FR_INT_ERR; break; }
S					if (stat == 0) n++;
S				} while (++clst < fs->n_fatent);
S			} else {
S				clst = fs->n_fatent;
S				sect = fs->fatbase;
S				i = 0; p = 0;
S				do {
S					if (!i) {
S						res = move_window(fs, sect++);
S						if (res != FR_OK) break;
S						p = fs->win;
S						i = SS(fs);
S					}
S					if (fat == FS_FAT16) {
S						if (LD_WORD(p) == 0) n++;
S						p += 2; i -= 2;
S					} else {
S						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
S						p += 4; i -= 4;
S					}
S				} while (--clst);
S			}
S			fs->free_clust = n;
S			if (fat == FS_FAT32) fs->fsi_flag = 1;
S			*nclst = n;
S		}
S	}
S	LEAVE_FF(fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Truncate File                                                         */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_truncate (
S	FIL *fp		/* Pointer to the file object */
S)
S{
S	FRESULT res;
S	DWORD ncl;
S
S
S	if (!fp) return FR_INVALID_OBJECT;
S
S	res = validate(fp);						/* Check validity of the object */
S	if (res == FR_OK) {
S		if (fp->flag & FA__ERROR) {			/* Check abort flag */
S			res = FR_INT_ERR;
S		} else {
S			if (!(fp->flag & FA_WRITE))		/* Check access mode */
S				res = FR_DENIED;
S		}
S	}
S	if (res == FR_OK) {
S		if (fp->fsize > fp->fptr) {
S			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
S			fp->flag |= FA__WRITTEN;
S			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
S				res = remove_chain(fp->fs, fp->sclust);
S				fp->sclust = 0;
S			} else {				/* When truncate a part of the file, remove remaining clusters */
S				ncl = get_fat(fp->fs, fp->clust);
S				res = FR_OK;
S				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
S				if (ncl == 1) res = FR_INT_ERR;
S				if (res == FR_OK && ncl < fp->fs->n_fatent) {
S					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
S					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
S				}
S			}
S		}
S		if (res != FR_OK) fp->flag |= FA__ERROR;
S	}
S
S	LEAVE_FF(fp->fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Delete a File or Directory                                            */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_unlink (
S	const TCHAR *path		/* Pointer to the file or directory path */
S)
S{
S	FRESULT res;
S	DIR dj, sdj;
S	BYTE *dir;
S	DWORD dclst;
S	DEF_NAMEBUF;
S
S
S	res = chk_mounted(&path, &dj.fs, 1);
S	if (res == FR_OK) {
S		INIT_BUF(dj);
S		res = follow_path(&dj, path);		/* Follow the file path */
S		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
S			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
S#if _FS_LOCK
S		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
S#endif
S		if (res == FR_OK) {					/* The object is accessible */
S			dir = dj.dir;
S			if (!dir) {
S				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
S			} else {
S				if (dir[DIR_Attr] & AM_RDO)
S					res = FR_DENIED;		/* Cannot remove R/O object */
S			}
S			dclst = ld_clust(dj.fs, dir);
S			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
S				if (dclst < 2) {
S					res = FR_INT_ERR;
S				} else {
S					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-dir is empty or not */
S					sdj.sclust = dclst;
S					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
S					if (res == FR_OK) {
S						res = dir_read(&sdj);
S						if (res == FR_OK		/* Not empty dir */
S#if _FS_RPATH
S						|| dclst == dj.fs->cdir	/* Current dir */
S#endif
S						) res = FR_DENIED;
S						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
S					}
S				}
S			}
S			if (res == FR_OK) {
S				res = dir_remove(&dj);		/* Remove the directory entry */
S				if (res == FR_OK) {
S					if (dclst)				/* Remove the cluster chain if exist */
S						res = remove_chain(dj.fs, dclst);
S					if (res == FR_OK) res = sync(dj.fs);
S				}
S			}
S		}
S		FREE_BUF();
S	}
S	LEAVE_FF(dj.fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Create a Directory                                                    */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_mkdir (
S	const TCHAR *path		/* Pointer to the directory path */
S)
S{
S	FRESULT res;
S	DIR dj;
S	BYTE *dir, n;
S	DWORD dsc, dcl, pcl, tim = get_fattime();
S	DEF_NAMEBUF;
S
S
S	res = chk_mounted(&path, &dj.fs, 1);
S	if (res == FR_OK) {
S		INIT_BUF(dj);
S		res = follow_path(&dj, path);			/* Follow the file path */
S		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
S		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
S			res = FR_INVALID_NAME;
S		if (res == FR_NO_FILE) {				/* Can create a new directory */
S			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
S			res = FR_OK;
S			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
S			if (dcl == 1) res = FR_INT_ERR;
S			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
S			if (res == FR_OK)					/* Flush FAT */
S				res = move_window(dj.fs, 0);
S			if (res == FR_OK) {					/* Initialize the new directory table */
S				dsc = clust2sect(dj.fs, dcl);
S				dir = dj.fs->win;
S				mem_set(dir, 0, SS(dj.fs));
S				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
S				dir[DIR_Name] = '.';
S				dir[DIR_Attr] = AM_DIR;
S				ST_DWORD(dir+DIR_WrtTime, tim);
S				st_clust(dir, dcl);
S				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
S				dir[33] = '.'; pcl = dj.sclust;
S				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
S					pcl = 0;
S				st_clust(dir+SZ_DIR, pcl);
S				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
S					dj.fs->winsect = dsc++;
S					dj.fs->wflag = 1;
S					res = move_window(dj.fs, 0);
S					if (res != FR_OK) break;
S					mem_set(dir, 0, SS(dj.fs));
S				}
S			}
S			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
S			if (res != FR_OK) {
S				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
S			} else {
S				dir = dj.dir;
S				dir[DIR_Attr] = AM_DIR;				/* Attribute */
S				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
S				st_clust(dir, dcl);					/* Table start cluster */
S				dj.fs->wflag = 1;
S				res = sync(dj.fs);
S			}
S		}
S		FREE_BUF();
S	}
S
S	LEAVE_FF(dj.fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Change Attribute                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_chmod (
S	const TCHAR *path,	/* Pointer to the file path */
S	BYTE value,			/* Attribute bits */
S	BYTE mask			/* Attribute mask to change */
S)
S{
S	FRESULT res;
S	DIR dj;
S	BYTE *dir;
S	DEF_NAMEBUF;
S
S
S	res = chk_mounted(&path, &dj.fs, 1);
S	if (res == FR_OK) {
S		INIT_BUF(dj);
S		res = follow_path(&dj, path);		/* Follow the file path */
S		FREE_BUF();
S		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
S			res = FR_INVALID_NAME;
S		if (res == FR_OK) {
S			dir = dj.dir;
S			if (!dir) {						/* Is it a root directory? */
S				res = FR_INVALID_NAME;
S			} else {						/* File or sub directory */
S				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
S				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
S				dj.fs->wflag = 1;
S				res = sync(dj.fs);
S			}
S		}
S	}
S
S	LEAVE_FF(dj.fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Change Timestamp                                                      */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_utime (
S	const TCHAR *path,	/* Pointer to the file/directory name */
S	const FILINFO *fno	/* Pointer to the time stamp to be set */
S)
S{
S	FRESULT res;
S	DIR dj;
S	BYTE *dir;
S	DEF_NAMEBUF;
S
S
S	res = chk_mounted(&path, &dj.fs, 1);
S	if (res == FR_OK) {
S		INIT_BUF(dj);
S		res = follow_path(&dj, path);	/* Follow the file path */
S		FREE_BUF();
S		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
S			res = FR_INVALID_NAME;
S		if (res == FR_OK) {
S			dir = dj.dir;
S			if (!dir) {					/* Root directory */
S				res = FR_INVALID_NAME;
S			} else {					/* File or sub-directory */
S				ST_WORD(dir+DIR_WrtTime, fno->ftime);
S				ST_WORD(dir+DIR_WrtDate, fno->fdate);
S				dj.fs->wflag = 1;
S				res = sync(dj.fs);
S			}
S		}
S	}
S
S	LEAVE_FF(dj.fs, res);
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Rename File/Directory                                                 */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_rename (
S	const TCHAR *path_old,	/* Pointer to the old name */
S	const TCHAR *path_new	/* Pointer to the new name */
S)
S{
S	FRESULT res;
S	DIR djo, djn;
S	BYTE buf[21], *dir;
S	DWORD dw;
S	DEF_NAMEBUF;
S
S
S	res = chk_mounted(&path_old, &djo.fs, 1);
S	if (res == FR_OK) {
S		djn.fs = djo.fs;
S		INIT_BUF(djo);
S		res = follow_path(&djo, path_old);		/* Check old object */
S		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
S			res = FR_INVALID_NAME;
S#if _FS_LOCK
S		if (res == FR_OK) res = chk_lock(&djo, 2);
S#endif
S		if (res == FR_OK) {						/* Old object is found */
S			if (!djo.dir) {						/* Is root dir? */
S				res = FR_NO_FILE;
S			} else {
S				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
S				mem_cpy(&djn, &djo, sizeof (DIR));		/* Check new object */
S				res = follow_path(&djn, path_new);
S				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
S				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
S/* Start critical section that an interruption or error can cause cross-link */
S					res = dir_register(&djn);			/* Register the new entry */
S					if (res == FR_OK) {
S						dir = djn.dir;					/* Copy object information except for name */
S						mem_cpy(dir+13, buf+2, 19);
S						dir[DIR_Attr] = buf[0] | AM_ARC;
S						djo.fs->wflag = 1;
S						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
S							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
S							if (!dw) {
S								res = FR_INT_ERR;
S							} else {
S								res = move_window(djo.fs, dw);
S								dir = djo.fs->win+SZ_DIR;	/* .. entry */
S								if (res == FR_OK && dir[1] == '.') {
S									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
S									st_clust(dir, dw);
S									djo.fs->wflag = 1;
S								}
S							}
S						}
S						if (res == FR_OK) {
S							res = dir_remove(&djo);		/* Remove old entry */
S							if (res == FR_OK)
S								res = sync(djo.fs);
S						}
S					}
S/* End critical section */
S				}
S			}
S		}
S		FREE_BUF();
S	}
S	LEAVE_FF(djo.fs, res);
S}
S
N#endif /* !_FS_READONLY */
N#endif /* _FS_MINIMIZE == 0 */
N#endif /* _FS_MINIMIZE <= 1 */
N#endif /* _FS_MINIMIZE <= 2 */
N
N
N
N/*-----------------------------------------------------------------------*/
N/* Forward data to the stream directly (available on only tiny cfg)      */
N/*-----------------------------------------------------------------------*/
N#if _USE_FORWARD && _FS_TINY
X#if 0 && 0
S
SFRESULT f_forward (
S	FIL *fp, 						/* Pointer to the file object */
S	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
S	UINT btr,						/* Number of bytes to forward */
S	UINT *bf						/* Pointer to number of bytes forwarded */
S)
S{
S	FRESULT res;
S	DWORD remain, clst, sect;
S	UINT rcnt;
S	BYTE csect;
S
S
S	*bf = 0;	/* Clear transfer byte counter */
S
S	if (!fp) return FR_INVALID_OBJECT;
S
S	res = validate(fp);								/* Check validity of the object */
S	if (res != FR_OK) LEAVE_FF(fp->fs, res);
S	if (fp->flag & FA__ERROR)						/* Check error flag */
S		LEAVE_FF(fp->fs, FR_INT_ERR);
S	if (!(fp->flag & FA_READ))						/* Check access mode */
S		LEAVE_FF(fp->fs, FR_DENIED);
S
S	remain = fp->fsize - fp->fptr;
S	if (btr > remain) btr = (UINT)remain;			/* Truncate btr by remaining bytes */
S
S	for ( ;  btr && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
S		fp->fptr += rcnt, *bf += rcnt, btr -= rcnt) {
S		csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
S		if ((fp->fptr % SS(fp->fs)) == 0) {			/* On the sector boundary? */
S			if (!csect) {							/* On the cluster boundary? */
S				clst = (fp->fptr == 0) ?			/* On the top of the file? */
S					fp->sclust : get_fat(fp->fs, fp->clust);
S				if (clst <= 1) ABORT(fp->fs, FR_INT_ERR);
S				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
S				fp->clust = clst;					/* Update current cluster */
S			}
S		}
S		sect = clust2sect(fp->fs, fp->clust);		/* Get current data sector */
S		if (!sect) ABORT(fp->fs, FR_INT_ERR);
S		sect += csect;
S		if (move_window(fp->fs, sect))				/* Move sector window */
S			ABORT(fp->fs, FR_DISK_ERR);
S		fp->dsect = sect;
S		rcnt = SS(fp->fs) - (WORD)(fp->fptr % SS(fp->fs));	/* Forward data from sector window */
S		if (rcnt > btr) rcnt = btr;
S		rcnt = (*func)(&fp->fs->win[(WORD)fp->fptr % SS(fp->fs)], rcnt);
S		if (!rcnt) ABORT(fp->fs, FR_INT_ERR);
S	}
S
S	LEAVE_FF(fp->fs, FR_OK);
S}
N#endif /* _USE_FORWARD */
N
N
N
N#if _USE_MKFS && !_FS_READONLY
X#if 1 && !1
S/*-----------------------------------------------------------------------*/
S/* Create File System on the Drive                                       */
S/*-----------------------------------------------------------------------*/
S#define N_ROOTDIR	512		/* Number of root dir entries for FAT12/16 */
S#define N_FATS		1		/* Number of FAT copies (1 or 2) */
S
S
SFRESULT f_mkfs (
S	BYTE drv,		/* Logical drive number */
S	BYTE sfd,		/* Partitioning rule 0:FDISK, 1:SFD */
S	UINT au			/* Allocation unit size [bytes] */
S)
S{
S	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
S	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
S	BYTE fmt, md, sys, *tbl, pdrv, part;
S	DWORD n_clst, vs, n, wsect;
S	UINT i;
S	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
S	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
S	FATFS *fs;
S	DSTATUS stat;
S
S
S	/* Check mounted drive and clear work area */
S	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
S	if (sfd > 1) return FR_INVALID_PARAMETER;
S	if (au & (au - 1)) return FR_INVALID_PARAMETER;
S	fs = FatFs[drv];
S	if (!fs) return FR_NOT_ENABLED;
S	fs->fs_type = 0;
S	pdrv = LD2PD(drv);	/* Physical drive */
S	part = LD2PT(drv);	/* Partition (0:auto detect, 1-4:get from partition table)*/
S
S	/* Get disk statics */
S	stat = disk_initialize(pdrv);
S	if (stat & STA_NOINIT) return FR_NOT_READY;
S	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
S#if _MAX_SS != 512					/* Get disk sector size */
S	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS)
S		return FR_DISK_ERR;
S#endif
S	if (_MULTI_PARTITION && part) {
S		/* Get partition information from partition table in the MBR */
S		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
S		if (LD_WORD(fs->win+BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
S		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
S		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
S		b_vol = LD_DWORD(tbl+8);	/* Volume start sector */
S		n_vol = LD_DWORD(tbl+12);	/* Volume size */
S	} else {
S		/* Create a partition in this function */
S		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128)
S			return FR_DISK_ERR;
S		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
S		n_vol -= b_vol;				/* Volume size */
S	}
S
S	if (!au) {				/* AU auto selection */
S		vs = n_vol / (2000 / (SS(fs) / 512));
S		for (i = 0; vs < vst[i]; i++) ;
S		au = cst[i];
S	}
S	au /= SS(fs);		/* Number of sectors per cluster */
S	if (au == 0) au = 1;
S	if (au > 128) au = 128;
S
S	/* Pre-compute number of clusters and FAT sub-type */
S	n_clst = n_vol / au;
S	fmt = FS_FAT12;
S	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
S	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
S
S	/* Determine offset and size of FAT structure */
S	if (fmt == FS_FAT32) {
S		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
S		n_rsv = 32;
S		n_dir = 0;
S	} else {
S		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
S		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
S		n_rsv = 1;
S		n_dir = (DWORD)N_ROOTDIR * SZ_DIR / SS(fs);
S	}
S	b_fat = b_vol + n_rsv;				/* FAT area start sector */
S	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
S	b_data = b_dir + n_dir;				/* Data area start sector */
S	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
S
S	/* Align data start sector to erase block boundary (for flash memory media) */
S	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
S	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
S	n = (n - b_data) / N_FATS;
S	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
S		n_rsv += n;
S		b_fat += n;
S	} else {					/* FAT12/16: Expand FAT size */
S		n_fat += n;
S	}
S
S	/* Determine number of clusters and final check of validity of the FAT sub-type */
S	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
S	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
S		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32))
S		return FR_MKFS_ABORTED;
S
S	switch (fmt) {	/* Determine system ID for partition table */
S	case FS_FAT12:	sys = 0x01; break;
S	case FS_FAT16:	sys = (n_vol < 0x10000) ? 0x04 : 0x06; break;
S	default: 		sys = 0x0C;
S	}
S
S	if (_MULTI_PARTITION && part) {
S		/* Update system ID in the partition table */
S		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
S		tbl[4] = sys;
S		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
S		md = 0xF8;
S	} else {
S		if (sfd) {	/* No partition table (SFD) */
S			md = 0xF0;
S		} else {	/* Create partition table (FDISK) */
S			mem_set(fs->win, 0, SS(fs));
S			tbl = fs->win+MBR_Table;	/* Create partition table for single partition in the drive */
S			tbl[1] = 1;						/* Partition start head */
S			tbl[2] = 1;						/* Partition start sector */
S			tbl[3] = 0;						/* Partition start cylinder */
S			tbl[4] = sys;					/* System type */
S			tbl[5] = 254;					/* Partition end head */
S			n = (b_vol + n_vol) / 63 / 255;
S			tbl[6] = (BYTE)((n >> 2) | 63);	/* Partition end sector */
S			tbl[7] = (BYTE)n;				/* End cylinder */
S			ST_DWORD(tbl+8, 63);			/* Partition start in LBA */
S			ST_DWORD(tbl+12, n_vol);		/* Partition size in LBA */
S			ST_WORD(fs->win+BS_55AA, 0xAA55);	/* MBR signature */
S			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK)	/* Write it to the MBR sector */
S				return FR_DISK_ERR;
S			md = 0xF8;
S		}
S	}
S
S	/* Create BPB in the VBR */
S	tbl = fs->win;							/* Clear sector */
S	mem_set(tbl, 0, SS(fs));
S	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
S	i = SS(fs);								/* Sector size */
S	ST_WORD(tbl+BPB_BytsPerSec, i);
S	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
S	ST_WORD(tbl+BPB_RsvdSecCnt, n_rsv);		/* Reserved sectors */
S	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
S	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of rootdir entries */
S	ST_WORD(tbl+BPB_RootEntCnt, i);
S	if (n_vol < 0x10000) {					/* Number of total sectors */
S		ST_WORD(tbl+BPB_TotSec16, n_vol);
S	} else {
S		ST_DWORD(tbl+BPB_TotSec32, n_vol);
S	}
S	tbl[BPB_Media] = md;					/* Media descriptor */
S	ST_WORD(tbl+BPB_SecPerTrk, 63);			/* Number of sectors per track */
S	ST_WORD(tbl+BPB_NumHeads, 255);			/* Number of heads */
S	ST_DWORD(tbl+BPB_HiddSec, b_vol);		/* Hidden sectors */
S	n = get_fattime();						/* Use current time as VSN */
S	if (fmt == FS_FAT32) {
S		ST_DWORD(tbl+BS_VolID32, n);		/* VSN */
S		ST_DWORD(tbl+BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
S		ST_DWORD(tbl+BPB_RootClus, 2);		/* Root directory start cluster (2) */
S		ST_WORD(tbl+BPB_FSInfo, 1);			/* FSInfo record offset (VBR+1) */
S		ST_WORD(tbl+BPB_BkBootSec, 6);		/* Backup boot record offset (VBR+6) */
S		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
S		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
S		mem_cpy(tbl+BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
S	} else {
S		ST_DWORD(tbl+BS_VolID, n);			/* VSN */
S		ST_WORD(tbl+BPB_FATSz16, n_fat);	/* Number of sectors per FAT */
S		tbl[BS_DrvNum] = 0x80;				/* Drive number */
S		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
S		mem_cpy(tbl+BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
S	}
S	ST_WORD(tbl+BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
S	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK)	/* Write it to the VBR sector */
S		return FR_DISK_ERR;
S	if (fmt == FS_FAT32)							/* Write backup VBR if needed (VBR+6) */
S		disk_write(pdrv, tbl, b_vol + 6, 1);
S
S	/* Initialize FAT area */
S	wsect = b_fat;
S	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
S		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
S		n = md;								/* Media descriptor byte */
S		if (fmt != FS_FAT32) {
S			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
S			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT12/16) */
S		} else {
S			n |= 0xFFFFFF00;
S			ST_DWORD(tbl+0, n);				/* Reserve cluster #0-1 (FAT32) */
S			ST_DWORD(tbl+4, 0xFFFFFFFF);
S			ST_DWORD(tbl+8, 0x0FFFFFFF);	/* Reserve cluster #2 for root dir */
S		}
S		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
S			return FR_DISK_ERR;
S		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
S		__print(" formatting");
S		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
S			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
S				__print(" error!");
S				return FR_DISK_ERR;
S			}
S
Sextern 
Svoid	(*App_Loop)(void);
Svoid	Wait(int,void (*)(void));
S			Wait(5,App_Loop);
S
S			if((n*100+n_fat/2)/n_fat % 10 == 0)
S				__print(".");
S		}
S				__print(" done!");
S	}
S
S	/* Initialize root directory */
S	i = (fmt == FS_FAT32) ? au : n_dir;
S	do {
S		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK)
S			return FR_DISK_ERR;
S	} while (--i);
S
S#if _USE_ERASE	/* Erase data area if needed */
S	{
S		DWORD eb[2];
S
S		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
S		disk_ioctl(pdrv, CTRL_ERASE_SECTOR, eb);
S	}
S#endif
S
S	/* Create FSInfo if needed */
S	if (fmt == FS_FAT32) {
S		ST_DWORD(tbl+FSI_LeadSig, 0x41615252);
S		ST_DWORD(tbl+FSI_StrucSig, 0x61417272);
S		ST_DWORD(tbl+FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
S		ST_DWORD(tbl+FSI_Nxt_Free, 2);				/* Last allocated cluster# */
S		ST_WORD(tbl+BS_55AA, 0xAA55);
S		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR+1) */
S		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR+7) */
S	}
S
S	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
S}
S
S
S#if _MULTI_PARTITION == 2
S/*-----------------------------------------------------------------------*/
S/* Divide Physical Drive                                                 */
S/*-----------------------------------------------------------------------*/
S
SFRESULT f_fdisk (
S	BYTE pdrv,			/* Physical drive number */
S	const DWORD szt[],	/* Pointer to the size table for each partitions */
S	void* work			/* Pointer to the working buffer */
S)
S{
S	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
S	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
S	DSTATUS stat;
S	DWORD sz_disk, sz_part, s_part;
S
S
S	stat = disk_initialize(pdrv);
S	if (stat & STA_NOINIT) return FR_NOT_READY;
S	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
S	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
S
S	/* Determine CHS in the table regardless of the drive geometry */
S	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
S	if (n == 256) n--;
S	e_hd = n - 1;
S	sz_cyl = 63 * n;
S	tot_cyl = sz_disk / sz_cyl;
S
S	/* Create partition table */
S	mem_set(buf, 0, _MAX_SS);
S	p = buf + MBR_Table; b_cyl = 0;
S	for (i = 0; i < 4; i++, p += SZ_PTE) {
S		p_cyl = (szt[i] <= 100) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
S		if (!p_cyl) continue;
S		s_part = (DWORD)sz_cyl * b_cyl;
S		sz_part = (DWORD)sz_cyl * p_cyl;
S		if (i == 0) {	/* Exclude first track of cylinder 0 */
S			s_hd = 1;
S			s_part += 63; sz_part -= 63;
S		} else {
S			s_hd = 0;
S		}
S		e_cyl = b_cyl + p_cyl - 1;
S		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
S
S		/* Set partition table */
S		p[1] = s_hd;						/* Start head */
S		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
S		p[3] = (BYTE)b_cyl;					/* Start cylinder */
S		p[4] = 0x06;						/* System type (temporary setting) */
S		p[5] = e_hd;						/* End head */
S		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
S		p[7] = (BYTE)e_cyl;					/* End cylinder */
S		ST_DWORD(p + 8, s_part);			/* Start sector in LBA */
S		ST_DWORD(p + 12, sz_part);			/* Partition size */
S
S		/* Next partition */
S		b_cyl += p_cyl;
S	}
S	ST_WORD(p, 0xAA55);
S
S	/* Write it to the MBR */
S	return (disk_write(pdrv, buf, 0, 1) || disk_ioctl(pdrv, CTRL_SYNC, 0)) ? FR_DISK_ERR : FR_OK;
S}
S
S
S#endif /* _MULTI_PARTITION == 2 */
N#endif /* _USE_MKFS && !_FS_READONLY */
N
N
N
N
N#if _USE_STRFUNC
X#if 1
N/*-----------------------------------------------------------------------*/
N/* Get a string from the file                                            */
N/*-----------------------------------------------------------------------*/
NTCHAR* f_gets (
N	TCHAR* buff,	/* Pointer to the string buffer to read */
N	int len,		/* Size of string buffer (characters) */
N	FIL* fil		/* Pointer to the file object */
N)
N{
N	int n = 0;
N	TCHAR c, *p = buff;
N	BYTE s[2];
N	UINT rc;
N
N	while (n < len - 1) {			/* Read bytes until buffer gets filled */
N		f_read(fil, s, 1, &rc);
N		if (rc != 1) break;			/* Break on EOF or error */
N		c = s[0];
N#if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
X#if 0					 
S		if (c >= 0x80) {
S			if (c < 0xC0) continue;	/* Skip stray trailer */
S			if (c < 0xE0) {			/* Two-byte sequence */
S				f_read(fil, s, 1, &rc);
S				if (rc != 1) break;
S				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
S				if (c < 0x80) c = '?';
S			} else {
S				if (c < 0xF0) {		/* Three-byte sequence */
S					f_read(fil, s, 2, &rc);
S					if (rc != 2) break;
S					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
S					if (c < 0x800) c = '?';
S				} else {			/* Reject four-byte sequence */
S					c = '?';
S				}
S			}
S		}
N#endif
N#if _USE_STRFUNC >= 2
X#if 1 >= 2
S		if (c == '\r') continue;	/* Strip '\r' */
N#endif
N		*p++ = c;
N		n++;
N		if (c == '\n') break;		/* Break on EOL */
N	}
N	*p = 0;
N	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
N}
N
N
N
N#if !_FS_READONLY
X#if !1
S#include <stdarg.h>
S/*-----------------------------------------------------------------------*/
S/* Put a character to the file                                           */
S/*-----------------------------------------------------------------------*/
Sint f_putc (
S	TCHAR c,	/* A character to be output */
S	FIL* fil	/* Pointer to the file object */
S)
S{
S	UINT bw, btw;
S	BYTE s[3];
S
S
S#if _USE_STRFUNC >= 2
S	if (c == '\n') f_putc ('\r', fil);	/* LF -> CRLF conversion */
S#endif
S
S#if _LFN_UNICODE	/* Write the character in UTF-8 encoding */
S	if (c < 0x80) {			/* 7-bit */
S		s[0] = (BYTE)c;
S		btw = 1;
S	} else {
S		if (c < 0x800) {	/* 11-bit */
S			s[0] = (BYTE)(0xC0 | (c >> 6));
S			s[1] = (BYTE)(0x80 | (c & 0x3F));
S			btw = 2;
S		} else {			/* 16-bit */
S			s[0] = (BYTE)(0xE0 | (c >> 12));
S			s[1] = (BYTE)(0x80 | ((c >> 6) & 0x3F));
S			s[2] = (BYTE)(0x80 | (c & 0x3F));
S			btw = 3;
S		}
S	}
S#else				/* Write the character without conversion */
S	s[0] = (BYTE)c;
S	btw = 1;
S#endif
S	f_write(fil, s, btw, &bw);		/* Write the char to the file */
S	return (bw == btw) ? 1 : EOF;	/* Return the result */
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a string to the file                                              */
S/*-----------------------------------------------------------------------*/
Sint f_puts (
S	const TCHAR* str,	/* Pointer to the string to be output */
S	FIL* fil			/* Pointer to the file object */
S)
S{
S	int n;
S
S
S	for (n = 0; *str; str++, n++) {
S		if (f_putc(*str, fil) == EOF) return EOF;
S	}
S	return n;
S}
S
S
S
S
S/*-----------------------------------------------------------------------*/
S/* Put a formatted string to the file                                    */
S/*-----------------------------------------------------------------------*/
Sint f_printf (
S	FIL* fil,			/* Pointer to the file object */
S	const TCHAR* str,	/* Pointer to the format string */
S	...					/* Optional arguments... */
S)
S{
S	va_list arp;
S	BYTE f, r;
S	UINT i, j, w;
S	ULONG v;
S	TCHAR c, d, s[16], *p;
S	int res, chc, cc;
S
S
S	va_start(arp, str);
S
S	for (cc = res = 0; cc != EOF; res += cc) {
S		c = *str++;
S		if (c == 0) break;			/* End of string */
S		if (c != '%') {				/* Non escape character */
S			cc = f_putc(c, fil);
S			if (cc != EOF) cc = 1;
S			continue;
S		}
S		w = f = 0;
S		c = *str++;
S		if (c == '0') {				/* Flag: '0' padding */
S			f = 1; c = *str++;
S		} else {
S			if (c == '-') {			/* Flag: left justified */
S				f = 2; c = *str++;
S			}
S		}
S		while (IsDigit(c)) {		/* Precision */
S			w = w * 10 + c - '0';
S			c = *str++;
S		}
S		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
S			f |= 4; c = *str++;
S		}
S		if (!c) break;
S		d = c;
S		if (IsLower(d)) d -= 0x20;
S		switch (d) {				/* Type is... */
S		case 'S' :					/* String */
S			p = va_arg(arp, TCHAR*);
S			for (j = 0; p[j]; j++) ;
S			chc = 0;
S			if (!(f & 2)) {
S				while (j++ < w) chc += (cc = f_putc(' ', fil));
S			}
S			chc += (cc = f_puts(p, fil));
S			while (j++ < w) chc += (cc = f_putc(' ', fil));
S			if (cc != EOF) cc = chc;
S			continue;
S		case 'C' :					/* Character */
S			cc = f_putc((TCHAR)va_arg(arp, int), fil); continue;
S		case 'B' :					/* Binary */
S			r = 2; break;
S		case 'O' :					/* Octal */
S			r = 8; break;
S		case 'D' :					/* Signed decimal */
S		case 'U' :					/* Unsigned decimal */
S			r = 10; break;
S		case 'X' :					/* Hexdecimal */
S			r = 16; break;
S		default:					/* Unknown type (pass-through) */
S			cc = f_putc(c, fil); continue;
S		}
S
S		/* Get an argument and put it in numeral */
S		v = (f & 4) ? (ULONG)va_arg(arp, long) : ((d == 'D') ? (ULONG)(long)va_arg(arp, int) : (ULONG)va_arg(arp, unsigned int));
S		if (d == 'D' && (v & 0x80000000)) {
S			v = 0 - v;
S			f |= 8;
S		}
S		i = 0;
S		do {
S			d = (TCHAR)(v % r); v /= r;
S			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
S			s[i++] = d + '0';
S		} while (v && i < sizeof s / sizeof s[0]);
S		if (f & 8) s[i++] = '-';
S		j = i; d = (f & 1) ? '0' : ' ';
S		res = 0;
S		while (!(f & 2) && j++ < w) res += (cc = f_putc(d, fil));
S		do res += (cc = f_putc(s[--i], fil)); while(i);
S		while (j++ < w) res += (cc = f_putc(' ', fil));
S		if (cc != EOF) cc = res;
S	}
S
S	va_end(arp);
S	return (cc == EOF) ? cc : res;
S}
S
N#endif /* !_FS_READONLY */
N#endif /* _USE_STRFUNC */
