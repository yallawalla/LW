; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stm32f2xx_rcc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\stm32f2xx_rcc.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\Inc -I..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Pfm6Ctrl\inc\app -I..\..\Pfm6Ctrl\src\wifi -I..\..\..\Utilities\FatFs_R0.09a -I.\RTE\_iap...PFM6 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -D__PFM6__ -DHSE_VALUE=25000000 -DWITH_COM_PORT --omf_browse=.\output\stm32f2xx_rcc.crf ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1093     */
;;;1094   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L1.14|
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1098   
;;;1099     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1100     if (NewState != DISABLE)
;;;1101     {
;;;1102       RCC->AHB1ENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L1.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L1.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L1.24|
                  |L1.14|
;;;1103     }
;;;1104     else
;;;1105     {
;;;1106       RCC->AHB1ENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L1.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L1.28|
000016  601a              STR      r2,[r3,#0]
                  |L1.24|
;;;1107     }
;;;1108   }
000018  4770              BX       lr
;;;1109   
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1463     */
;;;1464   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L2.14|
;;;1465   {
;;;1466     /* Check the parameters */
;;;1467     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1468     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1469     if (NewState != DISABLE)
;;;1470     {
;;;1471       RCC->AHB1LPENR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L2.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L2.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L2.24|
                  |L2.14|
;;;1472     }
;;;1473     else
;;;1474     {
;;;1475       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L2.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L2.28|
000016  601a              STR      r2,[r3,#0]
                  |L2.24|
;;;1476     }
;;;1477   }
000018  4770              BX       lr
;;;1478   
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1281     */
;;;1282   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L3.14|
;;;1283   {
;;;1284     /* Check the parameters */
;;;1285     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1286     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1287   
;;;1288     if (NewState != DISABLE)
;;;1289     {
;;;1290       RCC->AHB1RSTR |= RCC_AHB1Periph;
000002  4a06              LDR      r2,|L3.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L3.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L3.24|
                  |L3.14|
;;;1291     }
;;;1292     else
;;;1293     {
;;;1294       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
00000e  4a03              LDR      r2,|L3.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L3.28|
000016  601a              STR      r2,[r3,#0]
                  |L3.24|
;;;1295     }
;;;1296   }
000018  4770              BX       lr
;;;1297   
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1125     */
;;;1126   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L4.14|
;;;1127   {
;;;1128     /* Check the parameters */
;;;1129     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1130     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1131   
;;;1132     if (NewState != DISABLE)
;;;1133     {
;;;1134       RCC->AHB2ENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L4.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L4.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L4.24|
                  |L4.14|
;;;1135     }
;;;1136     else
;;;1137     {
;;;1138       RCC->AHB2ENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L4.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L4.28|
000016  601a              STR      r2,[r3,#0]
                  |L4.24|
;;;1139     }
;;;1140   }
000018  4770              BX       lr
;;;1141   
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1495     */
;;;1496   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L5.14|
;;;1497   {
;;;1498     /* Check the parameters */
;;;1499     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1500     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1501     if (NewState != DISABLE)
;;;1502     {
;;;1503       RCC->AHB2LPENR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L5.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L5.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L5.24|
                  |L5.14|
;;;1504     }
;;;1505     else
;;;1506     {
;;;1507       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L5.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L5.28|
000016  601a              STR      r2,[r3,#0]
                  |L5.24|
;;;1508     }
;;;1509   }
000018  4770              BX       lr
;;;1510   
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1310     */
;;;1311   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L6.14|
;;;1312   {
;;;1313     /* Check the parameters */
;;;1314     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1315     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1316   
;;;1317     if (NewState != DISABLE)
;;;1318     {
;;;1319       RCC->AHB2RSTR |= RCC_AHB2Periph;
000002  4a06              LDR      r2,|L6.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L6.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L6.24|
                  |L6.14|
;;;1320     }
;;;1321     else
;;;1322     {
;;;1323       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
00000e  4a03              LDR      r2,|L6.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L6.28|
000016  601a              STR      r2,[r3,#0]
                  |L6.24|
;;;1324     }
;;;1325   }
000018  4770              BX       lr
;;;1326   
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1152     */
;;;1153   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L7.14|
;;;1154   {
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1157     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1158   
;;;1159     if (NewState != DISABLE)
;;;1160     {
;;;1161       RCC->AHB3ENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L7.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L7.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L7.24|
                  |L7.14|
;;;1162     }
;;;1163     else
;;;1164     {
;;;1165       RCC->AHB3ENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L7.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L7.28|
000016  601a              STR      r2,[r3,#0]
                  |L7.24|
;;;1166     }
;;;1167   }
000018  4770              BX       lr
;;;1168   
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1522     */
;;;1523   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L8.14|
;;;1524   {
;;;1525     /* Check the parameters */
;;;1526     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1527     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1528     if (NewState != DISABLE)
;;;1529     {
;;;1530       RCC->AHB3LPENR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L8.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L8.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;1531     }
;;;1532     else
;;;1533     {
;;;1534       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L8.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L8.28|
000016  601a              STR      r2,[r3,#0]
                  |L8.24|
;;;1535     }
;;;1536   }
000018  4770              BX       lr
;;;1537   
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1334     */
;;;1335   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;1336   {
;;;1337     /* Check the parameters */
;;;1338     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1339     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1340   
;;;1341     if (NewState != DISABLE)
;;;1342     {
;;;1343       RCC->AHB3RSTR |= RCC_AHB3Periph;
000002  4a06              LDR      r2,|L9.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;1344     }
;;;1345     else
;;;1346     {
;;;1347       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
00000e  4a03              LDR      r2,|L9.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  601a              STR      r2,[r3,#0]
                  |L9.24|
;;;1348     }
;;;1349   }
000018  4770              BX       lr
;;;1350   
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1202     */
;;;1203   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L10.14|
;;;1204   {
;;;1205     /* Check the parameters */
;;;1206     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1207     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1208   
;;;1209     if (NewState != DISABLE)
;;;1210     {
;;;1211       RCC->APB1ENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L10.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L10.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L10.24|
                  |L10.14|
;;;1212     }
;;;1213     else
;;;1214     {
;;;1215       RCC->APB1ENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L10.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L10.28|
000016  601a              STR      r2,[r3,#0]
                  |L10.24|
;;;1216     }
;;;1217   }
000018  4770              BX       lr
;;;1218   
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1572     */
;;;1573   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;1574   {
;;;1575     /* Check the parameters */
;;;1576     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1577     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1578     if (NewState != DISABLE)
;;;1579     {
;;;1580       RCC->APB1LPENR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;1581     }
;;;1582     else
;;;1583     {
;;;1584       RCC->APB1LPENR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;1585     }
;;;1586   }
000018  4770              BX       lr
;;;1587   
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1381     */
;;;1382   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L12.14|
;;;1383   {
;;;1384     /* Check the parameters */
;;;1385     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1386     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1387     if (NewState != DISABLE)
;;;1388     {
;;;1389       RCC->APB1RSTR |= RCC_APB1Periph;
000002  4a06              LDR      r2,|L12.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L12.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;1390     }
;;;1391     else
;;;1392     {
;;;1393       RCC->APB1RSTR &= ~RCC_APB1Periph;
00000e  4a03              LDR      r2,|L12.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L12.28|
000016  601a              STR      r2,[r3,#0]
                  |L12.24|
;;;1394     }
;;;1395   }
000018  4770              BX       lr
;;;1396   
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1242     */
;;;1243   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L13.14|
;;;1244   {
;;;1245     /* Check the parameters */
;;;1246     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1247     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1248   
;;;1249     if (NewState != DISABLE)
;;;1250     {
;;;1251       RCC->APB2ENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L13.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L13.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L13.24|
                  |L13.14|
;;;1252     }
;;;1253     else
;;;1254     {
;;;1255       RCC->APB2ENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L13.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L13.28|
000016  601a              STR      r2,[r3,#0]
                  |L13.24|
;;;1256     }
;;;1257   }
000018  4770              BX       lr
;;;1258   
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1612     */
;;;1613   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L14.14|
;;;1614   {
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1617     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1618     if (NewState != DISABLE)
;;;1619     {
;;;1620       RCC->APB2LPENR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L14.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L14.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L14.24|
                  |L14.14|
;;;1621     }
;;;1622     else
;;;1623     {
;;;1624       RCC->APB2LPENR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L14.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L14.28|
000016  601a              STR      r2,[r3,#0]
                  |L14.24|
;;;1625     }
;;;1626   }
000018  4770              BX       lr
;;;1627   
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1417     */
;;;1418   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  b129              CBZ      r1,|L15.14|
;;;1419   {
;;;1420     /* Check the parameters */
;;;1421     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1422     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1423     if (NewState != DISABLE)
;;;1424     {
;;;1425       RCC->APB2RSTR |= RCC_APB2Periph;
000002  4a06              LDR      r2,|L15.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L15.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L15.24|
                  |L15.14|
;;;1426     }
;;;1427     else
;;;1428     {
;;;1429       RCC->APB2RSTR &= ~RCC_APB2Periph;
00000e  4a03              LDR      r2,|L15.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L15.28|
000016  601a              STR      r2,[r3,#0]
                  |L15.24|
;;;1430     }
;;;1431   }
000018  4770              BX       lr
;;;1432   
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;297      */
;;;298    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4601              MOV      r1,r0
;;;299    {
;;;300      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;301      /* Check the parameters */
;;;302      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;303    
;;;304      tmpreg = RCC->CR;
000004  4a03              LDR      r2,|L16.20|
000006  6810              LDR      r0,[r2,#0]
;;;305    
;;;306      /* Clear HSITRIM[4:0] bits */
;;;307      tmpreg &= ~RCC_CR_HSITRIM;
000008  f02000f8          BIC      r0,r0,#0xf8
;;;308    
;;;309      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;310      tmpreg |= (uint32_t)HSICalibrationValue << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;311    
;;;312      /* Store the new value */
;;;313      RCC->CR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;314    }
000012  4770              BX       lr
;;;315    
                          ENDP

                  |L16.20|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1035     */
;;;1036   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1037   {
;;;1038     /* Check the parameters */
;;;1039     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1040     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1041   }
000004  4770              BX       lr
;;;1042   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1738     */
;;;1739   void RCC_ClearFlag(void)
000000  4803              LDR      r0,|L18.16|
;;;1740   {
;;;1741     /* Set RMVF bit to clear the reset flags */
;;;1742     RCC->CSR |= RCC_CSR_RMVF;
000002  6800              LDR      r0,[r0,#0]
000004  f0407080          ORR      r0,r0,#0x1000000
000008  4901              LDR      r1,|L18.16|
00000a  6008              STR      r0,[r1,#0]
;;;1743   }
00000c  4770              BX       lr
;;;1744   
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1790     */
;;;1791   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;1792   {
;;;1793     /* Check the parameters */
;;;1794     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1795   
;;;1796     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1797        pending bits */
;;;1798     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;1799   }
000004  4770              BX       lr
;;;1800   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;525      */
;;;526    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;527    {
;;;528      /* Check the parameters */
;;;529      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;530      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;531    }
000004  4770              BX       lr
;;;532    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;201      */
;;;202    void RCC_DeInit(void)
000000  480e              LDR      r0,|L21.60|
;;;203    {
;;;204      /* Set HSION bit */
;;;205      RCC->CR |= (uint32_t)0x00000001;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  490c              LDR      r1,|L21.60|
00000a  6008              STR      r0,[r1,#0]
;;;206    
;;;207      /* Reset CFGR register */
;;;208      RCC->CFGR = 0x00000000;
00000c  2000              MOVS     r0,#0
00000e  490b              LDR      r1,|L21.60|
000010  3108              ADDS     r1,r1,#8
000012  6008              STR      r0,[r1,#0]
;;;209    
;;;210      /* Reset HSEON, CSSON and PLLON bits */
;;;211      RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  4809              LDR      r0,|L21.60|
000016  6800              LDR      r0,[r0,#0]
000018  4909              LDR      r1,|L21.64|
00001a  4008              ANDS     r0,r0,r1
00001c  4907              LDR      r1,|L21.60|
00001e  6008              STR      r0,[r1,#0]
;;;212    
;;;213      /* Reset PLLCFGR register */
;;;214      RCC->PLLCFGR = 0x24003010;
000020  4808              LDR      r0,|L21.68|
000022  1d09              ADDS     r1,r1,#4
000024  6008              STR      r0,[r1,#0]
;;;215    
;;;216      /* Reset HSEBYP bit */
;;;217      RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  1f08              SUBS     r0,r1,#4
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  1f09              SUBS     r1,r1,#4
000030  6008              STR      r0,[r1,#0]
;;;218    
;;;219      /* Disable all interrupts */
;;;220      RCC->CIR = 0x00000000;
000032  2000              MOVS     r0,#0
000034  4901              LDR      r1,|L21.60|
000036  310c              ADDS     r1,r1,#0xc
000038  6008              STR      r0,[r1,#0]
;;;221    }
00003a  4770              BX       lr
;;;222    
                          ENDP

                  |L21.60|
                          DCD      0x40023800
                  |L21.64|
                          DCD      0xfef6ffff
                  |L21.68|
                          DCD      0x24003010

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;861      */
;;;862    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b5f0              PUSH     {r4-r7,lr}
;;;863    {
;;;864      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
000002  2100              MOVS     r1,#0
000004  2200              MOVS     r2,#0
000006  2400              MOVS     r4,#0
000008  2502              MOVS     r5,#2
00000a  2600              MOVS     r6,#0
00000c  2302              MOVS     r3,#2
;;;865    
;;;866      /* Get SYSCLK source -------------------------------------------------------*/
;;;867      tmp = RCC->CFGR & RCC_CFGR_SWS;
00000e  4f32              LDR      r7,|L22.216|
000010  683f              LDR      r7,[r7,#0]
000012  f007010c          AND      r1,r7,#0xc
;;;868    
;;;869      switch (tmp)
000016  b121              CBZ      r1,|L22.34|
000018  2904              CMP      r1,#4
00001a  d005              BEQ      |L22.40|
00001c  2908              CMP      r1,#8
00001e  d137              BNE      |L22.144|
000020  e005              B        |L22.46|
                  |L22.34|
;;;870      {
;;;871        case 0x00:  /* HSI used as system clock source */
;;;872          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000022  4f2e              LDR      r7,|L22.220|
000024  6007              STR      r7,[r0,#0]
;;;873          break;
000026  e036              B        |L22.150|
                  |L22.40|
;;;874        case 0x04:  /* HSE used as system clock  source */
;;;875          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
000028  4f2d              LDR      r7,|L22.224|
00002a  6007              STR      r7,[r0,#0]
;;;876          break;
00002c  e033              B        |L22.150|
                  |L22.46|
;;;877        case 0x08:  /* PLL used as system clock  source */
;;;878    
;;;879          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;880             SYSCLK = PLL_VCO / PLLP
;;;881             */    
;;;882          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
00002e  4f2a              LDR      r7,|L22.216|
000030  1f3f              SUBS     r7,r7,#4
000032  683f              LDR      r7,[r7,#0]
000034  f3c75680          UBFX     r6,r7,#22,#1
;;;883          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
000038  4f27              LDR      r7,|L22.216|
00003a  1f3f              SUBS     r7,r7,#4
00003c  683f              LDR      r7,[r7,#0]
00003e  f007033f          AND      r3,r7,#0x3f
;;;884          
;;;885          if (pllsource != 0)
000042  b16e              CBZ      r6,|L22.96|
;;;886          {
;;;887            /* HSE used as PLL clock source */
;;;888            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000044  4f26              LDR      r7,|L22.224|
000046  fbb7f7f3          UDIV     r7,r7,r3
00004a  f8dfc08c          LDR      r12,|L22.216|
00004e  f1ac0c04          SUB      r12,r12,#4
000052  f8dcc000          LDR      r12,[r12,#0]
000056  f3cc1c88          UBFX     r12,r12,#6,#9
00005a  fb07f40c          MUL      r4,r7,r12
00005e  e00c              B        |L22.122|
                  |L22.96|
;;;889          }
;;;890          else
;;;891          {
;;;892            /* HSI used as PLL clock source */
;;;893            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000060  4f1e              LDR      r7,|L22.220|
000062  fbb7f7f3          UDIV     r7,r7,r3
000066  f8dfc070          LDR      r12,|L22.216|
00006a  f1ac0c04          SUB      r12,r12,#4
00006e  f8dcc000          LDR      r12,[r12,#0]
000072  f3cc1c88          UBFX     r12,r12,#6,#9
000076  fb07f40c          MUL      r4,r7,r12
                  |L22.122|
;;;894          }
;;;895    
;;;896          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00007a  4f17              LDR      r7,|L22.216|
00007c  1f3f              SUBS     r7,r7,#4
00007e  683f              LDR      r7,[r7,#0]
000080  f3c74701          UBFX     r7,r7,#16,#2
000084  1c7f              ADDS     r7,r7,#1
000086  007d              LSLS     r5,r7,#1
;;;897          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
000088  fbb4f7f5          UDIV     r7,r4,r5
00008c  6007              STR      r7,[r0,#0]
;;;898          break;
00008e  e002              B        |L22.150|
                  |L22.144|
;;;899        default:
;;;900          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000090  4f12              LDR      r7,|L22.220|
000092  6007              STR      r7,[r0,#0]
;;;901          break;
000094  bf00              NOP      
                  |L22.150|
000096  bf00              NOP                            ;873
;;;902      }
;;;903      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;904    
;;;905      /* Get HCLK prescaler */
;;;906      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000098  4f0f              LDR      r7,|L22.216|
00009a  683f              LDR      r7,[r7,#0]
00009c  f00701f0          AND      r1,r7,#0xf0
;;;907      tmp = tmp >> 4;
0000a0  0909              LSRS     r1,r1,#4
;;;908      presc = APBAHBPrescTable[tmp];
0000a2  4f10              LDR      r7,|L22.228|
0000a4  5c7a              LDRB     r2,[r7,r1]
;;;909      /* HCLK clock frequency */
;;;910      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
0000a6  6807              LDR      r7,[r0,#0]
0000a8  40d7              LSRS     r7,r7,r2
0000aa  6047              STR      r7,[r0,#4]
;;;911    
;;;912      /* Get PCLK1 prescaler */
;;;913      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
0000ac  4f0a              LDR      r7,|L22.216|
0000ae  683f              LDR      r7,[r7,#0]
0000b0  f40751e0          AND      r1,r7,#0x1c00
;;;914      tmp = tmp >> 10;
0000b4  0a89              LSRS     r1,r1,#10
;;;915      presc = APBAHBPrescTable[tmp];
0000b6  4f0b              LDR      r7,|L22.228|
0000b8  5c7a              LDRB     r2,[r7,r1]
;;;916      /* PCLK1 clock frequency */
;;;917      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000ba  6847              LDR      r7,[r0,#4]
0000bc  40d7              LSRS     r7,r7,r2
0000be  6087              STR      r7,[r0,#8]
;;;918    
;;;919      /* Get PCLK2 prescaler */
;;;920      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
0000c0  4f05              LDR      r7,|L22.216|
0000c2  683f              LDR      r7,[r7,#0]
0000c4  f4074160          AND      r1,r7,#0xe000
;;;921      tmp = tmp >> 13;
0000c8  0b49              LSRS     r1,r1,#13
;;;922      presc = APBAHBPrescTable[tmp];
0000ca  4f06              LDR      r7,|L22.228|
0000cc  5c7a              LDRB     r2,[r7,r1]
;;;923      /* PCLK2 clock frequency */
;;;924      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
0000ce  6847              LDR      r7,[r0,#4]
0000d0  40d7              LSRS     r7,r7,r2
0000d2  60c7              STR      r7,[r0,#0xc]
;;;925    }
0000d4  bdf0              POP      {r4-r7,pc}
;;;926    
                          ENDP

0000d6  0000              DCW      0x0000
                  |L22.216|
                          DCD      0x40023808
                  |L22.220|
                          DCD      0x00f42400
                  |L22.224|
                          DCD      0x017d7840
                  |L22.228|
                          DCD      APBAHBPrescTable

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1693     */
;;;1694   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1695   {
000002  4601              MOV      r1,r0
;;;1696     uint32_t tmp = 0;
000004  2200              MOVS     r2,#0
;;;1697     uint32_t statusreg = 0;
000006  2300              MOVS     r3,#0
;;;1698     FlagStatus bitstatus = RESET;
000008  2000              MOVS     r0,#0
;;;1699   
;;;1700     /* Check the parameters */
;;;1701     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1702   
;;;1703     /* Get the RCC register index */
;;;1704     tmp = RCC_FLAG >> 5;
00000a  114a              ASRS     r2,r1,#5
;;;1705     if (tmp == 1)               /* The flag to check is in CR register */
00000c  2a01              CMP      r2,#1
00000e  d102              BNE      |L23.22|
;;;1706     {
;;;1707       statusreg = RCC->CR;
000010  4c0a              LDR      r4,|L23.60|
000012  6823              LDR      r3,[r4,#0]
000014  e008              B        |L23.40|
                  |L23.22|
;;;1708     }
;;;1709     else if (tmp == 2)          /* The flag to check is in BDCR register */
000016  2a02              CMP      r2,#2
000018  d103              BNE      |L23.34|
;;;1710     {
;;;1711       statusreg = RCC->BDCR;
00001a  4c08              LDR      r4,|L23.60|
00001c  3470              ADDS     r4,r4,#0x70
00001e  6823              LDR      r3,[r4,#0]
000020  e002              B        |L23.40|
                  |L23.34|
;;;1712     }
;;;1713     else                       /* The flag to check is in CSR register */
;;;1714     {
;;;1715       statusreg = RCC->CSR;
000022  4c06              LDR      r4,|L23.60|
000024  3474              ADDS     r4,r4,#0x74
000026  6823              LDR      r3,[r4,#0]
                  |L23.40|
;;;1716     }
;;;1717   
;;;1718     /* Get the flag position */
;;;1719     tmp = RCC_FLAG & FLAG_MASK;
000028  f001021f          AND      r2,r1,#0x1f
;;;1720     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
00002c  2401              MOVS     r4,#1
00002e  4094              LSLS     r4,r4,r2
000030  401c              ANDS     r4,r4,r3
000032  b10c              CBZ      r4,|L23.56|
;;;1721     {
;;;1722       bitstatus = SET;
000034  2001              MOVS     r0,#1
000036  e000              B        |L23.58|
                  |L23.56|
;;;1723     }
;;;1724     else
;;;1725     {
;;;1726       bitstatus = RESET;
000038  2000              MOVS     r0,#0
                  |L23.58|
;;;1727     }
;;;1728     /* Return the flag status */
;;;1729     return bitstatus;
;;;1730   }
00003a  bd10              POP      {r4,pc}
;;;1731   
                          ENDP

                  |L23.60|
                          DCD      0x40023800

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1757     */
;;;1758   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4601              MOV      r1,r0
;;;1759   {
;;;1760     ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1761   
;;;1762     /* Check the parameters */
;;;1763     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1764   
;;;1765     /* Check the status of the specified RCC interrupt */
;;;1766     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L24.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L24.16|
;;;1767     {
;;;1768       bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L24.18|
                  |L24.16|
;;;1769     }
;;;1770     else
;;;1771     {
;;;1772       bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L24.18|
;;;1773     }
;;;1774     /* Return the RCC_IT status */
;;;1775     return  bitstatus;
;;;1776   }
000012  4770              BX       lr
;;;1777   
                          ENDP

                  |L24.20|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;721      */
;;;722    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;723    {
;;;724      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;725    }
000008  4770              BX       lr
;;;726    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;746      */
;;;747    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4601              MOV      r1,r0
;;;748    {
;;;749      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;750      
;;;751      /* Check the parameters */
;;;752      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;753    
;;;754      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L26.20|
000006  6810              LDR      r0,[r2,#0]
;;;755    
;;;756      /* Clear HPRE[3:0] bits */
;;;757      tmpreg &= ~RCC_CFGR_HPRE;
000008  f02000f0          BIC      r0,r0,#0xf0
;;;758    
;;;759      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;760      tmpreg |= RCC_SYSCLK;
00000c  4308              ORRS     r0,r0,r1
;;;761    
;;;762      /* Store the new value */
;;;763      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;764    }
000010  4770              BX       lr
;;;765    
                          ENDP

000012  0000              DCW      0x0000
                  |L26.20|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;242      */
;;;243    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  2100              MOVS     r1,#0
;;;244    {
;;;245      /* Check the parameters */
;;;246      assert_param(IS_RCC_HSE(RCC_HSE));
;;;247    
;;;248      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;249      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  4a02              LDR      r2,|L27.12|
000004  7011              STRB     r1,[r2,#0]
;;;250    
;;;251      /* Set the new HSE configuration -------------------------------------------*/
;;;252      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  4611              MOV      r1,r2
000008  7008              STRB     r0,[r1,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    
                          ENDP

                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;333      */
;;;334    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;335    {
;;;336      /* Check the parameters */
;;;337      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;338    
;;;339      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;340    }
000004  4770              BX       lr
;;;341    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1055     */
;;;1056   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1057   {
;;;1058     /* Check the parameters */
;;;1059     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1060   
;;;1061     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;1062   }
000004  4770              BX       lr
;;;1063   
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      0x4247015c

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1657     */
;;;1658   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L30.14|
;;;1659   {
;;;1660     /* Check the parameters */
;;;1661     assert_param(IS_RCC_IT(RCC_IT));
;;;1662     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1663     if (NewState != DISABLE)
;;;1664     {
;;;1665       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1666       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
000002  4a06              LDR      r2,|L30.28|
000004  7812              LDRB     r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L30.28|
00000a  701a              STRB     r2,[r3,#0]
00000c  e004              B        |L30.24|
                  |L30.14|
;;;1667     }
;;;1668     else
;;;1669     {
;;;1670       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1671       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
00000e  4a03              LDR      r2,|L30.28|
000010  7812              LDRB     r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L30.28|
000016  701a              STRB     r2,[r3,#0]
                  |L30.24|
;;;1672     }
;;;1673   }
000018  4770              BX       lr
;;;1674   
                          ENDP

00001a  0000              DCW      0x0000
                  |L30.28|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;358      */
;;;359    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  2100              MOVS     r1,#0
;;;360    {
;;;361      /* Check the parameters */
;;;362      assert_param(IS_RCC_LSE(RCC_LSE));
;;;363    
;;;364      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;365      /* Reset LSEON bit */
;;;366      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  4a09              LDR      r2,|L31.40|
000004  7011              STRB     r1,[r2,#0]
;;;367    
;;;368      /* Reset LSEBYP bit */
;;;369      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  7011              STRB     r1,[r2,#0]
;;;370    
;;;371      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;372      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L31.18|
00000c  2804              CMP      r0,#4
00000e  d108              BNE      |L31.34|
000010  e003              B        |L31.26|
                  |L31.18|
;;;373      {
;;;374        case RCC_LSE_ON:
;;;375          /* Set LSEON bit */
;;;376          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
000012  2101              MOVS     r1,#1
000014  4a04              LDR      r2,|L31.40|
000016  7011              STRB     r1,[r2,#0]
;;;377          break;
000018  e004              B        |L31.36|
                  |L31.26|
;;;378        case RCC_LSE_Bypass:
;;;379          /* Set LSEBYP and LSEON bits */
;;;380          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
00001a  2105              MOVS     r1,#5
00001c  4a02              LDR      r2,|L31.40|
00001e  7011              STRB     r1,[r2,#0]
;;;381          break;
000020  e000              B        |L31.36|
                  |L31.34|
;;;382        default:
;;;383          break;
000022  bf00              NOP      
                  |L31.36|
000024  bf00              NOP                            ;377
;;;384      }
;;;385    }
000026  4770              BX       lr
;;;386    
                          ENDP

                  |L31.40|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;398      */
;;;399    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;400    {
;;;401      /* Check the parameters */
;;;402      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;403    
;;;404      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;405    }
000004  4770              BX       lr
;;;406    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;550      */
;;;551    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4602              MOV      r2,r0
;;;552    {
;;;553      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;554      
;;;555      /* Check the parameters */
;;;556      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;557      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;558    
;;;559      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L33.24|
000006  6818              LDR      r0,[r3,#0]
;;;560    
;;;561      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;562      tmpreg &= CFGR_MCO1_RESET_MASK;
000008  f02060ec          BIC      r0,r0,#0x7600000
;;;563    
;;;564      /* Select MCO1 clock source and prescaler */
;;;565      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;566    
;;;567      /* Store the new value */
;;;568      RCC->CFGR = tmpreg;  
000012  4b01              LDR      r3,|L33.24|
000014  6018              STR      r0,[r3,#0]
;;;569    }
000016  4770              BX       lr
;;;570    
                          ENDP

                  |L33.24|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;588      */
;;;589    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4602              MOV      r2,r0
;;;590    {
;;;591      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;592      
;;;593      /* Check the parameters */
;;;594      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;595      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;596      
;;;597      tmpreg = RCC->CFGR;
000004  4b04              LDR      r3,|L34.24|
000006  6818              LDR      r0,[r3,#0]
;;;598      
;;;599      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;600      tmpreg &= CFGR_MCO2_RESET_MASK;
000008  f0204078          BIC      r0,r0,#0xf8000000
;;;601    
;;;602      /* Select MCO2 clock source and prescaler */
;;;603      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
00000c  ea420301          ORR      r3,r2,r1
000010  4318              ORRS     r0,r0,r3
;;;604    
;;;605      /* Store the new value */
;;;606      RCC->CFGR = tmpreg;  
000012  4b01              LDR      r3,|L34.24|
000014  6018              STR      r0,[r3,#0]
;;;607    }
000016  4770              BX       lr
;;;608    
                          ENDP

                  |L34.24|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;778      */
;;;779    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;780    {
;;;781      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;782    
;;;783      /* Check the parameters */
;;;784      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;785    
;;;786      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L35.20|
000006  6810              LDR      r0,[r2,#0]
;;;787    
;;;788      /* Clear PPRE1[2:0] bits */
;;;789      tmpreg &= ~RCC_CFGR_PPRE1;
000008  f42050e0          BIC      r0,r0,#0x1c00
;;;790    
;;;791      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;792      tmpreg |= RCC_HCLK;
00000c  4308              ORRS     r0,r0,r1
;;;793    
;;;794      /* Store the new value */
;;;795      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;796    }
000010  4770              BX       lr
;;;797    
                          ENDP

000012  0000              DCW      0x0000
                  |L35.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;809      */
;;;810    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4601              MOV      r1,r0
;;;811    {
;;;812      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;813    
;;;814      /* Check the parameters */
;;;815      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;816    
;;;817      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L36.20|
000006  6810              LDR      r0,[r2,#0]
;;;818    
;;;819      /* Clear PPRE2[2:0] bits */
;;;820      tmpreg &= ~RCC_CFGR_PPRE2;
000008  f4204060          BIC      r0,r0,#0xe000
;;;821    
;;;822      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;823      tmpreg |= RCC_HCLK << 3;
00000c  ea4000c1          ORR      r0,r0,r1,LSL #3
;;;824    
;;;825      /* Store the new value */
;;;826      RCC->CFGR = tmpreg;
000010  6010              STR      r0,[r2,#0]
;;;827    }
000012  4770              BX       lr
;;;828    
                          ENDP

                  |L36.20|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;464      */
;;;465    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L37.8|
;;;466    {
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;469      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;470    }
000004  4770              BX       lr
;;;471    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;441      */
;;;442    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  b570              PUSH     {r4-r6,lr}
;;;443    {
000002  9c04              LDR      r4,[sp,#0x10]
;;;444      /* Check the parameters */
;;;445      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;446      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;447      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;448      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;449      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;450    
;;;451      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  ea411582          ORR      r5,r1,r2,LSL #6
000008  2601              MOVS     r6,#1
00000a  ebc60653          RSB      r6,r6,r3,LSR #1
00000e  ea454506          ORR      r5,r5,r6,LSL #16
000012  4305              ORRS     r5,r5,r0
000014  ea456504          ORR      r5,r5,r4,LSL #24
000018  4e01              LDR      r6,|L38.32|
00001a  6035              STR      r5,[r6,#0]
;;;452                     (PLLQ << 24);
;;;453    }
00001c  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;507      */
;;;508    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;509    {
;;;510      /* Check the parameters */
;;;511      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;512      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;513    }
000004  4770              BX       lr
;;;514    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;491      */
;;;492    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0182              LSLS     r2,r0,#6
;;;493    {
;;;494      /* Check the parameters */
;;;495      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;496      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;497    
;;;498      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea427201          ORR      r2,r2,r1,LSL #28
000006  4b01              LDR      r3,|L40.12|
000008  601a              STR      r2,[r3,#0]
;;;499    }
00000a  4770              BX       lr
;;;500    
                          ENDP

                  |L40.12|
                          DCD      0x40023884

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1018     */
;;;1019   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;1020   {
;;;1021     /* Check the parameters */
;;;1022     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1023   
;;;1024     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1025   }
000004  4770              BX       lr
;;;1026   
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;986      */
;;;987    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  2100              MOVS     r1,#0
;;;988    {
;;;989      uint32_t tmpreg = 0;
;;;990    
;;;991      /* Check the parameters */
;;;992      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;993    
;;;994      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000002  f4007240          AND      r2,r0,#0x300
000006  f5b27f40          CMP      r2,#0x300
00000a  d108              BNE      |L42.30|
;;;995      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;996        tmpreg = RCC->CFGR;
00000c  4a09              LDR      r2,|L42.52|
00000e  6811              LDR      r1,[r2,#0]
;;;997    
;;;998        /* Clear RTCPRE[4:0] bits */
;;;999        tmpreg &= ~RCC_CFGR_RTCPRE;
000010  f42111f8          BIC      r1,r1,#0x1f0000
;;;1000   
;;;1001       /* Configure HSE division factor for RTC clock */
;;;1002       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000014  4a08              LDR      r2,|L42.56|
000016  4002              ANDS     r2,r2,r0
000018  4311              ORRS     r1,r1,r2
;;;1003   
;;;1004       /* Store the new value */
;;;1005       RCC->CFGR = tmpreg;
00001a  4a06              LDR      r2,|L42.52|
00001c  6011              STR      r1,[r2,#0]
                  |L42.30|
;;;1006     }
;;;1007       
;;;1008     /* Select the RTC clock source */
;;;1009     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
00001e  4a05              LDR      r2,|L42.52|
000020  3268              ADDS     r2,r2,#0x68
000022  6812              LDR      r2,[r2,#0]
000024  f3c0030b          UBFX     r3,r0,#0,#12
000028  431a              ORRS     r2,r2,r3
00002a  4b02              LDR      r3,|L42.52|
00002c  3368              ADDS     r3,r3,#0x68
00002e  601a              STR      r2,[r3,#0]
;;;1010   }
000030  4770              BX       lr
;;;1011   
                          ENDP

000032  0000              DCW      0x0000
                  |L42.52|
                          DCD      0x40023808
                  |L42.56|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;693      */
;;;694    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4601              MOV      r1,r0
;;;695    {
;;;696      uint32_t tmpreg = 0;
000002  2000              MOVS     r0,#0
;;;697    
;;;698      /* Check the parameters */
;;;699      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;700    
;;;701      tmpreg = RCC->CFGR;
000004  4a03              LDR      r2,|L43.20|
000006  6810              LDR      r0,[r2,#0]
;;;702    
;;;703      /* Clear SW[1:0] bits */
;;;704      tmpreg &= ~RCC_CFGR_SW;
000008  f0200003          BIC      r0,r0,#3
;;;705    
;;;706      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;707      tmpreg |= RCC_SYSCLKSource;
00000c  4308              ORRS     r0,r0,r1
;;;708    
;;;709      /* Store the new value */
;;;710      RCC->CFGR = tmpreg;
00000e  6010              STR      r0,[r2,#0]
;;;711    }
000010  4770              BX       lr
;;;712    
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;266      */
;;;267    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b538              PUSH     {r3-r5,lr}
;;;268    {
;;;269      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;270      ErrorStatus status = ERROR;
000006  2400              MOVS     r4,#0
;;;271      FlagStatus hsestatus = RESET;
000008  2500              MOVS     r5,#0
;;;272      /* Wait till HSE is ready and if Time out is reached exit */
;;;273      do
00000a  bf00              NOP      
                  |L44.12|
;;;274      {
;;;275        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
00000c  2031              MOVS     r0,#0x31
00000e  f7fffffe          BL       RCC_GetFlagStatus
000012  4605              MOV      r5,r0
;;;276        startupcounter++;
000014  9800              LDR      r0,[sp,#0]
000016  1c40              ADDS     r0,r0,#1
000018  9000              STR      r0,[sp,#0]
;;;277      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
00001a  9800              LDR      r0,[sp,#0]
00001c  f5b06fa0          CMP      r0,#0x500
000020  d001              BEQ      |L44.38|
000022  2d00              CMP      r5,#0
000024  d0f2              BEQ      |L44.12|
                  |L44.38|
;;;278    
;;;279      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000026  2031              MOVS     r0,#0x31
000028  f7fffffe          BL       RCC_GetFlagStatus
00002c  b108              CBZ      r0,|L44.50|
;;;280      {
;;;281        status = SUCCESS;
00002e  2401              MOVS     r4,#1
000030  e000              B        |L44.52|
                  |L44.50|
;;;282      }
;;;283      else
;;;284      {
;;;285        status = ERROR;
000032  2400              MOVS     r4,#0
                  |L44.52|
;;;286      }
;;;287      return (status);
000034  4620              MOV      r0,r4
;;;288    }
000036  bd38              POP      {r3-r5,pc}
;;;289    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rcc_c_49e27980____REV16|
#line 463 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_stm32f2xx_rcc_c_49e27980____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rcc_c_49e27980____REVSH|
#line 478
|__asm___15_stm32f2xx_rcc_c_49e27980____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f2xx_rcc_c_49e27980____RRX|
#line 665
|__asm___15_stm32f2xx_rcc_c_49e27980____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
