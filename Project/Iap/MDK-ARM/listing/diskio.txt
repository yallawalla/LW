; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\diskio.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\diskio.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\Inc -I..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Pfm6Ctrl\inc\app -I..\..\Pfm6Ctrl\src\wifi -I..\..\..\Utilities\FatFs_R0.09a -I.\RTE\_iap...PFM6 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -D__PFM6__ -DHSE_VALUE=25000000 -DWITH_COM_PORT --omf_browse=.\output\diskio.crf ..\..\..\Utilities\FatFs_R0.09a\diskio.c]
                          THUMB

                          AREA ||i.Defragment||, CODE, READONLY, ALIGN=2

                  Defragment PROC
;;;151    /*-----------------------------------------------------------------------*/
;;;152    void Defragment(BYTE drv) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  f5ad7d01          SUB      sp,sp,#0x204
000008  4681              MOV      r9,r0
;;;153    
;;;154    int i,f,e,*p,*q,buf[SECTOR_SIZE/4];
;;;155    	
;;;156    	f=FLASH_Sector_5;
00000a  2728              MOVS     r7,#0x28
;;;157    	e=ERASE_SIZE;
00000c  f44f3800          MOV      r8,#0x20000
;;;158    	p=(int *)STORAGE_TOP;
000010  4c26              LDR      r4,|L1.172|
;;;159    
;;;160    	do {
000012  bf00              NOP      
                  |L1.20|
;;;161    		do {
000014  bf00              NOP      
                  |L1.22|
;;;162    			q=&p[SECTOR_SIZE/4+1];
000016  f5047601          ADD      r6,r4,#0x204
;;;163    			while(p[SECTOR_SIZE/4] != q[SECTOR_SIZE/4] && q[SECTOR_SIZE/4] != -1)
00001a  e001              B        |L1.32|
                  |L1.28|
;;;164    				q=&q[SECTOR_SIZE/4+1];
00001c  f5067601          ADD      r6,r6,#0x204
                  |L1.32|
000020  f8d40200          LDR      r0,[r4,#0x200]        ;163
000024  f8d61200          LDR      r1,[r6,#0x200]        ;163
000028  4288              CMP      r0,r1                 ;163
00002a  d004              BEQ      |L1.54|
00002c  f8d60200          LDR      r0,[r6,#0x200]        ;163
000030  1c40              ADDS     r0,r0,#1              ;163
000032  2800              CMP      r0,#0                 ;163
000034  d1f2              BNE      |L1.28|
                  |L1.54|
;;;165    			if(q[SECTOR_SIZE/4] == -1) {
000036  f8d60200          LDR      r0,[r6,#0x200]
00003a  1c40              ADDS     r0,r0,#1
00003c  b998              CBNZ     r0,|L1.102|
;;;166    				for(i=0; i<SECTOR_SIZE/4;++i)
00003e  2500              MOVS     r5,#0
000040  e006              B        |L1.80|
                  |L1.66|
;;;167    					buf[i]=~p[i];
000042  f8540025          LDR      r0,[r4,r5,LSL #2]
000046  43c0              MVNS     r0,r0
000048  a901              ADD      r1,sp,#4
00004a  f8410025          STR      r0,[r1,r5,LSL #2]
00004e  1c6d              ADDS     r5,r5,#1              ;166
                  |L1.80|
000050  2d80              CMP      r5,#0x80              ;166
000052  dbf6              BLT      |L1.66|
;;;168    				Watchdog();
000054  f7fffffe          BL       Watchdog
;;;169    				disk_write (drv,(BYTE *)buf,p[SECTOR_SIZE/4],1);
000058  2301              MOVS     r3,#1
00005a  a901              ADD      r1,sp,#4
00005c  4648              MOV      r0,r9
00005e  f8d42200          LDR      r2,[r4,#0x200]
000062  f7fffffe          BL       disk_write
                  |L1.102|
;;;170    			}
;;;171    			p=&p[SECTOR_SIZE/4+1]; 
000066  f5047401          ADD      r4,r4,#0x204
;;;172    		} while(((int)p)-STORAGE_TOP <  e && p[SECTOR_SIZE/4] != -1);
00006a  4810              LDR      r0,|L1.172|
00006c  1a20              SUBS     r0,r4,r0
00006e  4540              CMP      r0,r8
000070  da04              BGE      |L1.124|
000072  f8d40200          LDR      r0,[r4,#0x200]
000076  1c40              ADDS     r0,r0,#1
000078  2800              CMP      r0,#0
00007a  d1cc              BNE      |L1.22|
                  |L1.124|
;;;173    		FLASH_EraseSector(f, VoltageRange_3);
00007c  2102              MOVS     r1,#2
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       FLASH_EraseSector
;;;174    		printf(".");
000084  a00a              ADR      r0,|L1.176|
000086  f7fffffe          BL       __2printf
;;;175    		f+=8; 
00008a  3708              ADDS     r7,r7,#8
;;;176    		e+=ERASE_SIZE;
00008c  f5083800          ADD      r8,r8,#0x20000
;;;177    	} while(p[SECTOR_SIZE/4] != -1);	
000090  f8d40200          LDR      r0,[r4,#0x200]
000094  1c40              ADDS     r0,r0,#1
000096  2800              CMP      r0,#0
000098  d1bc              BNE      |L1.20|
;;;178    	FLASH_EraseSector(f, VoltageRange_3);
00009a  2102              MOVS     r1,#2
00009c  4638              MOV      r0,r7
00009e  f7fffffe          BL       FLASH_EraseSector
;;;179    }
0000a2  f50d7d01          ADD      sp,sp,#0x204
0000a6  e8bd83f0          POP      {r4-r9,pc}
;;;180    #else
                          ENDP

0000aa  0000              DCW      0x0000
                  |L1.172|
                          DCD      0x08040000
                  |L1.176|
0000b0  2e00              DCB      ".",0
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.SectorQuery||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  SectorQuery PROC
;;;126    /*-----------------------------------------------------------------------*/
;;;127    void SectorQuery(void) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;128    int i,j,*p,*q;
;;;129    
;;;130    	p=(int *)STORAGE_TOP;
000004  4c26              LDR      r4,|L2.160|
;;;131    	for(i=0; i<SECTOR_COUNT; ++i) {
000006  2500              MOVS     r5,#0
000008  e044              B        |L2.148|
                  |L2.10|
;;;132    		if(!((i%255)%16))
00000a  21ff              MOVS     r1,#0xff
00000c  fb95f2f1          SDIV     r2,r5,r1
000010  fb015012          MLS      r0,r1,r2,r5
000014  17c1              ASRS     r1,r0,#31
000016  eb007111          ADD      r1,r0,r1,LSR #28
00001a  1109              ASRS     r1,r1,#4
00001c  eba01101          SUB      r1,r0,r1,LSL #4
000020  b911              CBNZ     r1,|L2.40|
;;;133    			printf("\r\n");
000022  a020              ADR      r0,|L2.164|
000024  f7fffffe          BL       __2printf
                  |L2.40|
;;;134    		if(!(i%255))
000028  20ff              MOVS     r0,#0xff
00002a  fb95f1f0          SDIV     r1,r5,r0
00002e  fb005011          MLS      r0,r0,r1,r5
000032  b910              CBNZ     r0,|L2.58|
;;;135    			printf("\r\n");		
000034  a01b              ADR      r0,|L2.164|
000036  f7fffffe          BL       __2printf
                  |L2.58|
;;;136    		if(p[SECTOR_SIZE/4] == -1)
00003a  f8d40200          LDR      r0,[r4,#0x200]
00003e  1c40              ADDS     r0,r0,#1
000040  b918              CBNZ     r0,|L2.74|
;;;137    			printf(" ---");
000042  a019              ADR      r0,|L2.168|
000044  f7fffffe          BL       __2printf
000048  e021              B        |L2.142|
                  |L2.74|
;;;138    		else {
;;;139    			q=&p[SECTOR_SIZE/4+1];
00004a  f5047701          ADD      r7,r4,#0x204
;;;140    			j=i;
00004e  462e              MOV      r6,r5
;;;141    			while(++j<SECTOR_COUNT && p[SECTOR_SIZE/4] != q[SECTOR_SIZE/4])
000050  e001              B        |L2.86|
                  |L2.82|
;;;142    				q=&q[SECTOR_SIZE/4+1];
000052  f5077701          ADD      r7,r7,#0x204
                  |L2.86|
000056  1c70              ADDS     r0,r6,#1              ;141
000058  4606              MOV      r6,r0                 ;141
00005a  f24041f6          MOV      r1,#0x4f6             ;141
00005e  4288              CMP      r0,r1                 ;141
000060  da05              BGE      |L2.110|
000062  f8d40200          LDR      r0,[r4,#0x200]        ;141
000066  f8d71200          LDR      r1,[r7,#0x200]        ;141
00006a  4288              CMP      r0,r1                 ;141
00006c  d1f1              BNE      |L2.82|
                  |L2.110|
;;;143    			if(j==SECTOR_COUNT)
00006e  f24040f6          MOV      r0,#0x4f6
000072  4286              CMP      r6,r0
000074  d105              BNE      |L2.130|
;;;144    				printf(" %-3d",p[SECTOR_SIZE/4]);
000076  a00e              ADR      r0,|L2.176|
000078  f8d41200          LDR      r1,[r4,#0x200]
00007c  f7fffffe          BL       __2printf
000080  e005              B        |L2.142|
                  |L2.130|
;;;145    			else
;;;146    				printf("%c%-3d",'*',p[SECTOR_SIZE/4]);
000082  212a              MOVS     r1,#0x2a
000084  a00c              ADR      r0,|L2.184|
000086  f8d42200          LDR      r2,[r4,#0x200]
00008a  f7fffffe          BL       __2printf
                  |L2.142|
;;;147    		}
;;;148    		p=&p[SECTOR_SIZE/4+1];
00008e  f5047401          ADD      r4,r4,#0x204
000092  1c6d              ADDS     r5,r5,#1              ;131
                  |L2.148|
000094  f24040f6          MOV      r0,#0x4f6             ;131
000098  4285              CMP      r5,r0                 ;131
00009a  dbb6              BLT      |L2.10|
;;;149    	}
;;;150    }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;151    /*-----------------------------------------------------------------------*/
                          ENDP

                  |L2.160|
                          DCD      0x08040000
                  |L2.164|
0000a4  0d0a00            DCB      "\r\n",0
0000a7  00                DCB      0
                  |L2.168|
0000a8  202d2d2d          DCB      " ---",0
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L2.176|
0000b0  20252d33          DCB      " %-3d",0
0000b4  6400    
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L2.184|
0000b8  2563252d          DCB      "%c%-3d",0
0000bc  336400  
0000bf  00                DCB      0

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;62     #ifndef WIN32
;;;63     DSTATUS disk_initialize (BYTE drv)
000000  b510              PUSH     {r4,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65     	FLASH_Unlock();
000004  f7fffffe          BL       FLASH_Unlock
;;;66     	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR | FLASH_FLAG_PGSERR);
000008  20f3              MOVS     r0,#0xf3
00000a  f7fffffe          BL       FLASH_ClearFlag
;;;67     	return RES_OK; 
00000e  2000              MOVS     r0,#0
;;;68     }
000010  bd10              POP      {r4,pc}
;;;69     /*-----------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;14     /* Miscellaneous Functions                                               */
;;;15     DRESULT disk_ioctl (
000000  4603              MOV      r3,r0
;;;16     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;17     	BYTE ctrl,			/* Control code */
;;;18     	void *buff			/* Buffer to send/receive control data */
;;;19     )
;;;20     {
;;;21     	switch(ctrl) {
000002  2917              CMP      r1,#0x17
000004  d226              BCS      |L4.84|
000006  e8dff001          TBB      [pc,r1]
00000a  0c11              DCB      0x0c,0x11
00000c  0d15191a          DCB      0x0d,0x15,0x19,0x1a
000010  1b1c2525          DCB      0x1b,0x1c,0x25,0x25
000014  1d1e1f20          DCB      0x1d,0x1e,0x1f,0x20
000018  21252525          DCB      0x21,0x25,0x25,0x25
00001c  25252223          DCB      0x25,0x25,0x22,0x23
000020  2400              DCB      0x24,0x00
;;;22     		case CTRL_SYNC:
;;;23     			break;
000022  e017              B        |L4.84|
;;;24     		case GET_SECTOR_SIZE:
;;;25     			*(int *)buff=SECTOR_SIZE;
000024  f44f7000          MOV      r0,#0x200
000028  6010              STR      r0,[r2,#0]
;;;26     			break;
00002a  e013              B        |L4.84|
;;;27     		case GET_SECTOR_COUNT:
;;;28     			*(int *)buff=SECTOR_COUNT;
00002c  f24040f6          MOV      r0,#0x4f6
000030  6010              STR      r0,[r2,#0]
;;;29     			break;
000032  e00f              B        |L4.84|
;;;30     		case GET_BLOCK_SIZE:
;;;31     			*(int *)buff=ERASE_SIZE;
000034  f44f3000          MOV      r0,#0x20000
000038  6010              STR      r0,[r2,#0]
;;;32     			break;
00003a  e00b              B        |L4.84|
;;;33     		case CTRL_ERASE_SECTOR:
;;;34     #if _USE_ERASE
;;;35     %error "define how to erase block... ???"
;;;36     #endif
;;;37     			break;
00003c  e00a              B        |L4.84|
;;;38     		case CTRL_POWER:
;;;39     		case CTRL_LOCK:
00003e  bf00              NOP      
;;;40     		case CTRL_EJECT:
000040  bf00              NOP      
;;;41     		case MMC_GET_TYPE:
000042  bf00              NOP      
;;;42     		case MMC_GET_CSD:
000044  bf00              NOP      
;;;43     		case MMC_GET_CID:
000046  bf00              NOP      
;;;44     		case MMC_GET_OCR:
000048  bf00              NOP      
;;;45     		case MMC_GET_SDSTAT:
00004a  bf00              NOP      
;;;46     		case ATA_GET_REV:
00004c  bf00              NOP      
;;;47     		case ATA_GET_MODEL:
00004e  bf00              NOP      
;;;48     		case ATA_GET_SN:
000050  bf00              NOP      
;;;49     			break;
000052  bf00              NOP      
                  |L4.84|
000054  bf00              NOP                            ;23
;;;50     	}
;;;51       	return RES_OK; 
000056  2000              MOVS     r0,#0
;;;52     }
000058  4770              BX       lr
;;;53     /*-----------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;72     //
;;;73     DRESULT disk_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;74     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;75     	BYTE *buff,			/* Data buffer to store read data */
;;;76     	DWORD sector,		/* Sector address (LBA) */
;;;77     	BYTE count			/* Number of sectors to read (1..255) */
;;;78     )
;;;79     {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;80     int i,*p,*q=NULL;
00000c  2500              MOVS     r5,#0
;;;81     	for(p=(int *)STORAGE_TOP; p[SECTOR_SIZE/4]!=-1; p=&p[SECTOR_SIZE/4+1])
00000e  4c15              LDR      r4,|L5.100|
000010  e006              B        |L5.32|
                  |L5.18|
;;;82     		if(p[SECTOR_SIZE/4] == sector)
000012  f8d40200          LDR      r0,[r4,#0x200]
000016  42b0              CMP      r0,r6
000018  d100              BNE      |L5.28|
;;;83     			q=p;
00001a  4625              MOV      r5,r4
                  |L5.28|
00001c  f5047401          ADD      r4,r4,#0x204          ;81
                  |L5.32|
000020  f8d40200          LDR      r0,[r4,#0x200]        ;81
000024  1c40              ADDS     r0,r0,#1              ;81
000026  2800              CMP      r0,#0                 ;81
000028  d1f3              BNE      |L5.18|
;;;84     	if(q)
00002a  b105              CBZ      r5,|L5.46|
;;;85     		p=q;
00002c  462c              MOV      r4,r5
                  |L5.46|
;;;86     	q=(int *)buff;
00002e  4645              MOV      r5,r8
;;;87     	for(i=0;i<SECTOR_SIZE/4; ++i)
000030  2700              MOVS     r7,#0
000032  e003              B        |L5.60|
                  |L5.52|
;;;88     		*q++=~(*p++);	
000034  cc02              LDM      r4!,{r1}
000036  43c8              MVNS     r0,r1
000038  c501              STM      r5!,{r0}
00003a  1c7f              ADDS     r7,r7,#1              ;87
                  |L5.60|
00003c  2f80              CMP      r7,#0x80              ;87
00003e  dbf9              BLT      |L5.52|
;;;89     	if(--count)
000040  f1a90001          SUB      r0,r9,#1
000044  b2c0              UXTB     r0,r0
000046  f1b00900          SUBS     r9,r0,#0
00004a  d007              BEQ      |L5.92|
;;;90     		disk_read (drv, (uint8_t *)q, ++sector, count);
00004c  1c70              ADDS     r0,r6,#1
00004e  4606              MOV      r6,r0
000050  4602              MOV      r2,r0
000052  464b              MOV      r3,r9
000054  4629              MOV      r1,r5
000056  4650              MOV      r0,r10
000058  f7fffffe          BL       disk_read
                  |L5.92|
;;;91     	return RES_OK; 
00005c  2000              MOVS     r0,#0
;;;92     }
00005e  e8bd87f0          POP      {r4-r10,pc}
;;;93     /*-----------------------------------------------------------------------*/
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
                          DCD      0x08040000

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;55     
;;;56     DSTATUS disk_status (BYTE drv) 
000000  4601              MOV      r1,r0
;;;57     {
;;;58       return RES_OK; 
000002  2000              MOVS     r0,#0
;;;59     }
000004  4770              BX       lr
;;;60     /*-----------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                  disk_write PROC
;;;97     #if _READONLY == 0
;;;98     DRESULT disk_write (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;99     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;100    	const BYTE *buff,	/* Data to be written */
;;;101    	DWORD sector,		/* Sector address (LBA) */
;;;102    	BYTE count			/* Number of sectors to write (1..255) */
;;;103    )
;;;104    {
000004  4682              MOV      r10,r0
000006  4688              MOV      r8,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;105    int i,*p,*q=NULL;
00000c  2600              MOVS     r6,#0
;;;106    	for(p=(int *)STORAGE_TOP; p[SECTOR_SIZE/4]!=-1; p=&p[SECTOR_SIZE/4+1])
00000e  4d1e              LDR      r5,|L7.136|
000010  e006              B        |L7.32|
                  |L7.18|
;;;107    		if(p[SECTOR_SIZE/4] == sector)
000012  f8d50200          LDR      r0,[r5,#0x200]
000016  42b8              CMP      r0,r7
000018  d100              BNE      |L7.28|
;;;108    			q=p;
00001a  462e              MOV      r6,r5
                  |L7.28|
00001c  f5057501          ADD      r5,r5,#0x204          ;106
                  |L7.32|
000020  f8d50200          LDR      r0,[r5,#0x200]        ;106
000024  1c40              ADDS     r0,r0,#1              ;106
000026  2800              CMP      r0,#0                 ;106
000028  d1f3              BNE      |L7.18|
;;;109    		
;;;110    	q=(int *)buff;
00002a  4646              MOV      r6,r8
;;;111    	for(i=0; i<SECTOR_SIZE/4; ++i)	
00002c  2400              MOVS     r4,#0
00002e  e003              B        |L7.56|
                  |L7.48|
;;;112    		if(*q++)
000030  ce02              LDM      r6!,{r1}
000032  b101              CBZ      r1,|L7.54|
;;;113    			break;
000034  e002              B        |L7.60|
                  |L7.54|
000036  1c64              ADDS     r4,r4,#1              ;111
                  |L7.56|
000038  2c80              CMP      r4,#0x80              ;111
00003a  dbf9              BLT      |L7.48|
                  |L7.60|
00003c  bf00              NOP      
;;;114    
;;;115    	if(i<SECTOR_SIZE/4) {												// all zeroes ???
00003e  2c80              CMP      r4,#0x80
000040  da10              BGE      |L7.100|
;;;116    		q=(int *)buff;
000042  4646              MOV      r6,r8
;;;117    		for(i=0; i<SECTOR_SIZE/4; ++i,++p,++q)
000044  2400              MOVS     r4,#0
000046  e007              B        |L7.88|
                  |L7.72|
;;;118    			FlashProgram32((int)p,~(*q));
000048  6830              LDR      r0,[r6,#0]
00004a  43c1              MVNS     r1,r0
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       FlashProgram32
000052  1c64              ADDS     r4,r4,#1              ;117
000054  1d2d              ADDS     r5,r5,#4              ;117
000056  1d36              ADDS     r6,r6,#4              ;117
                  |L7.88|
000058  2c80              CMP      r4,#0x80              ;117
00005a  dbf5              BLT      |L7.72|
;;;119    		FlashProgram32((int)p,sector);
00005c  4639              MOV      r1,r7
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       FlashProgram32
                  |L7.100|
;;;120    	}
;;;121    	if(--count)
000064  f1a90001          SUB      r0,r9,#1
000068  b2c0              UXTB     r0,r0
00006a  f1b00900          SUBS     r9,r0,#0
00006e  d007              BEQ      |L7.128|
;;;122    		disk_write (drv, (uint8_t *)q, ++sector, count);
000070  1c78              ADDS     r0,r7,#1
000072  4607              MOV      r7,r0
000074  4602              MOV      r2,r0
000076  464b              MOV      r3,r9
000078  4631              MOV      r1,r6
00007a  4650              MOV      r0,r10
00007c  f7fffffe          BL       disk_write
                  |L7.128|
;;;123    	return RES_OK; 
000080  2000              MOVS     r0,#0
;;;124    }	  
000082  e8bd87f0          POP      {r4-r10,pc}
;;;125    #endif /* _READONLY */
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x08040000

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;236    /*-----------------------------------------------------------------------*/
;;;237    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;238    {
;;;239    	return 0;
;;;240    }
000002  4770              BX       lr
;;;241    
                          ENDP


                          AREA ||i.time||, CODE, READONLY, ALIGN=1

                  time PROC
;;;242    #ifndef WIN32
;;;243    time_t time(time_t *t) {
000000  4601              MOV      r1,r0
;;;244    	return *t;
000002  6808              LDR      r0,[r1,#0]
;;;245    }
000004  4770              BX       lr
;;;246    #endif
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Utilities\\FatFs_R0.09a\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_2f51d95c____REV16|
#line 463 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___8_diskio_c_2f51d95c____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_2f51d95c____REVSH|
#line 478
|__asm___8_diskio_c_2f51d95c____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_2f51d95c____RRX|
#line 665
|__asm___8_diskio_c_2f51d95c____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
