; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\stm32f2xx_flash.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\stm32f2xx_flash.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\Inc -I..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Pfm6Ctrl\inc\app -I..\..\Pfm6Ctrl\src\wifi -I..\..\..\Utilities\FatFs_R0.09a -I.\RTE\_iap...PFM6 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -D__PFM6__ -DHSE_VALUE=25000000 -DWITH_COM_PORT --omf_browse=.\output\stm32f2xx_flash.crf ..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash.c]
                          THUMB

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;967      */
;;;968    void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4901              LDR      r1,|L1.8|
;;;969    {
;;;970      /* Check the parameters */
;;;971      assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
;;;972      
;;;973      /* Clear the flags */
;;;974      FLASH->SR = FLASH_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;975    }
000004  4770              BX       lr
;;;976    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_DataCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheCmd PROC
;;;227      */
;;;228    void FLASH_DataCacheCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L2.16|
;;;229    {
;;;230      /* Check the parameters */
;;;231      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;232      
;;;233      if(NewState != DISABLE)
;;;234      {
;;;235        FLASH->ACR |= FLASH_ACR_DCEN;
000002  4907              LDR      r1,|L2.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4416180          ORR      r1,r1,#0x400
00000a  4a05              LDR      r2,|L2.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L2.28|
                  |L2.16|
;;;236      }
;;;237      else
;;;238      {
;;;239        FLASH->ACR &= (~FLASH_ACR_DCEN);
000010  4903              LDR      r1,|L2.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4216180          BIC      r1,r1,#0x400
000018  4a01              LDR      r2,|L2.32|
00001a  6011              STR      r1,[r2,#0]
                  |L2.28|
;;;240      }
;;;241    }
00001c  4770              BX       lr
;;;242    
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_DataCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_DataCacheReset PROC
;;;259      */
;;;260    void FLASH_DataCacheReset(void)
000000  4803              LDR      r0,|L3.16|
;;;261    {
;;;262      FLASH->ACR |= FLASH_ACR_DCRST;
000002  6800              LDR      r0,[r0,#0]
000004  f4405080          ORR      r0,r0,#0x1000
000008  4901              LDR      r1,|L3.16|
00000a  6008              STR      r0,[r1,#0]
;;;263    }
00000c  4770              BX       lr
;;;264    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40023c00

                          AREA ||i.FLASH_EraseAllSectors||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllSectors PROC
;;;409      */
;;;410    FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
000000  b530              PUSH     {r4,r5,lr}
;;;411    {
000002  4602              MOV      r2,r0
;;;412      uint32_t tmp_psize = 0x0;
000004  2500              MOVS     r5,#0
;;;413      FLASH_Status status = FLASH_COMPLETE;
000006  2408              MOVS     r4,#8
;;;414      
;;;415      /* Wait for last operation to be completed */
;;;416      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4604              MOV      r4,r0
;;;417      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;418      
;;;419      if(VoltageRange == VoltageRange_1)
00000e  b902              CBNZ     r2,|L4.18|
;;;420      {
;;;421         tmp_psize = FLASH_PSIZE_BYTE;
000010  e009              B        |L4.38|
                  |L4.18|
;;;422      }
;;;423      else if(VoltageRange == VoltageRange_2)
000012  2a01              CMP      r2,#1
000014  d101              BNE      |L4.26|
;;;424      {
;;;425        tmp_psize = FLASH_PSIZE_HALF_WORD;
000016  0215              LSLS     r5,r2,#8
000018  e005              B        |L4.38|
                  |L4.26|
;;;426      }
;;;427      else if(VoltageRange == VoltageRange_3)
00001a  2a02              CMP      r2,#2
00001c  d101              BNE      |L4.34|
;;;428      {
;;;429        tmp_psize = FLASH_PSIZE_WORD;
00001e  0215              LSLS     r5,r2,#8
000020  e001              B        |L4.38|
                  |L4.34|
;;;430      }
;;;431      else
;;;432      {
;;;433        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
000022  f44f7540          MOV      r5,#0x300
                  |L4.38|
;;;434      }  
;;;435      if(status == FLASH_COMPLETE)
000026  2c08              CMP      r4,#8
000028  d11c              BNE      |L4.100|
;;;436      {
;;;437        /* if the previous operation is completed, proceed to erase all sectors */
;;;438         FLASH->CR &= CR_PSIZE_MASK;
00002a  480f              LDR      r0,|L4.104|
00002c  6800              LDR      r0,[r0,#0]
00002e  f4207040          BIC      r0,r0,#0x300
000032  490d              LDR      r1,|L4.104|
000034  6008              STR      r0,[r1,#0]
;;;439         FLASH->CR |= tmp_psize;
000036  4608              MOV      r0,r1
000038  6800              LDR      r0,[r0,#0]
00003a  4328              ORRS     r0,r0,r5
00003c  6008              STR      r0,[r1,#0]
;;;440         FLASH->CR |= FLASH_CR_MER;
00003e  4608              MOV      r0,r1
000040  6800              LDR      r0,[r0,#0]
000042  f0400004          ORR      r0,r0,#4
000046  6008              STR      r0,[r1,#0]
;;;441         FLASH->CR |= FLASH_CR_STRT;
000048  4608              MOV      r0,r1
00004a  6800              LDR      r0,[r0,#0]
00004c  f4403080          ORR      r0,r0,#0x10000
000050  6008              STR      r0,[r1,#0]
;;;442        
;;;443        /* Wait for last operation to be completed */
;;;444        status = FLASH_WaitForLastOperation();
000052  f7fffffe          BL       FLASH_WaitForLastOperation
000056  4604              MOV      r4,r0
;;;445    
;;;446        /* if the erase operation is completed, disable the MER Bit */
;;;447        FLASH->CR &= (~FLASH_CR_MER);
000058  4803              LDR      r0,|L4.104|
00005a  6800              LDR      r0,[r0,#0]
00005c  f0200004          BIC      r0,r0,#4
000060  4901              LDR      r1,|L4.104|
000062  6008              STR      r0,[r1,#0]
                  |L4.100|
;;;448    
;;;449      }   
;;;450      /* Return the Erase Status */
;;;451      return status;
000064  4620              MOV      r0,r4
;;;452    }
000066  bd30              POP      {r4,r5,pc}
;;;453    
                          ENDP

                  |L4.104|
                          DCD      0x40023c10

                          AREA ||i.FLASH_EraseSector||, CODE, READONLY, ALIGN=2

                  FLASH_EraseSector PROC
;;;344      */
;;;345    FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
000000  b570              PUSH     {r4-r6,lr}
;;;346    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;347      uint32_t tmp_psize = 0x0;
000006  2600              MOVS     r6,#0
;;;348      FLASH_Status status = FLASH_COMPLETE;
000008  2508              MOVS     r5,#8
;;;349    
;;;350      /* Check the parameters */
;;;351      assert_param(IS_FLASH_SECTOR(FLASH_Sector));
;;;352      assert_param(IS_VOLTAGERANGE(VoltageRange));
;;;353      
;;;354      if(VoltageRange == VoltageRange_1)
00000a  b902              CBNZ     r2,|L5.14|
;;;355      {
;;;356         tmp_psize = FLASH_PSIZE_BYTE;
00000c  e009              B        |L5.34|
                  |L5.14|
;;;357      }
;;;358      else if(VoltageRange == VoltageRange_2)
00000e  2a01              CMP      r2,#1
000010  d101              BNE      |L5.22|
;;;359      {
;;;360        tmp_psize = FLASH_PSIZE_HALF_WORD;
000012  0216              LSLS     r6,r2,#8
000014  e005              B        |L5.34|
                  |L5.22|
;;;361      }
;;;362      else if(VoltageRange == VoltageRange_3)
000016  2a02              CMP      r2,#2
000018  d101              BNE      |L5.30|
;;;363      {
;;;364        tmp_psize = FLASH_PSIZE_WORD;
00001a  0216              LSLS     r6,r2,#8
00001c  e001              B        |L5.34|
                  |L5.30|
;;;365      }
;;;366      else
;;;367      {
;;;368        tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
00001e  f44f7640          MOV      r6,#0x300
                  |L5.34|
;;;369      }
;;;370      /* Wait for last operation to be completed */
;;;371      status = FLASH_WaitForLastOperation();
000022  f7fffffe          BL       FLASH_WaitForLastOperation
000026  4605              MOV      r5,r0
;;;372      
;;;373      if(status == FLASH_COMPLETE)
000028  2d08              CMP      r5,#8
00002a  d128              BNE      |L5.126|
;;;374      { 
;;;375        /* if the previous operation is completed, proceed to erase the sector */
;;;376        FLASH->CR &= CR_PSIZE_MASK;
00002c  4815              LDR      r0,|L5.132|
00002e  6800              LDR      r0,[r0,#0]
000030  f4207040          BIC      r0,r0,#0x300
000034  4913              LDR      r1,|L5.132|
000036  6008              STR      r0,[r1,#0]
;;;377        FLASH->CR |= tmp_psize;
000038  4608              MOV      r0,r1
00003a  6800              LDR      r0,[r0,#0]
00003c  4330              ORRS     r0,r0,r6
00003e  6008              STR      r0,[r1,#0]
;;;378        FLASH->CR &= SECTOR_MASK;
000040  4608              MOV      r0,r1
000042  6800              LDR      r0,[r0,#0]
000044  f02000f8          BIC      r0,r0,#0xf8
000048  6008              STR      r0,[r1,#0]
;;;379        FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
00004a  4608              MOV      r0,r1
00004c  6800              LDR      r0,[r0,#0]
00004e  f0440102          ORR      r1,r4,#2
000052  4308              ORRS     r0,r0,r1
000054  490b              LDR      r1,|L5.132|
000056  6008              STR      r0,[r1,#0]
;;;380        FLASH->CR |= FLASH_CR_STRT;
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f4403080          ORR      r0,r0,#0x10000
000060  6008              STR      r0,[r1,#0]
;;;381        
;;;382        /* Wait for last operation to be completed */
;;;383        status = FLASH_WaitForLastOperation();
000062  f7fffffe          BL       FLASH_WaitForLastOperation
000066  4605              MOV      r5,r0
;;;384        
;;;385        /* if the erase operation is completed, disable the SER Bit */
;;;386        FLASH->CR &= (~FLASH_CR_SER);
000068  4806              LDR      r0,|L5.132|
00006a  6800              LDR      r0,[r0,#0]
00006c  f0200002          BIC      r0,r0,#2
000070  4904              LDR      r1,|L5.132|
000072  6008              STR      r0,[r1,#0]
;;;387        FLASH->CR &= SECTOR_MASK; 
000074  4608              MOV      r0,r1
000076  6800              LDR      r0,[r0,#0]
000078  f02000f8          BIC      r0,r0,#0xf8
00007c  6008              STR      r0,[r1,#0]
                  |L5.126|
;;;388      }
;;;389      /* Return the Erase Status */
;;;390      return status;
00007e  4628              MOV      r0,r5
;;;391    }
000080  bd70              POP      {r4-r6,pc}
;;;392    
                          ENDP

000082  0000              DCW      0x0000
                  |L5.132|
                          DCD      0x40023c10

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;937      */
;;;938    FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;939    {
;;;940      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;941      /* Check the parameters */
;;;942      assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
;;;943    
;;;944      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
000004  4a03              LDR      r2,|L6.20|
000006  6812              LDR      r2,[r2,#0]
000008  400a              ANDS     r2,r2,r1
00000a  b10a              CBZ      r2,|L6.16|
;;;945      {
;;;946        bitstatus = SET;
00000c  2001              MOVS     r0,#1
00000e  e000              B        |L6.18|
                  |L6.16|
;;;947      }
;;;948      else
;;;949      {
;;;950        bitstatus = RESET;
000010  2000              MOVS     r0,#0
                  |L6.18|
;;;951      }
;;;952      /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;953      return bitstatus; 
;;;954    }
000012  4770              BX       lr
;;;955    
                          ENDP

                  |L6.20|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;982      */
;;;983    FLASH_Status FLASH_GetStatus(void)
000000  2008              MOVS     r0,#8
;;;984    {
;;;985      FLASH_Status flashstatus = FLASH_COMPLETE;
;;;986      
;;;987      if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000002  4910              LDR      r1,|L7.68|
000004  6809              LDR      r1,[r1,#0]
000006  f4013180          AND      r1,r1,#0x10000
00000a  f5b13f80          CMP      r1,#0x10000
00000e  d101              BNE      |L7.20|
;;;988      {
;;;989        flashstatus = FLASH_BUSY;
000010  2001              MOVS     r0,#1
000012  e015              B        |L7.64|
                  |L7.20|
;;;990      }
;;;991      else 
;;;992      {  
;;;993        if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
000014  490b              LDR      r1,|L7.68|
000016  6809              LDR      r1,[r1,#0]
000018  f0010110          AND      r1,r1,#0x10
00001c  b109              CBZ      r1,|L7.34|
;;;994        { 
;;;995          flashstatus = FLASH_ERROR_WRP;
00001e  2005              MOVS     r0,#5
000020  e00e              B        |L7.64|
                  |L7.34|
;;;996        }
;;;997        else 
;;;998        {
;;;999          if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
000022  4908              LDR      r1,|L7.68|
000024  6809              LDR      r1,[r1,#0]
000026  f00101ef          AND      r1,r1,#0xef
00002a  b109              CBZ      r1,|L7.48|
;;;1000         {
;;;1001           flashstatus = FLASH_ERROR_PROGRAM; 
00002c  2006              MOVS     r0,#6
00002e  e007              B        |L7.64|
                  |L7.48|
;;;1002         }
;;;1003         else
;;;1004         {
;;;1005           if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
000030  4904              LDR      r1,|L7.68|
000032  6809              LDR      r1,[r1,#0]
000034  f0010102          AND      r1,r1,#2
000038  b109              CBZ      r1,|L7.62|
;;;1006           {
;;;1007             flashstatus = FLASH_ERROR_OPERATION;
00003a  2007              MOVS     r0,#7
00003c  e000              B        |L7.64|
                  |L7.62|
;;;1008           }
;;;1009           else
;;;1010           {
;;;1011             flashstatus = FLASH_COMPLETE;
00003e  2008              MOVS     r0,#8
                  |L7.64|
;;;1012           }
;;;1013         }
;;;1014       }
;;;1015     }
;;;1016     /* Return the FLASH Status */
;;;1017     return flashstatus;
;;;1018   }
000040  4770              BX       lr
;;;1019   
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x40023c0c

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;906      */
;;;907    void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L8.14|
;;;908    {
;;;909      /* Check the parameters */
;;;910      assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;911      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;912    
;;;913      if(NewState != DISABLE)
;;;914      {
;;;915        /* Enable the interrupt sources */
;;;916        FLASH->CR |= FLASH_IT;
000002  4a06              LDR      r2,|L8.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L8.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L8.24|
                  |L8.14|
;;;917      }
;;;918      else
;;;919      {
;;;920        /* Disable the interrupt sources */
;;;921        FLASH->CR &= ~(uint32_t)FLASH_IT;
00000e  4a03              LDR      r2,|L8.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L8.28|
000016  601a              STR      r2,[r3,#0]
                  |L8.24|
;;;922      }
;;;923    }
000018  4770              BX       lr
;;;924    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40023c10

                          AREA ||i.FLASH_InstructionCacheCmd||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheCmd PROC
;;;206      */
;;;207    void FLASH_InstructionCacheCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L9.16|
;;;208    {
;;;209      /* Check the parameters */
;;;210      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;211      
;;;212      if(NewState != DISABLE)
;;;213      {
;;;214        FLASH->ACR |= FLASH_ACR_ICEN;
000002  4907              LDR      r1,|L9.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4417100          ORR      r1,r1,#0x200
00000a  4a05              LDR      r2,|L9.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L9.28|
                  |L9.16|
;;;215      }
;;;216      else
;;;217      {
;;;218        FLASH->ACR &= (~FLASH_ACR_ICEN);
000010  4903              LDR      r1,|L9.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4217100          BIC      r1,r1,#0x200
000018  4a01              LDR      r2,|L9.32|
00001a  6011              STR      r1,[r2,#0]
                  |L9.28|
;;;219      }
;;;220    }
00001c  4770              BX       lr
;;;221    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_InstructionCacheReset||, CODE, READONLY, ALIGN=2

                  FLASH_InstructionCacheReset PROC
;;;248      */
;;;249    void FLASH_InstructionCacheReset(void)
000000  4803              LDR      r0,|L10.16|
;;;250    {
;;;251      FLASH->ACR |= FLASH_ACR_ICRST;
000002  6800              LDR      r0,[r0,#0]
000004  f4406000          ORR      r0,r0,#0x800
000008  4901              LDR      r1,|L10.16|
00000a  6008              STR      r0,[r1,#0]
;;;252    }
00000c  4770              BX       lr
;;;253    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;318      */
;;;319    void FLASH_Lock(void)
000000  4803              LDR      r0,|L11.16|
;;;320    {
;;;321      /* Set the LOCK Bit to lock the FLASH Registers access */
;;;322      FLASH->CR |= FLASH_CR_LOCK;
000002  6800              LDR      r0,[r0,#0]
000004  f0404000          ORR      r0,r0,#0x80000000
000008  4901              LDR      r1,|L11.16|
00000a  6008              STR      r0,[r1,#0]
;;;323    }
00000c  4770              BX       lr
;;;324    
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      0x40023c10

                          AREA ||i.FLASH_OB_BORConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_BORConfig PROC
;;;792      */
;;;793    void FLASH_OB_BORConfig(uint8_t OB_BOR)
000000  4905              LDR      r1,|L12.24|
;;;794    {
;;;795      /* Check the parameters */
;;;796      assert_param(IS_OB_BOR(OB_BOR));
;;;797    
;;;798      /* Set the BOR Level */
;;;799      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
000002  7809              LDRB     r1,[r1,#0]
000004  f021010c          BIC      r1,r1,#0xc
000008  4a03              LDR      r2,|L12.24|
00000a  7011              STRB     r1,[r2,#0]
;;;800      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
00000c  4611              MOV      r1,r2
00000e  7809              LDRB     r1,[r1,#0]
000010  4301              ORRS     r1,r1,r0
000012  7011              STRB     r1,[r2,#0]
;;;801    
;;;802    }
000014  4770              BX       lr
;;;803    
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetBOR||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetBOR PROC
;;;876      */
;;;877    uint8_t FLASH_OB_GetBOR(void)
000000  4802              LDR      r0,|L13.12|
;;;878    {
;;;879      /* Return the FLASH BOR level */
;;;880      return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
000002  7800              LDRB     r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;881    }
000008  4770              BX       lr
;;;882    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;852      */
;;;853    FlagStatus FLASH_OB_GetRDP(void)
000000  2000              MOVS     r0,#0
;;;854    {
;;;855      FlagStatus readstatus = RESET;
;;;856    
;;;857      if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
000002  4904              LDR      r1,|L14.20|
000004  7809              LDRB     r1,[r1,#0]
000006  29aa              CMP      r1,#0xaa
000008  d001              BEQ      |L14.14|
;;;858      {
;;;859        readstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L14.16|
                  |L14.14|
;;;860      }
;;;861      else
;;;862      {
;;;863        readstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L14.16|
;;;864      }
;;;865      return readstatus;
;;;866    }
000010  4770              BX       lr
;;;867    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;828      */
;;;829    uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L15.12|
;;;830    {
;;;831      /* Return the User Option Byte */
;;;832      return (uint8_t)(FLASH->OPTCR >> 5);
000002  6800              LDR      r0,[r0,#0]
000004  f3c01047          UBFX     r0,r0,#5,#8
;;;833    }
000008  4770              BX       lr
;;;834    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;839      */
;;;840    uint16_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L16.8|
;;;841    {
;;;842      /* Return the FLASH write protection Register value */
;;;843      return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
000002  8800              LDRH     r0,[r0,#0]
;;;844    }
000004  4770              BX       lr
;;;845    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x40023c16

                          AREA ||i.FLASH_OB_Launch||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Launch PROC
;;;809      */
;;;810    FLASH_Status FLASH_OB_Launch(void)
000000  b500              PUSH     {lr}
;;;811    {
;;;812      FLASH_Status status = FLASH_COMPLETE;
000002  2208              MOVS     r2,#8
;;;813    
;;;814      /* Set the OPTSTRT bit in OPTCR register */
;;;815      *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
000004  4805              LDR      r0,|L17.28|
000006  7800              LDRB     r0,[r0,#0]
000008  f0400002          ORR      r0,r0,#2
00000c  4903              LDR      r1,|L17.28|
00000e  7008              STRB     r0,[r1,#0]
;;;816    
;;;817      /* Wait for last operation to be completed */
;;;818      status = FLASH_WaitForLastOperation();
000010  f7fffffe          BL       FLASH_WaitForLastOperation
000014  4602              MOV      r2,r0
;;;819    
;;;820      return status;
000016  4610              MOV      r0,r2
;;;821    }
000018  bd00              POP      {pc}
;;;822    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Lock PROC
;;;676      */
;;;677    void FLASH_OB_Lock(void)
000000  4803              LDR      r0,|L18.16|
;;;678    {
;;;679      /* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
;;;680      FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
000002  6800              LDR      r0,[r0,#0]
000004  f0400001          ORR      r0,r0,#1
000008  4901              LDR      r1,|L18.16|
00000a  6008              STR      r0,[r1,#0]
;;;681    }
00000c  4770              BX       lr
;;;682    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_RDPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDPConfig PROC
;;;727      */
;;;728    void FLASH_OB_RDPConfig(uint8_t OB_RDP)
000000  b510              PUSH     {r4,lr}
;;;729    {
000002  4602              MOV      r2,r0
;;;730      FLASH_Status status = FLASH_COMPLETE;
000004  2408              MOVS     r4,#8
;;;731    
;;;732      /* Check the parameters */
;;;733      assert_param(IS_OB_RDP(OB_RDP));
;;;734    
;;;735      status = FLASH_WaitForLastOperation();
000006  f7fffffe          BL       FLASH_WaitForLastOperation
00000a  4604              MOV      r4,r0
;;;736    
;;;737      if(status == FLASH_COMPLETE)
00000c  2c08              CMP      r4,#8
00000e  d101              BNE      |L19.20|
;;;738      {
;;;739        *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
000010  4801              LDR      r0,|L19.24|
000012  7002              STRB     r2,[r0,#0]
                  |L19.20|
;;;740    
;;;741      }
;;;742    }
000014  bd10              POP      {r4,pc}
;;;743    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40023c15

                          AREA ||i.FLASH_OB_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_OB_Unlock PROC
;;;661      */
;;;662    void FLASH_OB_Unlock(void)
000000  4805              LDR      r0,|L20.24|
;;;663    {
;;;664      if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0000001          AND      r0,r0,#1
000008  b128              CBZ      r0,|L20.22|
;;;665      {
;;;666        /* Authorizes the Option Byte register programming */
;;;667        FLASH->OPTKEYR = FLASH_OPT_KEY1;
00000a  4804              LDR      r0,|L20.28|
00000c  4902              LDR      r1,|L20.24|
00000e  390c              SUBS     r1,r1,#0xc
000010  6008              STR      r0,[r1,#0]
;;;668        FLASH->OPTKEYR = FLASH_OPT_KEY2;
000012  4803              LDR      r0,|L20.32|
000014  6008              STR      r0,[r1,#0]
                  |L20.22|
;;;669      }  
;;;670    }
000016  4770              BX       lr
;;;671    
                          ENDP

                  |L20.24|
                          DCD      0x40023c14
                  |L20.28|
                          DCD      0x08192a3b
                  |L20.32|
                          DCD      0x4c5d6e7f

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;759      */
;;;760    void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
000000  b5f0              PUSH     {r4-r7,lr}
;;;761    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;762      uint8_t optiontmp = 0xFF;
000006  26ff              MOVS     r6,#0xff
;;;763      FLASH_Status status = FLASH_COMPLETE; 
000008  2708              MOVS     r7,#8
;;;764    
;;;765      /* Check the parameters */
;;;766      assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;767      assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;768      assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;769    
;;;770      /* Wait for last operation to be completed */
;;;771      status = FLASH_WaitForLastOperation();
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4607              MOV      r7,r0
;;;772      
;;;773      if(status == FLASH_COMPLETE)
000010  2f08              CMP      r7,#8
000012  d109              BNE      |L21.40|
;;;774      { 
;;;775        /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
;;;776        optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
000014  4805              LDR      r0,|L21.44|
000016  7800              LDRB     r0,[r0,#0]
000018  f000060f          AND      r6,r0,#0xf
;;;777    
;;;778        /* Update User Option Byte */
;;;779        *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
00001c  ea450006          ORR      r0,r5,r6
000020  4310              ORRS     r0,r0,r2
000022  4320              ORRS     r0,r0,r4
000024  4901              LDR      r1,|L21.44|
000026  7008              STRB     r0,[r1,#0]
                  |L21.40|
;;;780      }  
;;;781    }
000028  bdf0              POP      {r4-r7,pc}
;;;782    
                          ENDP

00002a  0000              DCW      0x0000
                  |L21.44|
                          DCD      0x40023c14

                          AREA ||i.FLASH_OB_WRPConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_WRPConfig PROC
;;;692      */
;;;693    void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;694    { 
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;695      FLASH_Status status = FLASH_COMPLETE;
000006  2508              MOVS     r5,#8
;;;696      
;;;697      /* Check the parameters */
;;;698      assert_param(IS_OB_WRP(OB_WRP));
;;;699      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;700        
;;;701      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;702    
;;;703      if(status == FLASH_COMPLETE)
00000e  2d08              CMP      r5,#8
000010  d10c              BNE      |L22.44|
;;;704      { 
;;;705        if(NewState != DISABLE)
000012  b12c              CBZ      r4,|L22.32|
;;;706        {
;;;707          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
000014  4806              LDR      r0,|L22.48|
000016  8800              LDRH     r0,[r0,#0]
000018  4390              BICS     r0,r0,r2
00001a  4905              LDR      r1,|L22.48|
00001c  8008              STRH     r0,[r1,#0]
00001e  e005              B        |L22.44|
                  |L22.32|
;;;708        }
;;;709        else
;;;710        {
;;;711          *(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
000020  4803              LDR      r0,|L22.48|
000022  8800              LDRH     r0,[r0,#0]
000024  b291              UXTH     r1,r2
000026  4308              ORRS     r0,r0,r1
000028  4901              LDR      r1,|L22.48|
00002a  8008              STRH     r0,[r1,#0]
                  |L22.44|
;;;712        }
;;;713      }
;;;714    }
00002c  bd30              POP      {r4,r5,pc}
;;;715    
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0x40023c16

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;184      */
;;;185    void FLASH_PrefetchBufferCmd(FunctionalState NewState)
000000  b130              CBZ      r0,|L23.16|
;;;186    {
;;;187      /* Check the parameters */
;;;188      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;189      
;;;190      /* Enable or disable the Prefetch Buffer */
;;;191      if(NewState != DISABLE)
;;;192      {
;;;193        FLASH->ACR |= FLASH_ACR_PRFTEN;
000002  4907              LDR      r1,|L23.32|
000004  6809              LDR      r1,[r1,#0]
000006  f4417180          ORR      r1,r1,#0x100
00000a  4a05              LDR      r2,|L23.32|
00000c  6011              STR      r1,[r2,#0]
00000e  e005              B        |L23.28|
                  |L23.16|
;;;194      }
;;;195      else
;;;196      {
;;;197        FLASH->ACR &= (~FLASH_ACR_PRFTEN);
000010  4903              LDR      r1,|L23.32|
000012  6809              LDR      r1,[r1,#0]
000014  f4217180          BIC      r1,r1,#0x100
000018  4a01              LDR      r2,|L23.32|
00001a  6011              STR      r1,[r2,#0]
                  |L23.28|
;;;198      }
;;;199    }
00001c  4770              BX       lr
;;;200    
                          ENDP

00001e  0000              DCW      0x0000
                  |L23.32|
                          DCD      0x40023c00

                          AREA ||i.FLASH_ProgramByte||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramByte PROC
;;;576      */
;;;577    FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;578    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;579      FLASH_Status status = FLASH_COMPLETE;
000006  2508              MOVS     r5,#8
;;;580    
;;;581      /* Check the parameters */
;;;582      assert_param(IS_FLASH_ADDRESS(Address));
;;;583    
;;;584      /* Wait for last operation to be completed */
;;;585      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;586      
;;;587      if(status == FLASH_COMPLETE)
00000e  2d08              CMP      r5,#8
000010  d117              BNE      |L24.66|
;;;588      {
;;;589        /* if the previous operation is completed, proceed to program the new data */
;;;590        FLASH->CR &= CR_PSIZE_MASK;
000012  480d              LDR      r0,|L24.72|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490b              LDR      r1,|L24.72|
00001c  6008              STR      r0,[r1,#0]
;;;591        FLASH->CR |= FLASH_PSIZE_BYTE;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  6008              STR      r0,[r1,#0]
;;;592        FLASH->CR |= FLASH_CR_PG;
000024  4608              MOV      r0,r1
000026  6800              LDR      r0,[r0,#0]
000028  f0400001          ORR      r0,r0,#1
00002c  6008              STR      r0,[r1,#0]
;;;593      
;;;594        *(__IO uint8_t*)Address = Data;
00002e  7014              STRB     r4,[r2,#0]
;;;595            
;;;596        /* Wait for last operation to be completed */
;;;597        status = FLASH_WaitForLastOperation();
000030  f7fffffe          BL       FLASH_WaitForLastOperation
000034  4605              MOV      r5,r0
;;;598    
;;;599        /* if the program operation is completed, disable the PG Bit */
;;;600        FLASH->CR &= (~FLASH_CR_PG);
000036  4804              LDR      r0,|L24.72|
000038  6800              LDR      r0,[r0,#0]
00003a  f0200001          BIC      r0,r0,#1
00003e  4902              LDR      r1,|L24.72|
000040  6008              STR      r0,[r1,#0]
                  |L24.66|
;;;601      } 
;;;602    
;;;603      /* Return the Program Status */
;;;604      return status;
000042  4628              MOV      r0,r5
;;;605    }
000044  bd30              POP      {r4,r5,pc}
;;;606    
                          ENDP

000046  0000              DCW      0x0000
                  |L24.72|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramDoubleWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramDoubleWord PROC
;;;462      */
;;;463    FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
000000  b570              PUSH     {r4-r6,lr}
;;;464    {
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  461d              MOV      r5,r3
;;;465      FLASH_Status status = FLASH_COMPLETE;
000008  2208              MOVS     r2,#8
;;;466    
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FLASH_ADDRESS(Address));
;;;469    
;;;470      /* Wait for last operation to be completed */
;;;471      status = FLASH_WaitForLastOperation();
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
00000e  4602              MOV      r2,r0
;;;472      
;;;473      if(status == FLASH_COMPLETE)
000010  2a08              CMP      r2,#8
000012  d11a              BNE      |L25.74|
;;;474      {
;;;475        /* if the previous operation is completed, proceed to program the new data */
;;;476        FLASH->CR &= CR_PSIZE_MASK;
000014  480e              LDR      r0,|L25.80|
000016  6800              LDR      r0,[r0,#0]
000018  f4207040          BIC      r0,r0,#0x300
00001c  490c              LDR      r1,|L25.80|
00001e  6008              STR      r0,[r1,#0]
;;;477        FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
000020  4608              MOV      r0,r1
000022  6800              LDR      r0,[r0,#0]
000024  f4407040          ORR      r0,r0,#0x300
000028  6008              STR      r0,[r1,#0]
;;;478        FLASH->CR |= FLASH_CR_PG;
00002a  4608              MOV      r0,r1
00002c  6800              LDR      r0,[r0,#0]
00002e  f0400001          ORR      r0,r0,#1
000032  6008              STR      r0,[r1,#0]
;;;479      
;;;480        *(__IO uint64_t*)Address = Data;
000034  6034              STR      r4,[r6,#0]
000036  6075              STR      r5,[r6,#4]
;;;481            
;;;482        /* Wait for last operation to be completed */
;;;483        status = FLASH_WaitForLastOperation();
000038  f7fffffe          BL       FLASH_WaitForLastOperation
00003c  4602              MOV      r2,r0
;;;484    
;;;485        /* if the program operation is completed, disable the PG Bit */
;;;486        FLASH->CR &= (~FLASH_CR_PG);
00003e  4804              LDR      r0,|L25.80|
000040  6800              LDR      r0,[r0,#0]
000042  f0200001          BIC      r0,r0,#1
000046  4902              LDR      r1,|L25.80|
000048  6008              STR      r0,[r1,#0]
                  |L25.74|
;;;487      } 
;;;488      /* Return the Program Status */
;;;489      return status;
00004a  4610              MOV      r0,r2
;;;490    }
00004c  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP

00004e  0000              DCW      0x0000
                  |L25.80|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;538      */
;;;539    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;540    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;541      FLASH_Status status = FLASH_COMPLETE;
000006  2508              MOVS     r5,#8
;;;542    
;;;543      /* Check the parameters */
;;;544      assert_param(IS_FLASH_ADDRESS(Address));
;;;545    
;;;546      /* Wait for last operation to be completed */
;;;547      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;548      
;;;549      if(status == FLASH_COMPLETE)
00000e  2d08              CMP      r5,#8
000010  d119              BNE      |L26.70|
;;;550      {
;;;551        /* if the previous operation is completed, proceed to program the new data */
;;;552        FLASH->CR &= CR_PSIZE_MASK;
000012  480e              LDR      r0,|L26.76|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490c              LDR      r1,|L26.76|
00001c  6008              STR      r0,[r1,#0]
;;;553        FLASH->CR |= FLASH_PSIZE_HALF_WORD;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  f4407080          ORR      r0,r0,#0x100
000026  6008              STR      r0,[r1,#0]
;;;554        FLASH->CR |= FLASH_CR_PG;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6008              STR      r0,[r1,#0]
;;;555      
;;;556        *(__IO uint16_t*)Address = Data;
000032  8014              STRH     r4,[r2,#0]
;;;557            
;;;558        /* Wait for last operation to be completed */
;;;559        status = FLASH_WaitForLastOperation();
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;560    
;;;561        /* if the program operation is completed, disable the PG Bit */
;;;562        FLASH->CR &= (~FLASH_CR_PG);
00003a  4804              LDR      r0,|L26.76|
00003c  6800              LDR      r0,[r0,#0]
00003e  f0200001          BIC      r0,r0,#1
000042  4902              LDR      r1,|L26.76|
000044  6008              STR      r0,[r1,#0]
                  |L26.70|
;;;563      } 
;;;564      /* Return the Program Status */
;;;565      return status;
000046  4628              MOV      r0,r5
;;;566    }
000048  bd30              POP      {r4,r5,pc}
;;;567    
                          ENDP

00004a  0000              DCW      0x0000
                  |L26.76|
                          DCD      0x40023c10

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;500      */
;;;501    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  b530              PUSH     {r4,r5,lr}
;;;502    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;503      FLASH_Status status = FLASH_COMPLETE;
000006  2508              MOVS     r5,#8
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_FLASH_ADDRESS(Address));
;;;507    
;;;508      /* Wait for last operation to be completed */
;;;509      status = FLASH_WaitForLastOperation();
000008  f7fffffe          BL       FLASH_WaitForLastOperation
00000c  4605              MOV      r5,r0
;;;510      
;;;511      if(status == FLASH_COMPLETE)
00000e  2d08              CMP      r5,#8
000010  d119              BNE      |L27.70|
;;;512      {
;;;513        /* if the previous operation is completed, proceed to program the new data */
;;;514        FLASH->CR &= CR_PSIZE_MASK;
000012  480e              LDR      r0,|L27.76|
000014  6800              LDR      r0,[r0,#0]
000016  f4207040          BIC      r0,r0,#0x300
00001a  490c              LDR      r1,|L27.76|
00001c  6008              STR      r0,[r1,#0]
;;;515        FLASH->CR |= FLASH_PSIZE_WORD;
00001e  4608              MOV      r0,r1
000020  6800              LDR      r0,[r0,#0]
000022  f4407000          ORR      r0,r0,#0x200
000026  6008              STR      r0,[r1,#0]
;;;516        FLASH->CR |= FLASH_CR_PG;
000028  4608              MOV      r0,r1
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400001          ORR      r0,r0,#1
000030  6008              STR      r0,[r1,#0]
;;;517      
;;;518        *(__IO uint32_t*)Address = Data;
000032  6014              STR      r4,[r2,#0]
;;;519            
;;;520        /* Wait for last operation to be completed */
;;;521        status = FLASH_WaitForLastOperation();
000034  f7fffffe          BL       FLASH_WaitForLastOperation
000038  4605              MOV      r5,r0
;;;522    
;;;523        /* if the program operation is completed, disable the PG Bit */
;;;524        FLASH->CR &= (~FLASH_CR_PG);
00003a  4804              LDR      r0,|L27.76|
00003c  6800              LDR      r0,[r0,#0]
00003e  f0200001          BIC      r0,r0,#1
000042  4902              LDR      r1,|L27.76|
000044  6008              STR      r0,[r1,#0]
                  |L27.70|
;;;525      } 
;;;526      /* Return the Program Status */
;;;527      return status;
000046  4628              MOV      r0,r5
;;;528    }
000048  bd30              POP      {r4,r5,pc}
;;;529    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      0x40023c10

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;169      */
;;;170    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a01              LDR      r2,|L28.8|
;;;171    {
;;;172      /* Check the parameters */
;;;173      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;174      
;;;175      /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
;;;176      *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
000002  7010              STRB     r0,[r2,#0]
;;;177    }
000004  4770              BX       lr
;;;178    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x40023c00

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;303      */
;;;304    void FLASH_Unlock(void)
000000  4805              LDR      r0,|L29.24|
;;;305    {
;;;306      if((FLASH->CR & FLASH_CR_LOCK) != RESET)
000002  6800              LDR      r0,[r0,#0]
000004  f0004000          AND      r0,r0,#0x80000000
000008  b128              CBZ      r0,|L29.22|
;;;307      {
;;;308        /* Authorize the FLASH Registers access */
;;;309        FLASH->KEYR = FLASH_KEY1;
00000a  4804              LDR      r0,|L29.28|
00000c  4902              LDR      r1,|L29.24|
00000e  390c              SUBS     r1,r1,#0xc
000010  6008              STR      r0,[r1,#0]
;;;310        FLASH->KEYR = FLASH_KEY2;
000012  4803              LDR      r0,|L29.32|
000014  6008              STR      r0,[r1,#0]
                  |L29.22|
;;;311      }  
;;;312    }
000016  4770              BX       lr
;;;313    
                          ENDP

                  |L29.24|
                          DCD      0x40023c10
                  |L29.28|
                          DCD      0x45670123
                  |L29.32|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1025     */
;;;1026   FLASH_Status FLASH_WaitForLastOperation(void)
000000  b508              PUSH     {r3,lr}
;;;1027   { 
;;;1028     __IO FLASH_Status status = FLASH_COMPLETE;
000002  2008              MOVS     r0,#8
000004  9000              STR      r0,[sp,#0]
;;;1029      
;;;1030     /* Check for the FLASH Status */
;;;1031     status = FLASH_GetStatus();
000006  f7fffffe          BL       FLASH_GetStatus
00000a  9000              STR      r0,[sp,#0]
;;;1032   
;;;1033     /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
;;;1034        Even if the FLASH operation fails, the BUSY flag will be reset and an error
;;;1035        flag will be set */
;;;1036     while(status == FLASH_BUSY)
00000c  e002              B        |L30.20|
                  |L30.14|
;;;1037     {
;;;1038       status = FLASH_GetStatus();
00000e  f7fffffe          BL       FLASH_GetStatus
000012  9000              STR      r0,[sp,#0]
                  |L30.20|
000014  f89d0000          LDRB     r0,[sp,#0]            ;1036
000018  2801              CMP      r0,#1                 ;1036
00001a  d0f8              BEQ      |L30.14|
;;;1039     }
;;;1040     /* Return the operation status */
;;;1041     return status;
00001c  f89d0000          LDRB     r0,[sp,#0]
;;;1042   }
000020  bd08              POP      {r3,pc}
;;;1043   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32F2xx_StdPeriph_Driver\\src\\stm32f2xx_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f2xx_flash_c_a2a150d6____REV16|
#line 463 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.4.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_stm32f2xx_flash_c_a2a150d6____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f2xx_flash_c_a2a150d6____REVSH|
#line 478
|__asm___17_stm32f2xx_flash_c_a2a150d6____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f2xx_flash_c_a2a150d6____RRX|
#line 665
|__asm___17_stm32f2xx_flash_c_a2a150d6____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
