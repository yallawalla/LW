; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\output\ff.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\output\ff.d --cpu=Cortex-M4 --apcs=interwork -O0 --diag_suppress=9931 -I..\ -I..\Inc -I..\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include -I..\..\Pfm6Ctrl\inc\app -I..\..\Pfm6Ctrl\src\wifi -I..\..\..\Utilities\FatFs_R0.09a -I.\RTE\_iap...PFM6 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.4.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F405xx -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -D__PFM6__ -DHSE_VALUE=25000000 -DWITH_COM_PORT --omf_browse=.\output\ff.crf ..\..\..\Utilities\FatFs_R0.09a\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2018   static
;;;2019   BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;2020   	FATFS *fs,	/* File system object */
;;;2021   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2022   )
;;;2023   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2024   	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
000006  7860              LDRB     r0,[r4,#1]
000008  2301              MOVS     r3,#1
00000a  462a              MOV      r2,r5
00000c  f1040128          ADD      r1,r4,#0x28
000010  f7fffffe          BL       disk_read
000014  b108              CBZ      r0,|L1.26|
;;;2025   		return 3;
000016  2003              MOVS     r0,#3
                  |L1.24|
;;;2026   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
;;;2027   		return 2;
;;;2028   
;;;2029   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2030   		return 0;
;;;2031   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
;;;2032   		return 0;
;;;2033   
;;;2034   	return 1;
;;;2035   }
000018  bd70              POP      {r4-r6,pc}
                  |L1.26|
00001a  f8941226          LDRB     r1,[r4,#0x226]        ;2026
00001e  f8940227          LDRB     r0,[r4,#0x227]        ;2026
000022  ea412000          ORR      r0,r1,r0,LSL #8       ;2026
000026  f64a2155          MOV      r1,#0xaa55            ;2026
00002a  4288              CMP      r0,r1                 ;2026
00002c  d001              BEQ      |L1.50|
00002e  2002              MOVS     r0,#2                 ;2027
000030  e7f2              B        |L1.24|
                  |L1.50|
000032  f8940061          LDRB     r0,[r4,#0x61]         ;2029
000036  0601              LSLS     r1,r0,#24             ;2029
000038  f8940060          LDRB     r0,[r4,#0x60]         ;2029
00003c  ea414100          ORR      r1,r1,r0,LSL #16      ;2029
000040  f894005f          LDRB     r0,[r4,#0x5f]         ;2029
000044  ea412000          ORR      r0,r1,r0,LSL #8       ;2029
000048  f894105e          LDRB     r1,[r4,#0x5e]         ;2029
00004c  4308              ORRS     r0,r0,r1              ;2029
00004e  f020407f          BIC      r0,r0,#0xff000000     ;2029
000052  490e              LDR      r1,|L1.140|
000054  4288              CMP      r0,r1                 ;2029
000056  d101              BNE      |L1.92|
000058  2000              MOVS     r0,#0                 ;2030
00005a  e7dd              B        |L1.24|
                  |L1.92|
00005c  f894007d          LDRB     r0,[r4,#0x7d]         ;2031
000060  0601              LSLS     r1,r0,#24             ;2031
000062  f894007c          LDRB     r0,[r4,#0x7c]         ;2031
000066  ea414100          ORR      r1,r1,r0,LSL #16      ;2031
00006a  f894007b          LDRB     r0,[r4,#0x7b]         ;2031
00006e  ea412000          ORR      r0,r1,r0,LSL #8       ;2031
000072  f894107a          LDRB     r1,[r4,#0x7a]         ;2031
000076  4308              ORRS     r0,r0,r1              ;2031
000078  f020407f          BIC      r0,r0,#0xff000000     ;2031
00007c  4903              LDR      r1,|L1.140|
00007e  4288              CMP      r0,r1                 ;2031
000080  d101              BNE      |L1.134|
000082  2000              MOVS     r0,#0                 ;2032
000084  e7c8              B        |L1.24|
                  |L1.134|
000086  2001              MOVS     r0,#1                 ;2034
000088  e7c6              B        |L1.24|
;;;2036   
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      0x00544146

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;566    static
;;;567    int chk_chr (const char* str, int chr) {
000000  4602              MOV      r2,r0
;;;568    	while (*str && *str != chr) str++;
000002  e000              B        |L2.6|
                  |L2.4|
000004  1c52              ADDS     r2,r2,#1
                  |L2.6|
000006  7810              LDRB     r0,[r2,#0]
000008  b110              CBZ      r0,|L2.16|
00000a  7810              LDRB     r0,[r2,#0]
00000c  4288              CMP      r0,r1
00000e  d1f9              BNE      |L2.4|
                  |L2.16|
;;;569    	return *str;
000010  7810              LDRB     r0,[r2,#0]
;;;570    }
000012  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||i.chk_mounted||, CODE, READONLY, ALIGN=2

                  chk_mounted PROC
;;;2044   static
;;;2045   FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;2046   	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
;;;2047   	FATFS **rfs,		/* Pointer to pointer to the found file system object */
;;;2048   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2049   )
;;;2050   {
000004  b088              SUB      sp,sp,#0x20
;;;2051   	BYTE fmt, b, pi, *tbl;
;;;2052   	UINT vol;
;;;2053   	DSTATUS stat;
;;;2054   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;;;2055   	WORD nrsv;
;;;2056   	const TCHAR *p = *path;
000006  9808              LDR      r0,[sp,#0x20]
000008  6800              LDR      r0,[r0,#0]
00000a  9001              STR      r0,[sp,#4]
;;;2057   	FATFS *fs;
;;;2058   
;;;2059   
;;;2060   										/* Get logical drive number from the path name */
;;;2061   	vol = p[0] - '0';					/* Is there a drive number? */
00000c  9801              LDR      r0,[sp,#4]
00000e  7800              LDRB     r0,[r0,#0]
000010  f1a00b30          SUB      r11,r0,#0x30
;;;2062   	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
000014  f1bb0f09          CMP      r11,#9
000018  d80a              BHI      |L3.48|
00001a  9801              LDR      r0,[sp,#4]
00001c  7840              LDRB     r0,[r0,#1]
00001e  283a              CMP      r0,#0x3a
000020  d106              BNE      |L3.48|
;;;2063   		p += 2; *path = p;				/* Return pointer to the path name */
000022  9801              LDR      r0,[sp,#4]
000024  1c80              ADDS     r0,r0,#2
000026  9001              STR      r0,[sp,#4]
000028  9908              LDR      r1,[sp,#0x20]
00002a  9801              LDR      r0,[sp,#4]
00002c  6008              STR      r0,[r1,#0]
00002e  e002              B        |L3.54|
                  |L3.48|
;;;2064   	} else {							/* No drive number is given */
;;;2065   #if _FS_RPATH
;;;2066   		vol = CurrVol;					/* Use current drive */
000030  489f              LDR      r0,|L3.688|
000032  f890b000          LDRB     r11,[r0,#0]  ; CurrVol
                  |L3.54|
;;;2067   #else
;;;2068   		vol = 0;						/* Use drive 0 */
;;;2069   #endif
;;;2070   	}
;;;2071   
;;;2072   	/* Check if the file system object is valid or not */
;;;2073   	*rfs = 0;
000036  2100              MOVS     r1,#0
000038  9809              LDR      r0,[sp,#0x24]
00003a  6001              STR      r1,[r0,#0]
;;;2074   	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
00003c  f1bb0f02          CMP      r11,#2
000040  d303              BCC      |L3.74|
;;;2075   		return FR_INVALID_DRIVE;
000042  200b              MOVS     r0,#0xb
                  |L3.68|
;;;2076   	fs = FatFs[vol];					/* Get corresponding file system object */
;;;2077   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2078   
;;;2079   	ENTER_FF(fs);						/* Lock file system */
;;;2080   
;;;2081   	*rfs = fs;							/* Return pointer to the corresponding file system object */
;;;2082   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2083   		stat = disk_status(fs->drv);
;;;2084   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
;;;2085   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2086   				return FR_WRITE_PROTECTED;
;;;2087   			return FR_OK;				/* The file system object is valid */
;;;2088   		}
;;;2089   	}
;;;2090   
;;;2091   	/* The file system object is not valid. */
;;;2092   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2093   
;;;2094   	fs->fs_type = 0;					/* Clear the file system object */
;;;2095   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2096   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2097   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2098   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2099   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2100   		return FR_WRITE_PROTECTED;
;;;2101   #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
;;;2102   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
;;;2103   		return FR_DISK_ERR;
;;;2104   #endif
;;;2105   	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
;;;2106   	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
;;;2107   	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
;;;2108   	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
;;;2109   		/* Check the partition listed in the partition table */
;;;2110   		pi = LD2PT(vol);
;;;2111   		if (pi) pi--;
;;;2112   		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
;;;2113   		if (tbl[4]) {						/* Is the partition existing? */
;;;2114   			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
;;;2115   			fmt = check_fs(fs, bsect);		/* Check the partition */
;;;2116   		}
;;;2117   	}
;;;2118   	if (fmt == 3) return FR_DISK_ERR;
;;;2119   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2120   
;;;2121   	/* An FAT volume is found. Following code initializes the file system object */
;;;2122   
;;;2123   	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2124   		return FR_NO_FILESYSTEM;
;;;2125   
;;;2126   	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;2127   	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;;;2128   	fs->fsize = fasize;
;;;2129   
;;;2130   	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
;;;2131   	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
;;;2132   	fasize *= b;										/* Number of sectors for FAT area */
;;;2133   
;;;2134   	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
;;;2135   	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;2136   
;;;2137   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;;;2138   	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
;;;2139   
;;;2140   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;;;2141   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;2142   
;;;2143   	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;;;2144   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
;;;2145   
;;;2146   	/* Determine the FAT sub type */
;;;2147   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;;;2148   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2149   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2150   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2151   	fmt = FS_FAT12;
;;;2152   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2153   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2154   
;;;2155   	/* Boundaries and Limits */
;;;2156   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2157   	fs->database = bsect + sysect;						/* Data start sector */
;;;2158   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2159   	if (fmt == FS_FAT32) {
;;;2160   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2161   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;2162   		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
;;;2163   	} else {
;;;2164   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2165   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2166   		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
;;;2167   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2168   	}
;;;2169   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
;;;2170   		return FR_NO_FILESYSTEM;
;;;2171   
;;;2172   #if !_FS_READONLY
;;;2173   	/* Initialize cluster allocation information */
;;;2174   	fs->free_clust = 0xFFFFFFFF;
;;;2175   	fs->last_clust = 0;
;;;2176   
;;;2177   	/* Get fsinfo if available */
;;;2178   	if (fmt == FS_FAT32) {
;;;2179   	 	fs->fsi_flag = 0;
;;;2180   		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
;;;2181   		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
;;;2182   			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
;;;2183   			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
;;;2184   			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
;;;2185   				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;2186   				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;2187   		}
;;;2188   	}
;;;2189   #endif
;;;2190   	fs->fs_type = fmt;		/* FAT sub-type */
;;;2191   	fs->id = ++Fsid;		/* File system mount ID */
;;;2192   	fs->winsect = 0;		/* Invalidate sector cache */
;;;2193   	fs->wflag = 0;
;;;2194   #if _FS_RPATH
;;;2195   	fs->cdir = 0;			/* Current directory (root dir) */
;;;2196   #endif
;;;2197   #if _FS_LOCK				/* Clear file lock semaphores */
;;;2198   	clear_lock(fs);
;;;2199   #endif
;;;2200   
;;;2201   	return FR_OK;
;;;2202   }
000044  b00b              ADD      sp,sp,#0x2c
000046  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.74|
00004a  489a              LDR      r0,|L3.692|
00004c  f850402b          LDR      r4,[r0,r11,LSL #2]    ;2076
000050  b90c              CBNZ     r4,|L3.86|
000052  200c              MOVS     r0,#0xc               ;2077
000054  e7f6              B        |L3.68|
                  |L3.86|
000056  9809              LDR      r0,[sp,#0x24]         ;2081
000058  6004              STR      r4,[r0,#0]            ;2081
00005a  7820              LDRB     r0,[r4,#0]            ;2082
00005c  b150              CBZ      r0,|L3.116|
00005e  7860              LDRB     r0,[r4,#1]            ;2083
000060  f7fffffe          BL       disk_status
000064  9007              STR      r0,[sp,#0x1c]         ;2083
000066  9807              LDR      r0,[sp,#0x1c]         ;2084
000068  f0000001          AND      r0,r0,#1              ;2084
00006c  b910              CBNZ     r0,|L3.116|
00006e  bf00              NOP                            ;2085
000070  2000              MOVS     r0,#0                 ;2087
000072  e7e7              B        |L3.68|
                  |L3.116|
000074  2000              MOVS     r0,#0                 ;2094
000076  7020              STRB     r0,[r4,#0]            ;2094
000078  f884b001          STRB     r11,[r4,#1]           ;2095
00007c  7860              LDRB     r0,[r4,#1]            ;2096
00007e  f7fffffe          BL       disk_initialize
000082  9007              STR      r0,[sp,#0x1c]         ;2096
000084  9807              LDR      r0,[sp,#0x1c]         ;2097
000086  f0000001          AND      r0,r0,#1              ;2097
00008a  b108              CBZ      r0,|L3.144|
00008c  2003              MOVS     r0,#3                 ;2098
00008e  e7d9              B        |L3.68|
                  |L3.144|
000090  bf00              NOP                            ;2099
000092  2000              MOVS     r0,#0                 ;2106
000094  4601              MOV      r1,r0                 ;2106
000096  9006              STR      r0,[sp,#0x18]         ;2106
000098  4620              MOV      r0,r4                 ;2106
00009a  f7fffffe          BL       check_fs
00009e  4605              MOV      r5,r0                 ;2106
0000a0  bf00              NOP                            ;2107
0000a2  2d01              CMP      r5,#1                 ;2108
0000a4  d121              BNE      |L3.234|
0000a6  f04f0900          MOV      r9,#0                 ;2110
0000aa  f1b90f00          CMP      r9,#0                 ;2111
0000ae  d003              BEQ      |L3.184|
0000b0  f1a90001          SUB      r0,r9,#1              ;2111
0000b4  f00009ff          AND      r9,r0,#0xff           ;2111
                  |L3.184|
0000b8  f44f70df          MOV      r0,#0x1be             ;2112
0000bc  eb001109          ADD      r1,r0,r9,LSL #4       ;2112
0000c0  f1040028          ADD      r0,r4,#0x28           ;2112
0000c4  180f              ADDS     r7,r1,r0              ;2112
0000c6  7938              LDRB     r0,[r7,#4]            ;2113
0000c8  b178              CBZ      r0,|L3.234|
0000ca  7af8              LDRB     r0,[r7,#0xb]          ;2114
0000cc  0601              LSLS     r1,r0,#24             ;2114
0000ce  7ab8              LDRB     r0,[r7,#0xa]          ;2114
0000d0  ea414100          ORR      r1,r1,r0,LSL #16      ;2114
0000d4  7a78              LDRB     r0,[r7,#9]            ;2114
0000d6  ea412000          ORR      r0,r1,r0,LSL #8       ;2114
0000da  7a39              LDRB     r1,[r7,#8]            ;2114
0000dc  4308              ORRS     r0,r0,r1              ;2114
0000de  9006              STR      r0,[sp,#0x18]         ;2114
0000e0  4620              MOV      r0,r4                 ;2115
0000e2  9906              LDR      r1,[sp,#0x18]         ;2115
0000e4  f7fffffe          BL       check_fs
0000e8  4605              MOV      r5,r0                 ;2115
                  |L3.234|
0000ea  2d03              CMP      r5,#3                 ;2118
0000ec  d101              BNE      |L3.242|
0000ee  2001              MOVS     r0,#1                 ;2118
0000f0  e7a8              B        |L3.68|
                  |L3.242|
0000f2  b10d              CBZ      r5,|L3.248|
0000f4  200d              MOVS     r0,#0xd               ;2119
0000f6  e7a5              B        |L3.68|
                  |L3.248|
0000f8  2033              MOVS     r0,#0x33              ;2123
0000fa  5d01              LDRB     r1,[r0,r4]            ;2123
0000fc  f8940034          LDRB     r0,[r4,#0x34]         ;2123
000100  ea412000          ORR      r0,r1,r0,LSL #8       ;2123
000104  f5b07f00          CMP      r0,#0x200             ;2123
000108  d001              BEQ      |L3.270|
00010a  200d              MOVS     r0,#0xd               ;2124
00010c  e79a              B        |L3.68|
                  |L3.270|
00010e  203e              MOVS     r0,#0x3e              ;2126
000110  5d01              LDRB     r1,[r0,r4]            ;2126
000112  f894003f          LDRB     r0,[r4,#0x3f]         ;2126
000116  ea412800          ORR      r8,r1,r0,LSL #8       ;2126
00011a  f1b80f00          CMP      r8,#0                 ;2127
00011e  d10e              BNE      |L3.318|
000120  f894004f          LDRB     r0,[r4,#0x4f]         ;2127
000124  0601              LSLS     r1,r0,#24             ;2127
000126  f894004e          LDRB     r0,[r4,#0x4e]         ;2127
00012a  ea414100          ORR      r1,r1,r0,LSL #16      ;2127
00012e  f894004d          LDRB     r0,[r4,#0x4d]         ;2127
000132  ea412000          ORR      r0,r1,r0,LSL #8       ;2127
000136  f894104c          LDRB     r1,[r4,#0x4c]         ;2127
00013a  ea400801          ORR      r8,r0,r1              ;2127
                  |L3.318|
00013e  f8c48014          STR      r8,[r4,#0x14]         ;2128
000142  2038              MOVS     r0,#0x38              ;2130
000144  5d06              LDRB     r6,[r0,r4]            ;2130
000146  70e6              STRB     r6,[r4,#3]            ;2130
000148  2e01              CMP      r6,#1                 ;2131
00014a  d003              BEQ      |L3.340|
00014c  2e02              CMP      r6,#2                 ;2131
00014e  d001              BEQ      |L3.340|
000150  200d              MOVS     r0,#0xd               ;2131
000152  e777              B        |L3.68|
                  |L3.340|
000154  fb08f806          MUL      r8,r8,r6              ;2132
000158  2035              MOVS     r0,#0x35              ;2134
00015a  5d00              LDRB     r0,[r0,r4]            ;2134
00015c  4606              MOV      r6,r0                 ;2134
00015e  70a0              STRB     r0,[r4,#2]            ;2134
000160  b116              CBZ      r6,|L3.360|
000162  1e70              SUBS     r0,r6,#1              ;2135
000164  4030              ANDS     r0,r0,r6              ;2135
000166  b108              CBZ      r0,|L3.364|
                  |L3.360|
000168  200d              MOVS     r0,#0xd               ;2135
00016a  e76b              B        |L3.68|
                  |L3.364|
00016c  2039              MOVS     r0,#0x39              ;2137
00016e  5d01              LDRB     r1,[r0,r4]            ;2137
000170  f894003a          LDRB     r0,[r4,#0x3a]         ;2137
000174  ea412000          ORR      r0,r1,r0,LSL #8       ;2137
000178  8120              STRH     r0,[r4,#8]            ;2137
00017a  7a20              LDRB     r0,[r4,#8]            ;2138
00017c  f000000f          AND      r0,r0,#0xf            ;2138
000180  b108              CBZ      r0,|L3.390|
000182  200d              MOVS     r0,#0xd               ;2138
000184  e75e              B        |L3.68|
                  |L3.390|
000186  203b              MOVS     r0,#0x3b              ;2140
000188  5d01              LDRB     r1,[r0,r4]            ;2140
00018a  f894003c          LDRB     r0,[r4,#0x3c]         ;2140
00018e  ea412000          ORR      r0,r1,r0,LSL #8       ;2140
000192  9005              STR      r0,[sp,#0x14]         ;2140
000194  9805              LDR      r0,[sp,#0x14]         ;2141
000196  b970              CBNZ     r0,|L3.438|
000198  f894004b          LDRB     r0,[r4,#0x4b]         ;2141
00019c  0601              LSLS     r1,r0,#24             ;2141
00019e  f894004a          LDRB     r0,[r4,#0x4a]         ;2141
0001a2  ea414100          ORR      r1,r1,r0,LSL #16      ;2141
0001a6  f8940049          LDRB     r0,[r4,#0x49]         ;2141
0001aa  ea412000          ORR      r0,r1,r0,LSL #8       ;2141
0001ae  f8941048          LDRB     r1,[r4,#0x48]         ;2141
0001b2  4308              ORRS     r0,r0,r1              ;2141
0001b4  9005              STR      r0,[sp,#0x14]         ;2141
                  |L3.438|
0001b6  2036              MOVS     r0,#0x36              ;2143
0001b8  5d01              LDRB     r1,[r0,r4]            ;2143
0001ba  f8940037          LDRB     r0,[r4,#0x37]         ;2143
0001be  ea412000          ORR      r0,r1,r0,LSL #8       ;2143
0001c2  9002              STR      r0,[sp,#8]            ;2143
0001c4  9802              LDR      r0,[sp,#8]            ;2144
0001c6  b908              CBNZ     r0,|L3.460|
0001c8  200d              MOVS     r0,#0xd               ;2144
0001ca  e73b              B        |L3.68|
                  |L3.460|
0001cc  9802              LDR      r0,[sp,#8]            ;2147
0001ce  4440              ADD      r0,r0,r8              ;2147
0001d0  8921              LDRH     r1,[r4,#8]            ;2147
0001d2  eb001011          ADD      r0,r0,r1,LSR #4       ;2147
0001d6  9004              STR      r0,[sp,#0x10]         ;2147
0001d8  e9dd0104          LDRD     r0,r1,[sp,#0x10]      ;2148
0001dc  4281              CMP      r1,r0                 ;2148
0001de  d201              BCS      |L3.484|
0001e0  200d              MOVS     r0,#0xd               ;2148
0001e2  e72f              B        |L3.68|
                  |L3.484|
0001e4  e9dd1004          LDRD     r1,r0,[sp,#0x10]      ;2149
0001e8  1a40              SUBS     r0,r0,r1              ;2149
0001ea  78a1              LDRB     r1,[r4,#2]            ;2149
0001ec  fbb0faf1          UDIV     r10,r0,r1             ;2149
0001f0  f1ba0f00          CMP      r10,#0                ;2150
0001f4  d101              BNE      |L3.506|
0001f6  200d              MOVS     r0,#0xd               ;2150
0001f8  e724              B        |L3.68|
                  |L3.506|
0001fa  2501              MOVS     r5,#1                 ;2151
0001fc  f64070f6          MOV      r0,#0xff6             ;2152
000200  4582              CMP      r10,r0                ;2152
000202  d300              BCC      |L3.518|
000204  2502              MOVS     r5,#2                 ;2152
                  |L3.518|
000206  f64f70f6          MOV      r0,#0xfff6            ;2153
00020a  4582              CMP      r10,r0                ;2153
00020c  d300              BCC      |L3.528|
00020e  2503              MOVS     r5,#3                 ;2153
                  |L3.528|
000210  f10a0002          ADD      r0,r10,#2             ;2156
000214  6120              STR      r0,[r4,#0x10]         ;2156
000216  9904              LDR      r1,[sp,#0x10]         ;2157
000218  9806              LDR      r0,[sp,#0x18]         ;2157
00021a  4408              ADD      r0,r0,r1              ;2157
00021c  6220              STR      r0,[r4,#0x20]         ;2157
00021e  9902              LDR      r1,[sp,#8]            ;2158
000220  9806              LDR      r0,[sp,#0x18]         ;2158
000222  4408              ADD      r0,r0,r1              ;2158
000224  61a0              STR      r0,[r4,#0x18]         ;2158
000226  2d03              CMP      r5,#3                 ;2159
000228  d116              BNE      |L3.600|
00022a  8920              LDRH     r0,[r4,#8]            ;2160
00022c  b108              CBZ      r0,|L3.562|
00022e  200d              MOVS     r0,#0xd               ;2160
000230  e708              B        |L3.68|
                  |L3.562|
000232  f8940057          LDRB     r0,[r4,#0x57]         ;2161
000236  0601              LSLS     r1,r0,#24             ;2161
000238  f8940056          LDRB     r0,[r4,#0x56]         ;2161
00023c  ea414100          ORR      r1,r1,r0,LSL #16      ;2161
000240  f8940055          LDRB     r0,[r4,#0x55]         ;2161
000244  ea412000          ORR      r0,r1,r0,LSL #8       ;2161
000248  f8941054          LDRB     r1,[r4,#0x54]         ;2161
00024c  4308              ORRS     r0,r0,r1              ;2161
00024e  61e0              STR      r0,[r4,#0x1c]         ;2161
000250  6920              LDR      r0,[r4,#0x10]         ;2162
000252  0080              LSLS     r0,r0,#2              ;2162
000254  9003              STR      r0,[sp,#0xc]          ;2162
000256  e014              B        |L3.642|
                  |L3.600|
000258  8920              LDRH     r0,[r4,#8]            ;2164
00025a  b908              CBNZ     r0,|L3.608|
00025c  200d              MOVS     r0,#0xd               ;2164
00025e  e6f1              B        |L3.68|
                  |L3.608|
000260  69a0              LDR      r0,[r4,#0x18]         ;2165
000262  4440              ADD      r0,r0,r8              ;2165
000264  61e0              STR      r0,[r4,#0x1c]         ;2165
000266  2d02              CMP      r5,#2                 ;2166
000268  d102              BNE      |L3.624|
00026a  6920              LDR      r0,[r4,#0x10]         ;2167
00026c  0040              LSLS     r0,r0,#1              ;2167
00026e  e007              B        |L3.640|
                  |L3.624|
000270  7c20              LDRB     r0,[r4,#0x10]         ;2167
000272  f0000001          AND      r0,r0,#1              ;2167
000276  6921              LDR      r1,[r4,#0x10]         ;2167
000278  eb010141          ADD      r1,r1,r1,LSL #1       ;2167
00027c  eb000051          ADD      r0,r0,r1,LSR #1       ;2167
                  |L3.640|
000280  9003              STR      r0,[sp,#0xc]          ;2167
                  |L3.642|
000282  6961              LDR      r1,[r4,#0x14]         ;2169
000284  9803              LDR      r0,[sp,#0xc]          ;2169
000286  f20010ff          ADD      r0,r0,#0x1ff          ;2169
00028a  ebb12f50          CMP      r1,r0,LSR #9          ;2169
00028e  d201              BCS      |L3.660|
000290  200d              MOVS     r0,#0xd               ;2170
000292  e6d7              B        |L3.68|
                  |L3.660|
000294  7025              STRB     r5,[r4,#0]            ;2190
000296  4808              LDR      r0,|L3.696|
000298  8800              LDRH     r0,[r0,#0]            ;2191  ; Fsid
00029a  1c40              ADDS     r0,r0,#1              ;2191
00029c  b280              UXTH     r0,r0                 ;2191
00029e  4906              LDR      r1,|L3.696|
0002a0  8008              STRH     r0,[r1,#0]            ;2191
0002a2  80e0              STRH     r0,[r4,#6]            ;2191
0002a4  2000              MOVS     r0,#0                 ;2192
0002a6  6260              STR      r0,[r4,#0x24]         ;2192
0002a8  7120              STRB     r0,[r4,#4]            ;2193
0002aa  60e0              STR      r0,[r4,#0xc]          ;2195
0002ac  bf00              NOP                            ;2201
0002ae  e6c9              B        |L3.68|
;;;2203   
                          ENDP

                  |L3.688|
                          DCD      CurrVol
                  |L3.692|
                          DCD      FatFs
                  |L3.696|
                          DCD      Fsid

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;803    
;;;804    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  4602              MOV      r2,r0
;;;805    	FATFS *fs,		/* File system object */
;;;806    	DWORD clst		/* Cluster# to be converted */
;;;807    )
;;;808    {
;;;809    	clst -= 2;
000002  1e89              SUBS     r1,r1,#2
;;;810    	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
000004  6910              LDR      r0,[r2,#0x10]
000006  1e80              SUBS     r0,r0,#2
000008  4288              CMP      r0,r1
00000a  d801              BHI      |L4.16|
00000c  2000              MOVS     r0,#0
                  |L4.14|
;;;811    	return clst * fs->csize + fs->database;
;;;812    }
00000e  4770              BX       lr
                  |L4.16|
000010  7893              LDRB     r3,[r2,#2]            ;811
000012  6a10              LDR      r0,[r2,#0x20]         ;811
000014  fb010003          MLA      r0,r1,r3,r0           ;811
000018  e7f9              B        |L4.14|
;;;813    
                          ENDP


                          AREA ||i.cmp_lfn||, CODE, READONLY, ALIGN=2

                  cmp_lfn PROC
;;;1221   static
;;;1222   int cmp_lfn (			/* 1:Matched, 0:Not matched */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1223   	WCHAR *lfnbuf,		/* Pointer to the LFN to be compared */
;;;1224   	BYTE *dir			/* Pointer to the directory entry containing a part of LFN */
;;;1225   )
;;;1226   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1227   	UINT i, s;
;;;1228   	WCHAR wc, uc;
;;;1229   
;;;1230   
;;;1231   	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
000008  7820              LDRB     r0,[r4,#0]
00000a  f0200040          BIC      r0,r0,#0x40
00000e  1e40              SUBS     r0,r0,#1
000010  eb000180          ADD      r1,r0,r0,LSL #2
000014  eb0106c0          ADD      r6,r1,r0,LSL #3
;;;1232   	s = 0; wc = 1;
000018  2700              MOVS     r7,#0
00001a  f04f0801          MOV      r8,#1
;;;1233   	do {
00001e  bf00              NOP      
                  |L5.32|
;;;1234   		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
000020  481a              LDR      r0,|L5.140|
000022  5dc0              LDRB     r0,[r0,r7]
000024  5c20              LDRB     r0,[r4,r0]
000026  4919              LDR      r1,|L5.140|
000028  5dc9              LDRB     r1,[r1,r7]
00002a  4421              ADD      r1,r1,r4
00002c  7849              LDRB     r1,[r1,#1]
00002e  ea402901          ORR      r9,r0,r1,LSL #8
;;;1235   		if (wc) {	/* Last char has not been processed */
000032  f1b80f00          CMP      r8,#0
000036  d010              BEQ      |L5.90|
;;;1236   			wc = ff_wtoupper(uc);		/* Convert it to upper case */
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       ff_wtoupper
00003e  4680              MOV      r8,r0
;;;1237   			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
000040  2eff              CMP      r6,#0xff
000042  d207              BCS      |L5.84|
000044  4631              MOV      r1,r6
000046  1c76              ADDS     r6,r6,#1
000048  f8350011          LDRH     r0,[r5,r1,LSL #1]
00004c  f7fffffe          BL       ff_wtoupper
000050  4540              CMP      r0,r8
000052  d008              BEQ      |L5.102|
                  |L5.84|
;;;1238   				return 0;				/* Not matched */
000054  2000              MOVS     r0,#0
                  |L5.86|
;;;1239   		} else {
;;;1240   			if (uc != 0xFFFF) return 0;	/* Check filler */
;;;1241   		}
;;;1242   	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
;;;1243   
;;;1244   	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
;;;1245   		return 0;
;;;1246   
;;;1247   	return 1;						/* The part of LFN matched */
;;;1248   }
000056  e8bd87f0          POP      {r4-r10,pc}
                  |L5.90|
00005a  f64f70ff          MOV      r0,#0xffff            ;1240
00005e  4581              CMP      r9,r0                 ;1240
000060  d001              BEQ      |L5.102|
000062  2000              MOVS     r0,#0                 ;1240
000064  e7f7              B        |L5.86|
                  |L5.102|
000066  1c78              ADDS     r0,r7,#1              ;1242
000068  4607              MOV      r7,r0                 ;1242
00006a  280d              CMP      r0,#0xd               ;1242
00006c  d3d8              BCC      |L5.32|
00006e  7820              LDRB     r0,[r4,#0]            ;1244
000070  f0000040          AND      r0,r0,#0x40           ;1244
000074  b138              CBZ      r0,|L5.134|
000076  f1b80f00          CMP      r8,#0                 ;1244
00007a  d004              BEQ      |L5.134|
00007c  f8350016          LDRH     r0,[r5,r6,LSL #1]     ;1244
000080  b108              CBZ      r0,|L5.134|
000082  2000              MOVS     r0,#0                 ;1245
000084  e7e7              B        |L5.86|
                  |L5.134|
000086  2001              MOVS     r0,#1                 ;1247
000088  e7e5              B        |L5.86|
;;;1249   
                          ENDP

00008a  0000              DCW      0x0000
                  |L5.140|
                          DCD      LfnOfs

                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1659   static
;;;1660   FRESULT create_name (
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;1661   	DIR *dj,			/* Pointer to the directory object */
;;;1662   	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
;;;1663   )
;;;1664   {
000004  b083              SUB      sp,sp,#0xc
000006  4681              MOV      r9,r0
;;;1665   #ifdef _EXCVT
;;;1666   	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
;;;1667   #endif
;;;1668   
;;;1669   #if _USE_LFN	/* LFN configuration */
;;;1670   	BYTE b, cf;
;;;1671   	WCHAR w, *lfn;
;;;1672   	UINT i, ni, si, di;
;;;1673   	const TCHAR *p;
;;;1674   
;;;1675   	/* Create LFN in Unicode */
;;;1676   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
000008  9804              LDR      r0,[sp,#0x10]
00000a  6800              LDR      r0,[r0,#0]
00000c  9001              STR      r0,[sp,#4]
00000e  e002              B        |L6.22|
                  |L6.16|
000010  9801              LDR      r0,[sp,#4]
000012  1c40              ADDS     r0,r0,#1
000014  9001              STR      r0,[sp,#4]
                  |L6.22|
000016  9801              LDR      r0,[sp,#4]
000018  7800              LDRB     r0,[r0,#0]
00001a  282f              CMP      r0,#0x2f
00001c  d0f8              BEQ      |L6.16|
00001e  9801              LDR      r0,[sp,#4]
000020  7800              LDRB     r0,[r0,#0]
000022  285c              CMP      r0,#0x5c
000024  d0f4              BEQ      |L6.16|
;;;1677   	lfn = dj->lfn;
000026  f8d9701c          LDR      r7,[r9,#0x1c]
;;;1678   	si = di = 0;
00002a  2500              MOVS     r5,#0
00002c  46a8              MOV      r8,r5
;;;1679   	for (;;) {
00002e  bf00              NOP      
                  |L6.48|
;;;1680   		w = p[si++];					/* Get a character */
000030  4640              MOV      r0,r8
000032  f1080801          ADD      r8,r8,#1
000036  9901              LDR      r1,[sp,#4]
000038  5c0c              LDRB     r4,[r1,r0]
;;;1681   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
00003a  2c20              CMP      r4,#0x20
00003c  db03              BLT      |L6.70|
00003e  2c2f              CMP      r4,#0x2f
000040  d001              BEQ      |L6.70|
000042  2c5c              CMP      r4,#0x5c
000044  d100              BNE      |L6.72|
                  |L6.70|
000046  e01c              B        |L6.130|
                  |L6.72|
;;;1682   		if (di >= _MAX_LFN)				/* Reject too long name */
000048  2dff              CMP      r5,#0xff
00004a  d303              BCC      |L6.84|
;;;1683   			return FR_INVALID_NAME;
00004c  2006              MOVS     r0,#6
                  |L6.78|
;;;1684   #if !_LFN_UNICODE
;;;1685   		w &= 0xFF;
;;;1686   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1687   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1688   			if (!IsDBCS2(b))
;;;1689   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1690   			else
;;;1691   				w = (w << 8) + b;			/* Create a DBC */
;;;1692   		}
;;;1693   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1694   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1695   #endif
;;;1696   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
;;;1697   			return FR_INVALID_NAME;
;;;1698   		lfn[di++] = w;					/* Store the Unicode char */
;;;1699   	}
;;;1700   	*path = &p[si];						/* Return pointer to the next segment */
;;;1701   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1702   #if _FS_RPATH
;;;1703   	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
;;;1704   		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
;;;1705   		lfn[di] = 0;
;;;1706   		for (i = 0; i < 11; i++)
;;;1707   			dj->fn[i] = (i < di) ? '.' : ' ';
;;;1708   		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1709   		return FR_OK;
;;;1710   	}
;;;1711   #endif
;;;1712   	while (di) {						/* Strip trailing spaces and dots */
;;;1713   		w = lfn[di-1];
;;;1714   		if (w != ' ' && w != '.') break;
;;;1715   		di--;
;;;1716   	}
;;;1717   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1718   
;;;1719   	lfn[di] = 0;						/* LFN is created */
;;;1720   
;;;1721   	/* Create SFN in directory form */
;;;1722   	mem_set(dj->fn, ' ', 11);
;;;1723   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1724   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1725   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1726   
;;;1727   	b = i = 0; ni = 8;
;;;1728   	for (;;) {
;;;1729   		w = lfn[si++];					/* Get an LFN char */
;;;1730   		if (!w) break;					/* Break on end of the LFN */
;;;1731   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1732   			cf |= NS_LOSS | NS_LFN; continue;
;;;1733   		}
;;;1734   
;;;1735   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1736   			if (ni == 11) {				/* Long extension */
;;;1737   				cf |= NS_LOSS | NS_LFN; break;
;;;1738   			}
;;;1739   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1740   			if (si > di) break;			/* No extension */
;;;1741   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1742   			b <<= 2; continue;
;;;1743   		}
;;;1744   
;;;1745   		if (w >= 0x80) {				/* Non ASCII char */
;;;1746   #ifdef _EXCVT
;;;1747   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1748   			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
;;;1749   #else
;;;1750   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1751   #endif
;;;1752   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1753   		}
;;;1754   
;;;1755   		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
;;;1756   			if (i >= ni - 1) {
;;;1757   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1758   			}
;;;1759   			dj->fn[i++] = (BYTE)(w >> 8);
;;;1760   		} else {						/* Single byte char */
;;;1761   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
;;;1762   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1763   			} else {
;;;1764   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1765   					b |= 2;
;;;1766   				} else {
;;;1767   					if (IsLower(w)) {	/* ASCII small capital */
;;;1768   						b |= 1; w -= 0x20;
;;;1769   					}
;;;1770   				}
;;;1771   			}
;;;1772   		}
;;;1773   		dj->fn[i++] = (BYTE)w;
;;;1774   	}
;;;1775   
;;;1776   	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
;;;1777   
;;;1778   	if (ni == 8) b <<= 2;
;;;1779   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1780   		cf |= NS_LFN;
;;;1781   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
;;;1782   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1783   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1784   	}
;;;1785   
;;;1786   	dj->fn[NS] = cf;	/* SFN is created */
;;;1787   
;;;1788   	return FR_OK;
;;;1789   
;;;1790   
;;;1791   #else	/* Non-LFN configuration */
;;;1792   	BYTE b, c, d, *sfn;
;;;1793   	UINT ni, si, i;
;;;1794   	const char *p;
;;;1795   
;;;1796   	/* Create file name in directory form */
;;;1797   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1798   	sfn = dj->fn;
;;;1799   	mem_set(sfn, ' ', 11);
;;;1800   	si = i = b = 0; ni = 8;
;;;1801   #if _FS_RPATH
;;;1802   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1803   		for (;;) {
;;;1804   			c = (BYTE)p[si++];
;;;1805   			if (c != '.' || si >= 3) break;
;;;1806   			sfn[i++] = c;
;;;1807   		}
;;;1808   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1809   		*path = &p[si];									/* Return pointer to the next segment */
;;;1810   		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1811   		return FR_OK;
;;;1812   	}
;;;1813   #endif
;;;1814   	for (;;) {
;;;1815   		c = (BYTE)p[si++];
;;;1816   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
;;;1817   		if (c == '.' || i >= ni) {
;;;1818   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
;;;1819   			i = 8; ni = 11;
;;;1820   			b <<= 2; continue;
;;;1821   		}
;;;1822   		if (c >= 0x80) {				/* Extended char? */
;;;1823   			b |= 3;						/* Eliminate NT flag */
;;;1824   #ifdef _EXCVT
;;;1825   			c = excvt[c - 0x80];		/* Upper conversion (SBCS) */
;;;1826   #else
;;;1827   #if !_DF1S	/* ASCII only cfg */
;;;1828   			return FR_INVALID_NAME;
;;;1829   #endif
;;;1830   #endif
;;;1831   		}
;;;1832   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1833   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;1834   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;1835   				return FR_INVALID_NAME;
;;;1836   			sfn[i++] = c;
;;;1837   			sfn[i++] = d;
;;;1838   		} else {						/* Single byte code */
;;;1839   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;;;1840   				return FR_INVALID_NAME;
;;;1841   			if (IsUpper(c)) {			/* ASCII large capital? */
;;;1842   				b |= 2;
;;;1843   			} else {
;;;1844   				if (IsLower(c)) {		/* ASCII small capital? */
;;;1845   					b |= 1; c -= 0x20;
;;;1846   				}
;;;1847   			}
;;;1848   			sfn[i++] = c;
;;;1849   		}
;;;1850   	}
;;;1851   	*path = &p[si];						/* Return pointer to the next segment */
;;;1852   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1853   
;;;1854   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;;;1855   	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
;;;1856   
;;;1857   	if (ni == 8) b <<= 2;
;;;1858   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;1859   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;1860   
;;;1861   	sfn[NS] = c;		/* Store NT flag, File name is created */
;;;1862   
;;;1863   	return FR_OK;
;;;1864   #endif
;;;1865   }
00004e  b005              ADD      sp,sp,#0x14
000050  e8bd8ff0          POP      {r4-r11,pc}
                  |L6.84|
000054  b2e4              UXTB     r4,r4                 ;1685
000056  2101              MOVS     r1,#1                 ;1693
000058  4620              MOV      r0,r4                 ;1693
00005a  f7fffffe          BL       ff_convert
00005e  4604              MOV      r4,r0                 ;1693
000060  b90c              CBNZ     r4,|L6.102|
000062  2006              MOVS     r0,#6                 ;1694
000064  e7f3              B        |L6.78|
                  |L6.102|
000066  2c80              CMP      r4,#0x80              ;1696
000068  da06              BGE      |L6.120|
00006a  4621              MOV      r1,r4                 ;1696
00006c  a084              ADR      r0,|L6.640|
00006e  f7fffffe          BL       chk_chr
000072  b108              CBZ      r0,|L6.120|
000074  2006              MOVS     r0,#6                 ;1697
000076  e7ea              B        |L6.78|
                  |L6.120|
000078  4628              MOV      r0,r5                 ;1698
00007a  1c6d              ADDS     r5,r5,#1              ;1698
00007c  f8274010          STRH     r4,[r7,r0,LSL #1]     ;1698
000080  e7d6              B        |L6.48|
                  |L6.130|
000082  bf00              NOP                            ;1681
000084  9801              LDR      r0,[sp,#4]            ;1700
000086  eb000108          ADD      r1,r0,r8              ;1700
00008a  9804              LDR      r0,[sp,#0x10]         ;1700
00008c  6001              STR      r1,[r0,#0]            ;1700
00008e  2c20              CMP      r4,#0x20              ;1701
000090  da01              BGE      |L6.150|
000092  2004              MOVS     r0,#4                 ;1701
000094  e000              B        |L6.152|
                  |L6.150|
000096  2000              MOVS     r0,#0                 ;1701
                  |L6.152|
000098  4606              MOV      r6,r0                 ;1701
00009a  2d01              CMP      r5,#1                 ;1703
00009c  d104              BNE      |L6.168|
00009e  1e68              SUBS     r0,r5,#1              ;1703
0000a0  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;1703
0000a4  282e              CMP      r0,#0x2e              ;1703
0000a6  d00b              BEQ      |L6.192|
                  |L6.168|
0000a8  2d02              CMP      r5,#2                 ;1704
0000aa  d124              BNE      |L6.246|
0000ac  1e68              SUBS     r0,r5,#1              ;1704
0000ae  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;1704
0000b2  282e              CMP      r0,#0x2e              ;1704
0000b4  d11f              BNE      |L6.246|
0000b6  1ea8              SUBS     r0,r5,#2              ;1704
0000b8  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;1704
0000bc  282e              CMP      r0,#0x2e              ;1704
0000be  d11a              BNE      |L6.246|
                  |L6.192|
0000c0  2000              MOVS     r0,#0                 ;1705
0000c2  f8270015          STRH     r0,[r7,r5,LSL #1]     ;1705
0000c6  4683              MOV      r11,r0                ;1706
0000c8  e00a              B        |L6.224|
                  |L6.202|
0000ca  45ab              CMP      r11,r5                ;1707
0000cc  d201              BCS      |L6.210|
0000ce  202e              MOVS     r0,#0x2e              ;1707
0000d0  e000              B        |L6.212|
                  |L6.210|
0000d2  2020              MOVS     r0,#0x20              ;1707
                  |L6.212|
0000d4  f8d91018          LDR      r1,[r9,#0x18]         ;1707
0000d8  f801000b          STRB     r0,[r1,r11]           ;1707
0000dc  f10b0b01          ADD      r11,r11,#1            ;1706
                  |L6.224|
0000e0  f1bb0f0b          CMP      r11,#0xb              ;1706
0000e4  d3f1              BCC      |L6.202|
0000e6  f0460020          ORR      r0,r6,#0x20           ;1708
0000ea  f8d91018          LDR      r1,[r9,#0x18]         ;1708
0000ee  f801000b          STRB     r0,[r1,r11]           ;1708
0000f2  2000              MOVS     r0,#0                 ;1709
0000f4  e7ab              B        |L6.78|
                  |L6.246|
0000f6  e008              B        |L6.266|
                  |L6.248|
0000f8  1e68              SUBS     r0,r5,#1              ;1713
0000fa  f8374010          LDRH     r4,[r7,r0,LSL #1]     ;1713
0000fe  2c20              CMP      r4,#0x20              ;1714
000100  d002              BEQ      |L6.264|
000102  2c2e              CMP      r4,#0x2e              ;1714
000104  d000              BEQ      |L6.264|
000106  e002              B        |L6.270|
                  |L6.264|
000108  1e6d              SUBS     r5,r5,#1              ;1715
                  |L6.266|
00010a  2d00              CMP      r5,#0                 ;1712
00010c  d1f4              BNE      |L6.248|
                  |L6.270|
00010e  bf00              NOP                            ;1714
000110  b90d              CBNZ     r5,|L6.278|
000112  2006              MOVS     r0,#6                 ;1717
000114  e79b              B        |L6.78|
                  |L6.278|
000116  2000              MOVS     r0,#0                 ;1719
000118  f8270015          STRH     r0,[r7,r5,LSL #1]     ;1719
00011c  220b              MOVS     r2,#0xb               ;1722
00011e  2120              MOVS     r1,#0x20              ;1722
000120  f8d90018          LDR      r0,[r9,#0x18]         ;1722
000124  f7fffffe          BL       mem_set
000128  f04f0800          MOV      r8,#0                 ;1723
00012c  e001              B        |L6.306|
                  |L6.302|
00012e  f1080801          ADD      r8,r8,#1              ;1723
                  |L6.306|
000132  f8370018          LDRH     r0,[r7,r8,LSL #1]     ;1723
000136  2820              CMP      r0,#0x20              ;1723
000138  d0f9              BEQ      |L6.302|
00013a  f8370018          LDRH     r0,[r7,r8,LSL #1]     ;1723
00013e  282e              CMP      r0,#0x2e              ;1723
000140  d0f5              BEQ      |L6.302|
000142  f1b80f00          CMP      r8,#0                 ;1724
000146  d001              BEQ      |L6.332|
000148  f0460603          ORR      r6,r6,#3              ;1724
                  |L6.332|
00014c  e000              B        |L6.336|
                  |L6.334|
00014e  1e6d              SUBS     r5,r5,#1              ;1725
                  |L6.336|
000150  b125              CBZ      r5,|L6.348|
000152  1e68              SUBS     r0,r5,#1              ;1725
000154  f8370010          LDRH     r0,[r7,r0,LSL #1]     ;1725
000158  282e              CMP      r0,#0x2e              ;1725
00015a  d1f8              BNE      |L6.334|
                  |L6.348|
00015c  f04f0a00          MOV      r10,#0                ;1727
000160  46d3              MOV      r11,r10               ;1727
000162  2008              MOVS     r0,#8                 ;1727
000164  9002              STR      r0,[sp,#8]            ;1727
000166  bf00              NOP                            ;1728
                  |L6.360|
000168  4640              MOV      r0,r8                 ;1729
00016a  f1080801          ADD      r8,r8,#1              ;1729
00016e  f8374010          LDRH     r4,[r7,r0,LSL #1]     ;1729
000172  b904              CBNZ     r4,|L6.374|
000174  e054              B        |L6.544|
                  |L6.374|
000176  2c20              CMP      r4,#0x20              ;1731
000178  d003              BEQ      |L6.386|
00017a  2c2e              CMP      r4,#0x2e              ;1731
00017c  d104              BNE      |L6.392|
00017e  45a8              CMP      r8,r5                 ;1731
000180  d002              BEQ      |L6.392|
                  |L6.386|
000182  f0460603          ORR      r6,r6,#3              ;1732
000186  e7ef              B        |L6.360|
                  |L6.392|
000188  9802              LDR      r0,[sp,#8]            ;1735
00018a  4583              CMP      r11,r0                ;1735
00018c  d201              BCS      |L6.402|
00018e  45a8              CMP      r8,r5                 ;1735
000190  d116              BNE      |L6.448|
                  |L6.402|
000192  9802              LDR      r0,[sp,#8]            ;1736
000194  280b              CMP      r0,#0xb               ;1736
000196  d102              BNE      |L6.414|
000198  f0460603          ORR      r6,r6,#3              ;1737
00019c  e040              B        |L6.544|
                  |L6.414|
00019e  45a8              CMP      r8,r5                 ;1739
0001a0  d001              BEQ      |L6.422|
0001a2  f0460603          ORR      r6,r6,#3              ;1739
                  |L6.422|
0001a6  45a8              CMP      r8,r5                 ;1740
0001a8  d900              BLS      |L6.428|
0001aa  e039              B        |L6.544|
                  |L6.428|
0001ac  46a8              MOV      r8,r5                 ;1741
0001ae  f04f0b08          MOV      r11,#8                ;1741
0001b2  200b              MOVS     r0,#0xb               ;1741
0001b4  9002              STR      r0,[sp,#8]            ;1741
0001b6  ea4f608a          LSL      r0,r10,#26            ;1742
0001ba  ea4f6a10          LSR      r10,r0,#24            ;1742
0001be  e7d3              B        |L6.360|
                  |L6.448|
0001c0  2c80              CMP      r4,#0x80              ;1745
0001c2  db0b              BLT      |L6.476|
0001c4  2100              MOVS     r1,#0                 ;1747
0001c6  4620              MOV      r0,r4                 ;1747
0001c8  f7fffffe          BL       ff_convert
0001cc  4604              MOV      r4,r0                 ;1747
0001ce  b11c              CBZ      r4,|L6.472|
0001d0  f1a40080          SUB      r0,r4,#0x80           ;1748
0001d4  492d              LDR      r1,|L6.652|
0001d6  5c0c              LDRB     r4,[r1,r0]            ;1748
                  |L6.472|
0001d8  f0460602          ORR      r6,r6,#2              ;1752
                  |L6.476|
0001dc  bf00              NOP                            ;1755
0001de  b124              CBZ      r4,|L6.490|
0001e0  4621              MOV      r1,r4                 ;1761
0001e2  a02b              ADR      r0,|L6.656|
0001e4  f7fffffe          BL       chk_chr
0001e8  b118              CBZ      r0,|L6.498|
                  |L6.490|
0001ea  245f              MOVS     r4,#0x5f              ;1762
0001ec  f0460603          ORR      r6,r6,#3              ;1762
0001f0  e00f              B        |L6.530|
                  |L6.498|
0001f2  2c41              CMP      r4,#0x41              ;1764
0001f4  db04              BLT      |L6.512|
0001f6  2c5a              CMP      r4,#0x5a              ;1764
0001f8  dc02              BGT      |L6.512|
0001fa  f04a0a02          ORR      r10,r10,#2            ;1765
0001fe  e008              B        |L6.530|
                  |L6.512|
000200  2c61              CMP      r4,#0x61              ;1767
000202  db06              BLT      |L6.530|
000204  2c7a              CMP      r4,#0x7a              ;1767
000206  dc04              BGT      |L6.530|
000208  f04a0a01          ORR      r10,r10,#1            ;1768
00020c  f1a40020          SUB      r0,r4,#0x20           ;1768
000210  b284              UXTH     r4,r0                 ;1768
                  |L6.530|
000212  4658              MOV      r0,r11                ;1773
000214  f10b0b01          ADD      r11,r11,#1            ;1773
000218  f8d93018          LDR      r3,[r9,#0x18]         ;1773
00021c  541c              STRB     r4,[r3,r0]            ;1773
00021e  e7a3              B        |L6.360|
                  |L6.544|
000220  bf00              NOP                            ;1730
000222  f8d90018          LDR      r0,[r9,#0x18]         ;1776
000226  7800              LDRB     r0,[r0,#0]            ;1776
000228  28e5              CMP      r0,#0xe5              ;1776
00022a  d103              BNE      |L6.564|
00022c  2005              MOVS     r0,#5                 ;1776
00022e  f8d91018          LDR      r1,[r9,#0x18]         ;1776
000232  7008              STRB     r0,[r1,#0]            ;1776
                  |L6.564|
000234  9802              LDR      r0,[sp,#8]            ;1778
000236  2808              CMP      r0,#8                 ;1778
000238  d103              BNE      |L6.578|
00023a  ea4f608a          LSL      r0,r10,#26            ;1778
00023e  ea4f6a10          LSR      r10,r0,#24            ;1778
                  |L6.578|
000242  f00a000c          AND      r0,r10,#0xc           ;1779
000246  280c              CMP      r0,#0xc               ;1779
000248  d003              BEQ      |L6.594|
00024a  f00a0003          AND      r0,r10,#3             ;1779
00024e  2803              CMP      r0,#3                 ;1779
000250  d101              BNE      |L6.598|
                  |L6.594|
000252  f0460602          ORR      r6,r6,#2              ;1780
                  |L6.598|
000256  f0060002          AND      r0,r6,#2              ;1781
00025a  b958              CBNZ     r0,|L6.628|
00025c  f00a0003          AND      r0,r10,#3             ;1782
000260  2801              CMP      r0,#1                 ;1782
000262  d101              BNE      |L6.616|
000264  f0460610          ORR      r6,r6,#0x10           ;1782
                  |L6.616|
000268  f00a000c          AND      r0,r10,#0xc           ;1783
00026c  2804              CMP      r0,#4                 ;1783
00026e  d101              BNE      |L6.628|
000270  f0460608          ORR      r6,r6,#8              ;1783
                  |L6.628|
000274  f8d90018          LDR      r0,[r9,#0x18]         ;1786
000278  72c6              STRB     r6,[r0,#0xb]          ;1786
00027a  2000              MOVS     r0,#0                 ;1788
00027c  e6e7              B        |L6.78|
;;;1866   
                          ENDP

00027e  0000              DCW      0x0000
                  |L6.640|
000280  222a3a3c          DCB      """*:<>?|",127,0
000284  3e3f7c7f
000288  00      
000289  00                DCB      0
00028a  00                DCB      0
00028b  00                DCB      0
                  |L6.652|
                          DCD      excvt
                  |L6.656|
000290  2b2c3b3d          DCB      "+,;=[]",0
000294  5b5d00  
000297  00                DCB      0

                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=1

                  dir_find PROC
;;;1389   static
;;;1390   FRESULT dir_find (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1391   	DIR *dj			/* Pointer to the directory object linked to the file name */
;;;1392   )
;;;1393   {
000004  4604              MOV      r4,r0
;;;1394   	FRESULT res;
;;;1395   	BYTE c, *dir;
;;;1396   #if _USE_LFN
;;;1397   	BYTE a, ord, sum;
;;;1398   #endif
;;;1399   
;;;1400   	res = dir_sdi(dj, 0);			/* Rewind directory object */
000006  2100              MOVS     r1,#0
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dir_sdi
00000e  4607              MOV      r7,r0
;;;1401   	if (res != FR_OK) return res;
000010  b117              CBZ      r7,|L7.24|
000012  4638              MOV      r0,r7
                  |L7.20|
;;;1402   
;;;1403   #if _USE_LFN
;;;1404   	ord = sum = 0xFF;
;;;1405   #endif
;;;1406   	do {
;;;1407   		res = move_window(dj->fs, dj->sect);
;;;1408   		if (res != FR_OK) break;
;;;1409   		dir = dj->dir;					/* Ptr to the directory entry of current index */
;;;1410   		c = dir[DIR_Name];
;;;1411   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
;;;1412   #if _USE_LFN	/* LFN configuration */
;;;1413   		a = dir[DIR_Attr] & AM_MASK;
;;;1414   		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;1415   			ord = 0xFF;
;;;1416   		} else {
;;;1417   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1418   				if (dj->lfn) {
;;;1419   					if (c & LLE) {		/* Is it start of LFN sequence? */
;;;1420   						sum = dir[LDIR_Chksum];
;;;1421   						c &= ~LLE; ord = c;	/* LFN start order */
;;;1422   						dj->lfn_idx = dj->index;
;;;1423   					}
;;;1424   					/* Check validity of the LFN entry and compare it with given name */
;;;1425   					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
;;;1426   				}
;;;1427   			} else {					/* An SFN entry is found */
;;;1428   				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
;;;1429   				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1430   				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
;;;1431   			}
;;;1432   		}
;;;1433   #else		/* Non LFN configuration */
;;;1434   		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
;;;1435   			break;
;;;1436   #endif
;;;1437   		res = dir_next(dj, 0);		/* Next entry */
;;;1438   	} while (res == FR_OK);
;;;1439   
;;;1440   	return res;
;;;1441   }
000014  e8bd87f0          POP      {r4-r10,pc}
                  |L7.24|
000018  f04f09ff          MOV      r9,#0xff              ;1404
00001c  46ca              MOV      r10,r9                ;1404
00001e  bf00              NOP                            ;1406
                  |L7.32|
000020  6921              LDR      r1,[r4,#0x10]         ;1407
000022  6820              LDR      r0,[r4,#0]            ;1407
000024  f7fffffe          BL       move_window
000028  4607              MOV      r7,r0                 ;1407
00002a  b107              CBZ      r7,|L7.46|
00002c  e054              B        |L7.216|
                  |L7.46|
00002e  6965              LDR      r5,[r4,#0x14]         ;1409
000030  782e              LDRB     r6,[r5,#0]            ;1410
000032  b90e              CBNZ     r6,|L7.56|
000034  2704              MOVS     r7,#4                 ;1411
000036  e04f              B        |L7.216|
                  |L7.56|
000038  7ae8              LDRB     r0,[r5,#0xb]          ;1413
00003a  f000083f          AND      r8,r0,#0x3f           ;1413
00003e  2ee5              CMP      r6,#0xe5              ;1414
000040  d005              BEQ      |L7.78|
000042  f0080008          AND      r0,r8,#8              ;1414
000046  b128              CBZ      r0,|L7.84|
000048  f1b80f0f          CMP      r8,#0xf               ;1414
00004c  d002              BEQ      |L7.84|
                  |L7.78|
00004e  f04f09ff          MOV      r9,#0xff              ;1415
000052  e03a              B        |L7.202|
                  |L7.84|
000054  f1b80f0f          CMP      r8,#0xf               ;1417
000058  d11c              BNE      |L7.148|
00005a  69e0              LDR      r0,[r4,#0x1c]         ;1418
00005c  b3a0              CBZ      r0,|L7.200|
00005e  f0060040          AND      r0,r6,#0x40           ;1419
000062  b130              CBZ      r0,|L7.114|
000064  f895a00d          LDRB     r10,[r5,#0xd]         ;1420
000068  f0260640          BIC      r6,r6,#0x40           ;1421
00006c  46b1              MOV      r9,r6                 ;1421
00006e  88e0              LDRH     r0,[r4,#6]            ;1422
000070  8420              STRH     r0,[r4,#0x20]         ;1422
                  |L7.114|
000072  454e              CMP      r6,r9                 ;1425
000074  d10a              BNE      |L7.140|
000076  7b68              LDRB     r0,[r5,#0xd]          ;1425
000078  4550              CMP      r0,r10                ;1425
00007a  d107              BNE      |L7.140|
00007c  4629              MOV      r1,r5                 ;1425
00007e  69e0              LDR      r0,[r4,#0x1c]         ;1425
000080  f7fffffe          BL       cmp_lfn
000084  b110              CBZ      r0,|L7.140|
000086  f1a90001          SUB      r0,r9,#1              ;1425
00008a  e000              B        |L7.142|
                  |L7.140|
00008c  20ff              MOVS     r0,#0xff              ;1425
                  |L7.142|
00008e  f00009ff          AND      r9,r0,#0xff           ;1425
000092  e01a              B        |L7.202|
                  |L7.148|
000094  f1b90f00          CMP      r9,#0                 ;1428
000098  d105              BNE      |L7.166|
00009a  4628              MOV      r0,r5                 ;1428
00009c  f7fffffe          BL       sum_sfn
0000a0  4550              CMP      r0,r10                ;1428
0000a2  d100              BNE      |L7.166|
0000a4  e018              B        |L7.216|
                  |L7.166|
0000a6  f04f09ff          MOV      r9,#0xff              ;1429
0000aa  f64f70ff          MOV      r0,#0xffff            ;1429
0000ae  8420              STRH     r0,[r4,#0x20]         ;1429
0000b0  69a0              LDR      r0,[r4,#0x18]         ;1430
0000b2  7ac0              LDRB     r0,[r0,#0xb]          ;1430
0000b4  f0000001          AND      r0,r0,#1              ;1430
0000b8  b930              CBNZ     r0,|L7.200|
0000ba  220b              MOVS     r2,#0xb               ;1430
0000bc  4628              MOV      r0,r5                 ;1430
0000be  69a1              LDR      r1,[r4,#0x18]         ;1430
0000c0  f7fffffe          BL       mem_cmp
0000c4  b900              CBNZ     r0,|L7.200|
0000c6  e007              B        |L7.216|
                  |L7.200|
0000c8  e7ff              B        |L7.202|
                  |L7.202|
0000ca  2100              MOVS     r1,#0                 ;1437
0000cc  4620              MOV      r0,r4                 ;1437
0000ce  f7fffffe          BL       dir_next
0000d2  4607              MOV      r7,r0                 ;1437
0000d4  2f00              CMP      r7,#0                 ;1438
0000d6  d0a3              BEQ      |L7.32|
                  |L7.216|
0000d8  bf00              NOP                            ;1408
0000da  4638              MOV      r0,r7                 ;1440
0000dc  e79a              B        |L7.20|
;;;1442   
                          ENDP


                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1115   static
;;;1116   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1117   	DIR *dj,		/* Pointer to directory object */
;;;1118   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1119   )
;;;1120   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1121   	DWORD clst;
;;;1122   	WORD i;
;;;1123   
;;;1124   
;;;1125   	stretch = stretch;		/* To suppress warning on read-only cfg. */
000008  bf00              NOP      
;;;1126   	i = dj->index + 1;
00000a  88e0              LDRH     r0,[r4,#6]
00000c  1c40              ADDS     r0,r0,#1
00000e  b286              UXTH     r6,r0
;;;1127   	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
000010  b10e              CBZ      r6,|L8.22|
000012  6920              LDR      r0,[r4,#0x10]
000014  b910              CBNZ     r0,|L8.28|
                  |L8.22|
;;;1128   		return FR_NO_FILE;
000016  2004              MOVS     r0,#4
                  |L8.24|
;;;1129   
;;;1130   	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
;;;1131   		dj->sect++;					/* Next sector */
;;;1132   
;;;1133   		if (dj->clust == 0) {	/* Static table */
;;;1134   			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
;;;1135   				return FR_NO_FILE;
;;;1136   		}
;;;1137   		else {					/* Dynamic table */
;;;1138   			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
;;;1139   				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
;;;1140   				if (clst <= 1) return FR_INT_ERR;
;;;1141   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1142   				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
;;;1143   #if !_FS_READONLY
;;;1144   					BYTE c;
;;;1145   					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
;;;1146   					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
;;;1147   					if (clst == 0) return FR_DENIED;			/* No free cluster */
;;;1148   					if (clst == 1) return FR_INT_ERR;
;;;1149   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
;;;1150   					/* Clean-up stretched table */
;;;1151   					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
;;;1152   					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
;;;1153   					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
;;;1154   					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1155   						dj->fs->wflag = 1;
;;;1156   						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
;;;1157   						dj->fs->winsect++;
;;;1158   					}
;;;1159   					dj->fs->winsect -= c;						/* Rewind window address */
;;;1160   #else
;;;1161   					return FR_NO_FILE;			/* Report EOT */
;;;1162   #endif
;;;1163   				}
;;;1164   				dj->clust = clst;				/* Initialize data for new cluster */
;;;1165   				dj->sect = clust2sect(dj->fs, clst);
;;;1166   			}
;;;1167   		}
;;;1168   	}
;;;1169   
;;;1170   	dj->index = i;
;;;1171   	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
;;;1172   
;;;1173   	return FR_OK;
;;;1174   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L8.28|
00001c  f006000f          AND      r0,r6,#0xf            ;1130
000020  bb48              CBNZ     r0,|L8.118|
000022  6920              LDR      r0,[r4,#0x10]         ;1131
000024  1c40              ADDS     r0,r0,#1              ;1131
000026  6120              STR      r0,[r4,#0x10]         ;1131
000028  68e0              LDR      r0,[r4,#0xc]          ;1133
00002a  b928              CBNZ     r0,|L8.56|
00002c  6820              LDR      r0,[r4,#0]            ;1134
00002e  8900              LDRH     r0,[r0,#8]            ;1134
000030  42b0              CMP      r0,r6                 ;1134
000032  dc20              BGT      |L8.118|
000034  2004              MOVS     r0,#4                 ;1135
000036  e7ef              B        |L8.24|
                  |L8.56|
000038  6820              LDR      r0,[r4,#0]            ;1138
00003a  7880              LDRB     r0,[r0,#2]            ;1138
00003c  1e40              SUBS     r0,r0,#1              ;1138
00003e  ea001016          AND      r0,r0,r6,LSR #4       ;1138
000042  b9c0              CBNZ     r0,|L8.118|
000044  68e1              LDR      r1,[r4,#0xc]          ;1139
000046  6820              LDR      r0,[r4,#0]            ;1139
000048  f7fffffe          BL       get_fat
00004c  4605              MOV      r5,r0                 ;1139
00004e  2d01              CMP      r5,#1                 ;1140
000050  d801              BHI      |L8.86|
000052  2002              MOVS     r0,#2                 ;1140
000054  e7e0              B        |L8.24|
                  |L8.86|
000056  1c68              ADDS     r0,r5,#1              ;1141
000058  b908              CBNZ     r0,|L8.94|
00005a  2001              MOVS     r0,#1                 ;1141
00005c  e7dc              B        |L8.24|
                  |L8.94|
00005e  6820              LDR      r0,[r4,#0]            ;1142
000060  6900              LDR      r0,[r0,#0x10]         ;1142
000062  42a8              CMP      r0,r5                 ;1142
000064  d801              BHI      |L8.106|
000066  2004              MOVS     r0,#4                 ;1161
000068  e7d6              B        |L8.24|
                  |L8.106|
00006a  60e5              STR      r5,[r4,#0xc]          ;1164
00006c  4629              MOV      r1,r5                 ;1165
00006e  6820              LDR      r0,[r4,#0]            ;1165
000070  f7fffffe          BL       clust2sect
000074  6120              STR      r0,[r4,#0x10]         ;1165
                  |L8.118|
000076  80e6              STRH     r6,[r4,#6]            ;1170
000078  6820              LDR      r0,[r4,#0]            ;1171
00007a  3028              ADDS     r0,r0,#0x28           ;1171
00007c  f006010f          AND      r1,r6,#0xf            ;1171
000080  eb001041          ADD      r0,r0,r1,LSL #5       ;1171
000084  6160              STR      r0,[r4,#0x14]         ;1171
000086  2000              MOVS     r0,#0                 ;1173
000088  e7c6              B        |L8.24|
;;;1175   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1450   static
;;;1451   FRESULT dir_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1452   	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
;;;1453   )
;;;1454   {
000004  4604              MOV      r4,r0
;;;1455   	FRESULT res;
;;;1456   	BYTE c, *dir;
;;;1457   #if _USE_LFN
;;;1458   	BYTE a, ord = 0xFF, sum = 0xFF;
000006  f04f09ff          MOV      r9,#0xff
00000a  46ca              MOV      r10,r9
;;;1459   #endif
;;;1460   
;;;1461   	res = FR_NO_FILE;
00000c  2704              MOVS     r7,#4
;;;1462   	while (dj->sect) {
00000e  e04b              B        |L9.168|
                  |L9.16|
;;;1463   		res = move_window(dj->fs, dj->sect);
000010  6921              LDR      r1,[r4,#0x10]
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       move_window
000018  4607              MOV      r7,r0
;;;1464   		if (res != FR_OK) break;
00001a  b107              CBZ      r7,|L9.30|
00001c  e047              B        |L9.174|
                  |L9.30|
;;;1465   		dir = dj->dir;					/* Ptr to the directory entry of current index */
00001e  6965              LDR      r5,[r4,#0x14]
;;;1466   		c = dir[DIR_Name];
000020  782e              LDRB     r6,[r5,#0]
;;;1467   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000022  b90e              CBNZ     r6,|L9.40|
000024  2704              MOVS     r7,#4
000026  e042              B        |L9.174|
                  |L9.40|
;;;1468   #if _USE_LFN	/* LFN configuration */
;;;1469   		a = dir[DIR_Attr] & AM_MASK;
000028  7ae8              LDRB     r0,[r5,#0xb]
00002a  f000083f          AND      r8,r0,#0x3f
;;;1470   		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
00002e  2ee5              CMP      r6,#0xe5
000030  d006              BEQ      |L9.64|
000032  bf00              NOP      
000034  f0080008          AND      r0,r8,#8
000038  b128              CBZ      r0,|L9.70|
00003a  f1b80f0f          CMP      r8,#0xf
00003e  d002              BEQ      |L9.70|
                  |L9.64|
;;;1471   			ord = 0xFF;
000040  f04f09ff          MOV      r9,#0xff
000044  e029              B        |L9.154|
                  |L9.70|
;;;1472   		} else {
;;;1473   			if (a == AM_LFN) {			/* An LFN entry is found */
000046  f1b80f0f          CMP      r8,#0xf
00004a  d11a              BNE      |L9.130|
;;;1474   				if (c & LLE) {			/* Is it start of LFN sequence? */
00004c  f0060040          AND      r0,r6,#0x40
000050  b130              CBZ      r0,|L9.96|
;;;1475   					sum = dir[LDIR_Chksum];
000052  f895a00d          LDRB     r10,[r5,#0xd]
;;;1476   					c &= ~LLE; ord = c;
000056  f0260640          BIC      r6,r6,#0x40
00005a  46b1              MOV      r9,r6
;;;1477   					dj->lfn_idx = dj->index;
00005c  88e0              LDRH     r0,[r4,#6]
00005e  8420              STRH     r0,[r4,#0x20]
                  |L9.96|
;;;1478   				}
;;;1479   				/* Check LFN validity and capture it */
;;;1480   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
000060  454e              CMP      r6,r9
000062  d10a              BNE      |L9.122|
000064  7b68              LDRB     r0,[r5,#0xd]
000066  4550              CMP      r0,r10
000068  d107              BNE      |L9.122|
00006a  4629              MOV      r1,r5
00006c  69e0              LDR      r0,[r4,#0x1c]
00006e  f7fffffe          BL       pick_lfn
000072  b110              CBZ      r0,|L9.122|
000074  f1a90001          SUB      r0,r9,#1
000078  e000              B        |L9.124|
                  |L9.122|
00007a  20ff              MOVS     r0,#0xff
                  |L9.124|
00007c  f00009ff          AND      r9,r0,#0xff
000080  e00b              B        |L9.154|
                  |L9.130|
;;;1481   			} else {					/* An SFN entry is found */
;;;1482   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
000082  f1b90f00          CMP      r9,#0
000086  d104              BNE      |L9.146|
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       sum_sfn
00008e  4550              CMP      r0,r10
000090  d002              BEQ      |L9.152|
                  |L9.146|
;;;1483   					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
000092  f64f70ff          MOV      r0,#0xffff
000096  8420              STRH     r0,[r4,#0x20]
                  |L9.152|
;;;1484   				break;
000098  e009              B        |L9.174|
                  |L9.154|
;;;1485   			}
;;;1486   		}
;;;1487   #else		/* Non LFN configuration */
;;;1488   		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
;;;1489   			break;
;;;1490   #endif
;;;1491   		res = dir_next(dj, 0);				/* Next entry */
00009a  2100              MOVS     r1,#0
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       dir_next
0000a2  4607              MOV      r7,r0
;;;1492   		if (res != FR_OK) break;
0000a4  b107              CBZ      r7,|L9.168|
0000a6  e002              B        |L9.174|
                  |L9.168|
0000a8  6920              LDR      r0,[r4,#0x10]         ;1462
0000aa  2800              CMP      r0,#0                 ;1462
0000ac  d1b0              BNE      |L9.16|
                  |L9.174|
0000ae  bf00              NOP                            ;1464
;;;1493   	}
;;;1494   
;;;1495   	if (res != FR_OK) dj->sect = 0;
0000b0  b10f              CBZ      r7,|L9.182|
0000b2  2000              MOVS     r0,#0
0000b4  6120              STR      r0,[r4,#0x10]
                  |L9.182|
;;;1496   
;;;1497   	return res;
0000b6  4638              MOV      r0,r7
;;;1498   }
0000b8  e8bd87f0          POP      {r4-r10,pc}
;;;1499   #endif
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1067   static
;;;1068   FRESULT dir_sdi (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1069   	DIR *dj,		/* Pointer to directory object */
;;;1070   	WORD idx		/* Index of directory table */
;;;1071   )
;;;1072   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1073   	DWORD clst;
;;;1074   	WORD ic;
;;;1075   
;;;1076   
;;;1077   	dj->index = idx;
000008  80e6              STRH     r6,[r4,#6]
;;;1078   	clst = dj->sclust;
00000a  68a5              LDR      r5,[r4,#8]
;;;1079   	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
00000c  2d01              CMP      r5,#1
00000e  d003              BEQ      |L10.24|
000010  6820              LDR      r0,[r4,#0]
000012  6900              LDR      r0,[r0,#0x10]
000014  42a8              CMP      r0,r5
000016  d802              BHI      |L10.30|
                  |L10.24|
;;;1080   		return FR_INT_ERR;
000018  2002              MOVS     r0,#2
                  |L10.26|
;;;1081   	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
;;;1082   		clst = dj->fs->dirbase;
;;;1083   
;;;1084   	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
;;;1085   		dj->clust = clst;
;;;1086   		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
;;;1087   			return FR_INT_ERR;
;;;1088   		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1089   	}
;;;1090   	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
;;;1091   		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
;;;1092   		while (idx >= ic) {	/* Follow cluster chain */
;;;1093   			clst = get_fat(dj->fs, clst);				/* Get next cluster */
;;;1094   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
;;;1095   			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
;;;1096   				return FR_INT_ERR;
;;;1097   			idx -= ic;
;;;1098   		}
;;;1099   		dj->clust = clst;
;;;1100   		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1101   	}
;;;1102   
;;;1103   	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
;;;1104   
;;;1105   	return FR_OK;	/* Seek succeeded */
;;;1106   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L10.30|
00001e  b92d              CBNZ     r5,|L10.44|
000020  6820              LDR      r0,[r4,#0]            ;1081
000022  7800              LDRB     r0,[r0,#0]            ;1081
000024  2803              CMP      r0,#3                 ;1081
000026  d101              BNE      |L10.44|
000028  6820              LDR      r0,[r4,#0]            ;1082
00002a  69c5              LDR      r5,[r0,#0x1c]         ;1082
                  |L10.44|
00002c  b965              CBNZ     r5,|L10.72|
00002e  60e5              STR      r5,[r4,#0xc]          ;1085
000030  6820              LDR      r0,[r4,#0]            ;1086
000032  8900              LDRH     r0,[r0,#8]            ;1086
000034  42b0              CMP      r0,r6                 ;1086
000036  dc01              BGT      |L10.60|
000038  2002              MOVS     r0,#2                 ;1087
00003a  e7ee              B        |L10.26|
                  |L10.60|
00003c  6820              LDR      r0,[r4,#0]            ;1088
00003e  69c0              LDR      r0,[r0,#0x1c]         ;1088
000040  eb001016          ADD      r0,r0,r6,LSR #4       ;1088
000044  6120              STR      r0,[r4,#0x10]         ;1088
000046  e020              B        |L10.138|
                  |L10.72|
000048  6820              LDR      r0,[r4,#0]            ;1091
00004a  7880              LDRB     r0,[r0,#2]            ;1091
00004c  0107              LSLS     r7,r0,#4              ;1091
00004e  e012              B        |L10.118|
                  |L10.80|
000050  4629              MOV      r1,r5                 ;1093
000052  6820              LDR      r0,[r4,#0]            ;1093
000054  f7fffffe          BL       get_fat
000058  4605              MOV      r5,r0                 ;1093
00005a  1c68              ADDS     r0,r5,#1              ;1094
00005c  b908              CBNZ     r0,|L10.98|
00005e  2001              MOVS     r0,#1                 ;1094
000060  e7db              B        |L10.26|
                  |L10.98|
000062  2d02              CMP      r5,#2                 ;1095
000064  d303              BCC      |L10.110|
000066  6820              LDR      r0,[r4,#0]            ;1095
000068  6900              LDR      r0,[r0,#0x10]         ;1095
00006a  42a8              CMP      r0,r5                 ;1095
00006c  d801              BHI      |L10.114|
                  |L10.110|
00006e  2002              MOVS     r0,#2                 ;1096
000070  e7d3              B        |L10.26|
                  |L10.114|
000072  1bf0              SUBS     r0,r6,r7              ;1097
000074  b286              UXTH     r6,r0                 ;1097
                  |L10.118|
000076  42be              CMP      r6,r7                 ;1092
000078  daea              BGE      |L10.80|
00007a  60e5              STR      r5,[r4,#0xc]          ;1099
00007c  4629              MOV      r1,r5                 ;1100
00007e  6820              LDR      r0,[r4,#0]            ;1100
000080  f7fffffe          BL       clust2sect
000084  eb001016          ADD      r0,r0,r6,LSR #4       ;1100
000088  6120              STR      r0,[r4,#0x10]         ;1100
                  |L10.138|
00008a  6820              LDR      r0,[r4,#0]            ;1103
00008c  3028              ADDS     r0,r0,#0x28           ;1103
00008e  f006010f          AND      r1,r6,#0xf            ;1103
000092  eb001041          ADD      r0,r0,r1,LSL #5       ;1103
000096  6160              STR      r0,[r4,#0x14]         ;1103
000098  2000              MOVS     r0,#0                 ;1105
00009a  e7be              B        |L10.26|
;;;1107   
                          ENDP


                          AREA ||i.f_chdir||, CODE, READONLY, ALIGN=1

                  f_chdir PROC
;;;2743   
;;;2744   FRESULT f_chdir (
000000  b511              PUSH     {r0,r4,lr}
;;;2745   	const TCHAR *path	/* Pointer to the directory path */
;;;2746   )
;;;2747   {
000002  f5ad7d0d          SUB      sp,sp,#0x234
;;;2748   	FRESULT res;
;;;2749   	DIR dj;
;;;2750   	DEF_NAMEBUF;
;;;2751   
;;;2752   
;;;2753   	res = chk_mounted(&path, &dj.fs, 0);
000006  2200              MOVS     r2,#0
000008  a984              ADD      r1,sp,#0x210
00000a  a88d              ADD      r0,sp,#0x234
00000c  f7fffffe          BL       chk_mounted
000010  4604              MOV      r4,r0
;;;2754   	if (res == FR_OK) {
000012  b9fc              CBNZ     r4,|L11.84|
;;;2755   		INIT_BUF(dj);
000014  a881              ADD      r0,sp,#0x204
000016  908a              STR      r0,[sp,#0x228]
000018  a801              ADD      r0,sp,#4
00001a  908b              STR      r0,[sp,#0x22c]
;;;2756   		res = follow_path(&dj, path);		/* Follow the path */
00001c  a884              ADD      r0,sp,#0x210
00001e  998d              LDR      r1,[sp,#0x234]
000020  f7fffffe          BL       follow_path
000024  4604              MOV      r4,r0
;;;2757   		FREE_BUF();
;;;2758   		if (res == FR_OK) {					/* Follow completed */
000026  b994              CBNZ     r4,|L11.78|
;;;2759   			if (!dj.dir) {
000028  9889              LDR      r0,[sp,#0x224]
00002a  b918              CBNZ     r0,|L11.52|
;;;2760   				dj.fs->cdir = dj.sclust;	/* Start directory itself */
00002c  9984              LDR      r1,[sp,#0x210]
00002e  9886              LDR      r0,[sp,#0x218]
000030  60c8              STR      r0,[r1,#0xc]
000032  e00c              B        |L11.78|
                  |L11.52|
;;;2761   			} else {
;;;2762   				if (dj.dir[DIR_Attr] & AM_DIR)	/* Reached to the directory */
000034  9889              LDR      r0,[sp,#0x224]
000036  7ac0              LDRB     r0,[r0,#0xb]
000038  f0000010          AND      r0,r0,#0x10
00003c  b130              CBZ      r0,|L11.76|
;;;2763   					dj.fs->cdir = ld_clust(dj.fs, dj.dir);
00003e  9989              LDR      r1,[sp,#0x224]
000040  9884              LDR      r0,[sp,#0x210]
000042  f7fffffe          BL       ld_clust
000046  9984              LDR      r1,[sp,#0x210]
000048  60c8              STR      r0,[r1,#0xc]
00004a  e000              B        |L11.78|
                  |L11.76|
;;;2764   				else
;;;2765   					res = FR_NO_PATH;		/* Reached but a file */
00004c  2405              MOVS     r4,#5
                  |L11.78|
;;;2766   			}
;;;2767   		}
;;;2768   		if (res == FR_NO_FILE) res = FR_NO_PATH;
00004e  2c04              CMP      r4,#4
000050  d100              BNE      |L11.84|
000052  2405              MOVS     r4,#5
                  |L11.84|
;;;2769   	}
;;;2770   
;;;2771   	LEAVE_FF(dj.fs, res);
000054  4620              MOV      r0,r4
;;;2772   }
000056  f50d7d0e          ADD      sp,sp,#0x238
00005a  bd10              POP      {r4,pc}
;;;2773   
                          ENDP


                          AREA ||i.f_chdrive||, CODE, READONLY, ALIGN=2

                  f_chdrive PROC
;;;2730   
;;;2731   FRESULT f_chdrive (
000000  4601              MOV      r1,r0
;;;2732   	BYTE drv		/* Drive number */
;;;2733   )
;;;2734   {
;;;2735   	if (drv >= _VOLUMES) return FR_INVALID_DRIVE;
000002  2902              CMP      r1,#2
000004  db01              BLT      |L12.10|
000006  200b              MOVS     r0,#0xb
                  |L12.8|
;;;2736   
;;;2737   	CurrVol = drv;
;;;2738   
;;;2739   	return FR_OK;
;;;2740   }
000008  4770              BX       lr
                  |L12.10|
00000a  4802              LDR      r0,|L12.20|
00000c  7001              STRB     r1,[r0,#0]            ;2737
00000e  2000              MOVS     r0,#0                 ;2739
000010  e7fa              B        |L12.8|
;;;2741   
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      CurrVol

                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2684   
;;;2685   FRESULT f_close (
000000  b570              PUSH     {r4-r6,lr}
;;;2686   	FIL *fp		/* Pointer to the file object to be closed */
;;;2687   )
;;;2688   {
000002  4604              MOV      r4,r0
;;;2689   	FRESULT res;
;;;2690   
;;;2691   
;;;2692   #if _FS_READONLY
;;;2693   	res = validate(fp);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       validate
00000a  4605              MOV      r5,r0
;;;2694   	{
;;;2695   #if _FS_REENTRANT
;;;2696   		FATFS *fs = fp->fs;
;;;2697   #endif
;;;2698   		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
00000c  b90d              CBNZ     r5,|L13.18|
00000e  2000              MOVS     r0,#0
000010  6020              STR      r0,[r4,#0]
                  |L13.18|
;;;2699   		LEAVE_FF(fs, res);
000012  4628              MOV      r0,r5
;;;2700   	}
;;;2701   #else
;;;2702   	res = f_sync(fp);		/* Flush cached data */
;;;2703   #if _FS_LOCK
;;;2704   	if (res == FR_OK) {		/* Decrement open counter */
;;;2705   #if _FS_REENTRANT
;;;2706   		FATFS *fs = fp->fs;;
;;;2707   		res = validate(fp);
;;;2708   		if (res == FR_OK) {
;;;2709   			res = dec_lock(fp->lockid);	
;;;2710   			unlock_fs(fs, FR_OK);
;;;2711   		}
;;;2712   #else
;;;2713   		res = dec_lock(fp->lockid);
;;;2714   #endif
;;;2715   	}
;;;2716   #endif
;;;2717   	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
;;;2718   	return res;
;;;2719   #endif
;;;2720   }
000014  bd70              POP      {r4-r6,pc}
;;;2721   
                          ENDP


                          AREA ||i.f_getcwd||, CODE, READONLY, ALIGN=2

                  f_getcwd PROC
;;;2775   #if _FS_RPATH >= 2
;;;2776   FRESULT f_getcwd (
000000  e92d43f3          PUSH     {r0,r1,r4-r9,lr}
;;;2777   	TCHAR *path,	/* Pointer to the directory path */
;;;2778   	UINT sz_path	/* Size of path */
;;;2779   )
;;;2780   {
000004  f5ad7d15          SUB      sp,sp,#0x254
000008  4688              MOV      r8,r1
;;;2781   	FRESULT res;
;;;2782   	DIR dj;
;;;2783   	UINT i, n;
;;;2784   	DWORD ccl;
;;;2785   	TCHAR *tp;
;;;2786   	FILINFO fno;
;;;2787   	DEF_NAMEBUF;
;;;2788   
;;;2789   
;;;2790   	*path = 0;
00000a  2000              MOVS     r0,#0
00000c  9995              LDR      r1,[sp,#0x254]
00000e  7008              STRB     r0,[r1,#0]
;;;2791   	res = chk_mounted((const TCHAR**)&path, &dj.fs, 0);	/* Get current volume */
000010  2200              MOVS     r2,#0
000012  a98c              ADD      r1,sp,#0x230
000014  a895              ADD      r0,sp,#0x254
000016  f7fffffe          BL       chk_mounted
00001a  4605              MOV      r5,r0
;;;2792   	if (res == FR_OK) {
00001c  2d00              CMP      r5,#0
00001e  d179              BNE      |L14.276|
;;;2793   		INIT_BUF(dj);
000020  a881              ADD      r0,sp,#0x204
000022  9092              STR      r0,[sp,#0x248]
000024  a801              ADD      r0,sp,#4
000026  9093              STR      r0,[sp,#0x24c]
;;;2794   		i = sz_path;		/* Bottom of buffer (dir stack base) */
000028  4646              MOV      r6,r8
;;;2795   		dj.sclust = dj.fs->cdir;			/* Start to follow upper dir from current dir */
00002a  988c              LDR      r0,[sp,#0x230]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  908e              STR      r0,[sp,#0x238]
;;;2796   		while ((ccl = dj.sclust) != 0) {	/* Repeat while current dir is a sub-dir */
000030  e05a              B        |L14.232|
                  |L14.50|
;;;2797   			res = dir_sdi(&dj, 1);			/* Get parent dir */
000032  2101              MOVS     r1,#1
000034  a88c              ADD      r0,sp,#0x230
000036  f7fffffe          BL       dir_sdi
00003a  4605              MOV      r5,r0
;;;2798   			if (res != FR_OK) break;
00003c  b105              CBZ      r5,|L14.64|
00003e  e058              B        |L14.242|
                  |L14.64|
;;;2799   			res = dir_read(&dj);
000040  a88c              ADD      r0,sp,#0x230
000042  f7fffffe          BL       dir_read
000046  4605              MOV      r5,r0
;;;2800   			if (res != FR_OK) break;
000048  b105              CBZ      r5,|L14.76|
00004a  e052              B        |L14.242|
                  |L14.76|
;;;2801   			dj.sclust = ld_clust(dj.fs, dj.dir);	/* Goto parent dir */
00004c  9991              LDR      r1,[sp,#0x244]
00004e  988c              LDR      r0,[sp,#0x230]
000050  f7fffffe          BL       ld_clust
000054  908e              STR      r0,[sp,#0x238]
;;;2802   			res = dir_sdi(&dj, 0);
000056  2100              MOVS     r1,#0
000058  a88c              ADD      r0,sp,#0x230
00005a  f7fffffe          BL       dir_sdi
00005e  4605              MOV      r5,r0
;;;2803   			if (res != FR_OK) break;
000060  b105              CBZ      r5,|L14.100|
000062  e046              B        |L14.242|
                  |L14.100|
;;;2804   			do {							/* Find the entry links to the child dir */
000064  bf00              NOP      
                  |L14.102|
;;;2805   				res = dir_read(&dj);
000066  a88c              ADD      r0,sp,#0x230
000068  f7fffffe          BL       dir_read
00006c  4605              MOV      r5,r0
;;;2806   				if (res != FR_OK) break;
00006e  b105              CBZ      r5,|L14.114|
000070  e00d              B        |L14.142|
                  |L14.114|
;;;2807   				if (ccl == ld_clust(dj.fs, dj.dir)) break;	/* Found the entry */
000072  9991              LDR      r1,[sp,#0x244]
000074  988c              LDR      r0,[sp,#0x230]
000076  f7fffffe          BL       ld_clust
00007a  4548              CMP      r0,r9
00007c  d100              BNE      |L14.128|
00007e  e006              B        |L14.142|
                  |L14.128|
;;;2808   				res = dir_next(&dj, 0);	
000080  2100              MOVS     r1,#0
000082  a88c              ADD      r0,sp,#0x230
000084  f7fffffe          BL       dir_next
000088  4605              MOV      r5,r0
;;;2809   			} while (res == FR_OK);
00008a  2d00              CMP      r5,#0
00008c  d0eb              BEQ      |L14.102|
                  |L14.142|
00008e  bf00              NOP                            ;2806
;;;2810   			if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
000090  2d04              CMP      r5,#4
000092  d100              BNE      |L14.150|
000094  2502              MOVS     r5,#2
                  |L14.150|
;;;2811   			if (res != FR_OK) break;
000096  b105              CBZ      r5,|L14.154|
000098  e02b              B        |L14.242|
                  |L14.154|
;;;2812   #if _USE_LFN
;;;2813   			fno.lfname = path;
00009a  9895              LDR      r0,[sp,#0x254]
00009c  908a              STR      r0,[sp,#0x228]
;;;2814   			fno.lfsize = i;
00009e  968b              STR      r6,[sp,#0x22c]
;;;2815   #endif
;;;2816   			get_fileinfo(&dj, &fno);		/* Get the dir name and push it to the buffer */
0000a0  a984              ADD      r1,sp,#0x210
0000a2  a88c              ADD      r0,sp,#0x230
0000a4  f7fffffe          BL       get_fileinfo
;;;2817   			tp = fno.fname;
0000a8  f20d2419          ADD      r4,sp,#0x219
;;;2818   			if (_USE_LFN && *path) tp = path;
0000ac  9895              LDR      r0,[sp,#0x254]
0000ae  7800              LDRB     r0,[r0,#0]
0000b0  b100              CBZ      r0,|L14.180|
0000b2  9c95              LDR      r4,[sp,#0x254]
                  |L14.180|
;;;2819   			for (n = 0; tp[n]; n++) ;
0000b4  2700              MOVS     r7,#0
0000b6  e000              B        |L14.186|
                  |L14.184|
0000b8  1c7f              ADDS     r7,r7,#1
                  |L14.186|
0000ba  5de0              LDRB     r0,[r4,r7]
0000bc  2800              CMP      r0,#0
0000be  d1fb              BNE      |L14.184|
;;;2820   			if (i < n + 3) {
0000c0  1cf8              ADDS     r0,r7,#3
0000c2  4286              CMP      r6,r0
0000c4  d201              BCS      |L14.202|
;;;2821   				res = FR_NOT_ENOUGH_CORE; break;
0000c6  2511              MOVS     r5,#0x11
0000c8  e013              B        |L14.242|
                  |L14.202|
;;;2822   			}
;;;2823   			while (n) path[--i] = tp[--n];
0000ca  e006              B        |L14.218|
                  |L14.204|
0000cc  1e78              SUBS     r0,r7,#1
0000ce  4607              MOV      r7,r0
0000d0  5c21              LDRB     r1,[r4,r0]
0000d2  1e70              SUBS     r0,r6,#1
0000d4  4606              MOV      r6,r0
0000d6  9a95              LDR      r2,[sp,#0x254]
0000d8  5411              STRB     r1,[r2,r0]
                  |L14.218|
0000da  2f00              CMP      r7,#0
0000dc  d1f6              BNE      |L14.204|
;;;2824   			path[--i] = '/';
0000de  212f              MOVS     r1,#0x2f
0000e0  1e70              SUBS     r0,r6,#1
0000e2  4606              MOV      r6,r0
0000e4  9a95              LDR      r2,[sp,#0x254]
0000e6  5411              STRB     r1,[r2,r0]
                  |L14.232|
0000e8  f8dd9238          LDR      r9,[sp,#0x238]        ;2796
0000ec  f1b90f00          CMP      r9,#0                 ;2796
0000f0  d19f              BNE      |L14.50|
                  |L14.242|
0000f2  bf00              NOP                            ;2798
;;;2825   		}
;;;2826   		tp = path;
0000f4  9c95              LDR      r4,[sp,#0x254]
;;;2827   		if (res == FR_OK) {
0000f6  b9bd              CBNZ     r5,|L14.296|
;;;2828   			*tp++ = '0' + CurrVol;			/* Put drive number */
0000f8  480f              LDR      r0,|L14.312|
0000fa  7800              LDRB     r0,[r0,#0]  ; CurrVol
0000fc  3030              ADDS     r0,r0,#0x30
0000fe  f8040b01          STRB     r0,[r4],#1
;;;2829   			*tp++ = ':';
000102  203a              MOVS     r0,#0x3a
000104  f8040b01          STRB     r0,[r4],#1
;;;2830   			if (i == sz_path) {				/* Root-dir */
000108  4546              CMP      r6,r8
00010a  d104              BNE      |L14.278|
;;;2831   				*tp++ = '/';
00010c  202f              MOVS     r0,#0x2f
00010e  f8040b01          STRB     r0,[r4],#1
000112  e009              B        |L14.296|
                  |L14.276|
000114  e00a              B        |L14.300|
                  |L14.278|
;;;2832   			} else {						/* Sub-dir */
;;;2833   				do		/* Add stacked path str */
000116  bf00              NOP      
                  |L14.280|
;;;2834   					*tp++ = path[i++];
000118  4630              MOV      r0,r6
00011a  1c76              ADDS     r6,r6,#1
00011c  9995              LDR      r1,[sp,#0x254]
00011e  5c08              LDRB     r0,[r1,r0]
000120  f8040b01          STRB     r0,[r4],#1
;;;2835   				while (i < sz_path);
000124  4546              CMP      r6,r8
000126  d3f7              BCC      |L14.280|
                  |L14.296|
;;;2836   			}
;;;2837   		}
;;;2838   		*tp = 0;
000128  2000              MOVS     r0,#0
00012a  7020              STRB     r0,[r4,#0]
                  |L14.300|
;;;2839   		FREE_BUF();
;;;2840   	}
;;;2841   
;;;2842   	LEAVE_FF(dj.fs, res);
00012c  4628              MOV      r0,r5
;;;2843   }
00012e  f50d7d17          ADD      sp,sp,#0x25c
000132  e8bd83f0          POP      {r4-r9,pc}
;;;2844   #endif /* _FS_RPATH >= 2 */
                          ENDP

000136  0000              DCW      0x0000
                  |L14.312|
                          DCD      CurrVol

                          AREA ||i.f_gets||, CODE, READONLY, ALIGN=1

                  f_gets PROC
;;;3936   /*-----------------------------------------------------------------------*/
;;;3937   TCHAR* f_gets (
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;3938   	TCHAR* buff,	/* Pointer to the string buffer to read */
;;;3939   	int len,		/* Size of string buffer (characters) */
;;;3940   	FIL* fil		/* Pointer to the file object */
;;;3941   )
;;;3942   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;3943   	int n = 0;
00000a  2400              MOVS     r4,#0
;;;3944   	TCHAR c, *p = buff;
00000c  463e              MOV      r6,r7
;;;3945   	BYTE s[2];
;;;3946   	UINT rc;
;;;3947   
;;;3948   	while (n < len - 1) {			/* Read bytes until buffer gets filled */
00000e  e011              B        |L15.52|
                  |L15.16|
;;;3949   		f_read(fil, s, 1, &rc);
000010  466b              MOV      r3,sp
000012  2201              MOVS     r2,#1
000014  a901              ADD      r1,sp,#4
000016  4648              MOV      r0,r9
000018  f7fffffe          BL       f_read
;;;3950   		if (rc != 1) break;			/* Break on EOF or error */
00001c  9800              LDR      r0,[sp,#0]
00001e  2801              CMP      r0,#1
000020  d000              BEQ      |L15.36|
000022  e00b              B        |L15.60|
                  |L15.36|
;;;3951   		c = s[0];
000024  f89d5004          LDRB     r5,[sp,#4]
;;;3952   #if _LFN_UNICODE					/* Read a character in UTF-8 encoding */
;;;3953   		if (c >= 0x80) {
;;;3954   			if (c < 0xC0) continue;	/* Skip stray trailer */
;;;3955   			if (c < 0xE0) {			/* Two-byte sequence */
;;;3956   				f_read(fil, s, 1, &rc);
;;;3957   				if (rc != 1) break;
;;;3958   				c = ((c & 0x1F) << 6) | (s[0] & 0x3F);
;;;3959   				if (c < 0x80) c = '?';
;;;3960   			} else {
;;;3961   				if (c < 0xF0) {		/* Three-byte sequence */
;;;3962   					f_read(fil, s, 2, &rc);
;;;3963   					if (rc != 2) break;
;;;3964   					c = (c << 12) | ((s[0] & 0x3F) << 6) | (s[1] & 0x3F);
;;;3965   					if (c < 0x800) c = '?';
;;;3966   				} else {			/* Reject four-byte sequence */
;;;3967   					c = '?';
;;;3968   				}
;;;3969   			}
;;;3970   		}
;;;3971   #endif
;;;3972   #if _USE_STRFUNC >= 2
;;;3973   		if (c == '\r') continue;	/* Strip '\r' */
;;;3974   #endif
;;;3975   		*p++ = c;
000028  f8065b01          STRB     r5,[r6],#1
;;;3976   		n++;
00002c  1c64              ADDS     r4,r4,#1
;;;3977   		if (c == '\n') break;		/* Break on EOL */
00002e  2d0a              CMP      r5,#0xa
000030  d100              BNE      |L15.52|
000032  e003              B        |L15.60|
                  |L15.52|
000034  f1a80001          SUB      r0,r8,#1              ;3948
000038  42a0              CMP      r0,r4                 ;3948
00003a  dce9              BGT      |L15.16|
                  |L15.60|
00003c  bf00              NOP                            ;3950
;;;3978   	}
;;;3979   	*p = 0;
00003e  2000              MOVS     r0,#0
000040  7030              STRB     r0,[r6,#0]
;;;3980   	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
000042  b114              CBZ      r4,|L15.74|
000044  4638              MOV      r0,r7
                  |L15.70|
;;;3981   }
000046  e8bd87fc          POP      {r2-r10,pc}
                  |L15.74|
00004a  2000              MOVS     r0,#0                 ;3980
00004c  e7fb              B        |L15.70|
;;;3982   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;2853   
;;;2854   FRESULT f_lseek (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2855   	FIL *fp,		/* Pointer to the file object */
;;;2856   	DWORD ofs		/* File pointer from top of file */
;;;2857   )
;;;2858   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;2859   	FRESULT res;
;;;2860   
;;;2861   
;;;2862   	res = validate(fp);					/* Check validity of the object */
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       validate
00000e  4682              MOV      r10,r0
;;;2863   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  f1ba0f00          CMP      r10,#0
000014  d002              BEQ      |L16.28|
000016  4650              MOV      r0,r10
                  |L16.24|
;;;2864   	if (fp->flag & FA__ERROR)			/* Check abort flag */
;;;2865   		LEAVE_FF(fp->fs, FR_INT_ERR);
;;;2866   
;;;2867   #if _USE_FASTSEEK
;;;2868   	if (fp->cltbl) {	/* Fast seek */
;;;2869   		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;2870   
;;;2871   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;2872   			tbl = fp->cltbl;
;;;2873   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;2874   			cl = fp->sclust;			/* Top of the chain */
;;;2875   			if (cl) {
;;;2876   				do {
;;;2877   					/* Get a fragment */
;;;2878   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;2879   					do {
;;;2880   						pcl = cl; ncl++;
;;;2881   						cl = get_fat(fp->fs, cl);
;;;2882   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;2883   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2884   					} while (cl == pcl + 1);
;;;2885   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;2886   						*tbl++ = ncl; *tbl++ = tcl;
;;;2887   					}
;;;2888   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;2889   			}
;;;2890   			*fp->cltbl = ulen;	/* Number of items used */
;;;2891   			if (ulen <= tlen)
;;;2892   				*tbl = 0;		/* Terminate table */
;;;2893   			else
;;;2894   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;2895   
;;;2896   		} else {						/* Fast seek */
;;;2897   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;2898   				ofs = fp->fsize;
;;;2899   			fp->fptr = ofs;				/* Set file pointer */
;;;2900   			if (ofs) {
;;;2901   				fp->clust = clmt_clust(fp, ofs - 1);
;;;2902   				dsc = clust2sect(fp->fs, fp->clust);
;;;2903   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;2904   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;2905   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;2906   #if !_FS_TINY
;;;2907   #if !_FS_READONLY
;;;2908   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2909   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2910   							ABORT(fp->fs, FR_DISK_ERR);
;;;2911   						fp->flag &= ~FA__DIRTY;
;;;2912   					}
;;;2913   #endif
;;;2914   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;2915   						ABORT(fp->fs, FR_DISK_ERR);
;;;2916   #endif
;;;2917   					fp->dsect = dsc;
;;;2918   				}
;;;2919   			}
;;;2920   		}
;;;2921   	} else
;;;2922   #endif
;;;2923   
;;;2924   	/* Normal Seek */
;;;2925   	{
;;;2926   		DWORD clst, bcs, nsect, ifptr;
;;;2927   
;;;2928   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;2929   #if !_FS_READONLY
;;;2930   			 && !(fp->flag & FA_WRITE)
;;;2931   #endif
;;;2932   			) ofs = fp->fsize;
;;;2933   
;;;2934   		ifptr = fp->fptr;
;;;2935   		fp->fptr = nsect = 0;
;;;2936   		if (ofs) {
;;;2937   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;2938   			if (ifptr > 0 &&
;;;2939   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;2940   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;2941   				ofs -= fp->fptr;
;;;2942   				clst = fp->clust;
;;;2943   			} else {									/* When seek to back cluster, */
;;;2944   				clst = fp->sclust;						/* start from the first cluster */
;;;2945   #if !_FS_READONLY
;;;2946   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;2947   					clst = create_chain(fp->fs, 0);
;;;2948   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2949   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2950   					fp->sclust = clst;
;;;2951   				}
;;;2952   #endif
;;;2953   				fp->clust = clst;
;;;2954   			}
;;;2955   			if (clst != 0) {
;;;2956   				while (ofs > bcs) {						/* Cluster following loop */
;;;2957   #if !_FS_READONLY
;;;2958   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;2959   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;;;2960   						if (clst == 0) {				/* When disk gets full, clip file size */
;;;2961   							ofs = bcs; break;
;;;2962   						}
;;;2963   					} else
;;;2964   #endif
;;;2965   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;2966   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2967   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;;;2968   					fp->clust = clst;
;;;2969   					fp->fptr += bcs;
;;;2970   					ofs -= bcs;
;;;2971   				}
;;;2972   				fp->fptr += ofs;
;;;2973   				if (ofs % SS(fp->fs)) {
;;;2974   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;2975   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;2976   					nsect += ofs / SS(fp->fs);
;;;2977   				}
;;;2978   			}
;;;2979   		}
;;;2980   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;;;2981   #if !_FS_TINY
;;;2982   #if !_FS_READONLY
;;;2983   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;;;2984   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2985   					ABORT(fp->fs, FR_DISK_ERR);
;;;2986   				fp->flag &= ~FA__DIRTY;
;;;2987   			}
;;;2988   #endif
;;;2989   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;2990   				ABORT(fp->fs, FR_DISK_ERR);
;;;2991   #endif
;;;2992   			fp->dsect = nsect;
;;;2993   		}
;;;2994   #if !_FS_READONLY
;;;2995   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;2996   			fp->fsize = fp->fptr;
;;;2997   			fp->flag |= FA__WRITTEN;
;;;2998   		}
;;;2999   #endif
;;;3000   	}
;;;3001   
;;;3002   	LEAVE_FF(fp->fs, res);
;;;3003   }
000018  e8bd87f0          POP      {r4-r10,pc}
                  |L16.28|
00001c  79a0              LDRB     r0,[r4,#6]            ;2864
00001e  f0000080          AND      r0,r0,#0x80           ;2864
000022  b108              CBZ      r0,|L16.40|
000024  2002              MOVS     r0,#2                 ;2865
000026  e7f7              B        |L16.24|
                  |L16.40|
000028  68e0              LDR      r0,[r4,#0xc]          ;2928
00002a  42a8              CMP      r0,r5                 ;2928
00002c  d200              BCS      |L16.48|
00002e  68e5              LDR      r5,[r4,#0xc]          ;2932
                  |L16.48|
000030  f8d49008          LDR      r9,[r4,#8]            ;2934
000034  f04f0800          MOV      r8,#0                 ;2935
000038  f8c48008          STR      r8,[r4,#8]            ;2935
00003c  2d00              CMP      r5,#0                 ;2936
00003e  d052              BEQ      |L16.230|
000040  6820              LDR      r0,[r4,#0]            ;2937
000042  7880              LDRB     r0,[r0,#2]            ;2937
000044  0247              LSLS     r7,r0,#9              ;2937
000046  f1b90f00          CMP      r9,#0                 ;2938
00004a  d011              BEQ      |L16.112|
00004c  1e68              SUBS     r0,r5,#1              ;2939
00004e  fbb0f1f7          UDIV     r1,r0,r7              ;2939
000052  f1a90001          SUB      r0,r9,#1              ;2939
000056  fbb0f0f7          UDIV     r0,r0,r7              ;2939
00005a  4281              CMP      r1,r0                 ;2939
00005c  d308              BCC      |L16.112|
00005e  f1a90001          SUB      r0,r9,#1              ;2940
000062  1e79              SUBS     r1,r7,#1              ;2940
000064  4388              BICS     r0,r0,r1              ;2940
000066  60a0              STR      r0,[r4,#8]            ;2940
000068  68a0              LDR      r0,[r4,#8]            ;2941
00006a  1a2d              SUBS     r5,r5,r0              ;2941
00006c  6966              LDR      r6,[r4,#0x14]         ;2942
00006e  e001              B        |L16.116|
                  |L16.112|
000070  6926              LDR      r6,[r4,#0x10]         ;2944
000072  6166              STR      r6,[r4,#0x14]         ;2953
                  |L16.116|
000074  b3a6              CBZ      r6,|L16.224|
000076  e01d              B        |L16.180|
                  |L16.120|
000078  4631              MOV      r1,r6                 ;2965
00007a  6820              LDR      r0,[r4,#0]            ;2965
00007c  f7fffffe          BL       get_fat
000080  4606              MOV      r6,r0                 ;2965
000082  1c70              ADDS     r0,r6,#1              ;2966
000084  b928              CBNZ     r0,|L16.146|
000086  79a0              LDRB     r0,[r4,#6]            ;2966
000088  f0400080          ORR      r0,r0,#0x80           ;2966
00008c  71a0              STRB     r0,[r4,#6]            ;2966
00008e  2001              MOVS     r0,#1                 ;2966
000090  e7c2              B        |L16.24|
                  |L16.146|
000092  2e01              CMP      r6,#1                 ;2967
000094  d903              BLS      |L16.158|
000096  6820              LDR      r0,[r4,#0]            ;2967
000098  6900              LDR      r0,[r0,#0x10]         ;2967
00009a  42b0              CMP      r0,r6                 ;2967
00009c  d805              BHI      |L16.170|
                  |L16.158|
00009e  79a0              LDRB     r0,[r4,#6]            ;2967
0000a0  f0400080          ORR      r0,r0,#0x80           ;2967
0000a4  71a0              STRB     r0,[r4,#6]            ;2967
0000a6  2002              MOVS     r0,#2                 ;2967
0000a8  e7b6              B        |L16.24|
                  |L16.170|
0000aa  6166              STR      r6,[r4,#0x14]         ;2968
0000ac  68a0              LDR      r0,[r4,#8]            ;2969
0000ae  4438              ADD      r0,r0,r7              ;2969
0000b0  60a0              STR      r0,[r4,#8]            ;2969
0000b2  1bed              SUBS     r5,r5,r7              ;2970
                  |L16.180|
0000b4  42bd              CMP      r5,r7                 ;2956
0000b6  d8df              BHI      |L16.120|
0000b8  68a0              LDR      r0,[r4,#8]            ;2972
0000ba  4428              ADD      r0,r0,r5              ;2972
0000bc  60a0              STR      r0,[r4,#8]            ;2972
0000be  f3c50008          UBFX     r0,r5,#0,#9           ;2973
0000c2  b168              CBZ      r0,|L16.224|
0000c4  4631              MOV      r1,r6                 ;2974
0000c6  6820              LDR      r0,[r4,#0]            ;2974
0000c8  f7fffffe          BL       clust2sect
0000cc  4680              MOV      r8,r0                 ;2974
0000ce  f1b80f00          CMP      r8,#0                 ;2975
0000d2  d106              BNE      |L16.226|
0000d4  79a0              LDRB     r0,[r4,#6]            ;2975
0000d6  f0400080          ORR      r0,r0,#0x80           ;2975
0000da  71a0              STRB     r0,[r4,#6]            ;2975
0000dc  2002              MOVS     r0,#2                 ;2975
0000de  e79b              B        |L16.24|
                  |L16.224|
0000e0  e001              B        |L16.230|
                  |L16.226|
0000e2  eb082855          ADD      r8,r8,r5,LSR #9       ;2976
                  |L16.230|
0000e6  8920              LDRH     r0,[r4,#8]            ;2980
0000e8  f3c00008          UBFX     r0,r0,#0,#9           ;2980
0000ec  b198              CBZ      r0,|L16.278|
0000ee  69a0              LDR      r0,[r4,#0x18]         ;2980
0000f0  4540              CMP      r0,r8                 ;2980
0000f2  d010              BEQ      |L16.278|
0000f4  6821              LDR      r1,[r4,#0]            ;2989
0000f6  7848              LDRB     r0,[r1,#1]            ;2989
0000f8  2301              MOVS     r3,#1                 ;2989
0000fa  4642              MOV      r2,r8                 ;2989
0000fc  f104011c          ADD      r1,r4,#0x1c           ;2989
000100  f7fffffe          BL       disk_read
000104  b128              CBZ      r0,|L16.274|
000106  79a0              LDRB     r0,[r4,#6]            ;2990
000108  f0400080          ORR      r0,r0,#0x80           ;2990
00010c  71a0              STRB     r0,[r4,#6]            ;2990
00010e  2001              MOVS     r0,#1                 ;2990
000110  e782              B        |L16.24|
                  |L16.274|
000112  f8c48018          STR      r8,[r4,#0x18]         ;2992
                  |L16.278|
000116  4650              MOV      r0,r10                ;3002
000118  e77e              B        |L16.24|
;;;3004   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2244   
;;;2245   FRESULT f_mount (
000000  4602              MOV      r2,r0
;;;2246   	BYTE vol,		/* Logical drive number to be mounted/unmounted */
;;;2247   	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
;;;2248   )
;;;2249   {
;;;2250   	FATFS *rfs;
;;;2251   
;;;2252   
;;;2253   	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
000002  2a02              CMP      r2,#2
000004  db01              BLT      |L17.10|
;;;2254   		return FR_INVALID_DRIVE;
000006  200b              MOVS     r0,#0xb
                  |L17.8|
;;;2255   	rfs = FatFs[vol];			/* Get current fs object */
;;;2256   
;;;2257   	if (rfs) {
;;;2258   #if _FS_LOCK
;;;2259   		clear_lock(rfs);
;;;2260   #endif
;;;2261   #if _FS_REENTRANT				/* Discard sync object of the current volume */
;;;2262   		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
;;;2263   #endif
;;;2264   		rfs->fs_type = 0;		/* Clear old fs object */
;;;2265   	}
;;;2266   
;;;2267   	if (fs) {
;;;2268   		fs->fs_type = 0;		/* Clear new fs object */
;;;2269   #if _FS_REENTRANT				/* Create sync object for the new volume */
;;;2270   		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
;;;2271   #endif
;;;2272   	}
;;;2273   	FatFs[vol] = fs;			/* Register new fs object */
;;;2274   
;;;2275   	return FR_OK;
;;;2276   }
000008  4770              BX       lr
                  |L17.10|
00000a  4807              LDR      r0,|L17.40|
00000c  f8503022          LDR      r3,[r0,r2,LSL #2]     ;2255
000010  b10b              CBZ      r3,|L17.22|
000012  2000              MOVS     r0,#0                 ;2264
000014  7018              STRB     r0,[r3,#0]            ;2264
                  |L17.22|
000016  b109              CBZ      r1,|L17.28|
000018  2000              MOVS     r0,#0                 ;2268
00001a  7008              STRB     r0,[r1,#0]            ;2268
                  |L17.28|
00001c  4802              LDR      r0,|L17.40|
00001e  f8401022          STR      r1,[r0,r2,LSL #2]     ;2273
000022  2000              MOVS     r0,#0                 ;2275
000024  e7f0              B        |L17.8|
;;;2277   
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
                          DCD      FatFs

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2284   
;;;2285   FRESULT f_open (
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;2286   	FIL *fp,			/* Pointer to the blank file object */
;;;2287   	const TCHAR *path,	/* Pointer to the file name */
;;;2288   	BYTE mode			/* Access mode and file open mode flags */
;;;2289   )
;;;2290   {
000002  f5ad7d0c          SUB      sp,sp,#0x230
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
;;;2291   	FRESULT res;
;;;2292   	DIR dj;
;;;2293   	BYTE *dir;
;;;2294   	DEF_NAMEBUF;
;;;2295   
;;;2296   
;;;2297   	if (!fp) return FR_INVALID_OBJECT;
00000a  b91c              CBNZ     r4,|L18.20|
00000c  2009              MOVS     r0,#9
                  |L18.14|
;;;2298   	fp->fs = 0;			/* Clear file object */
;;;2299   
;;;2300   #if !_FS_READONLY
;;;2301   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
;;;2302   	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
;;;2303   #else
;;;2304   	mode &= FA_READ;
;;;2305   	res = chk_mounted(&path, &dj.fs, 0);
;;;2306   #endif
;;;2307   	if (res == FR_OK) {
;;;2308   		INIT_BUF(dj);
;;;2309   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2310   		dir = dj.dir;
;;;2311   #if !_FS_READONLY	/* R/W configuration */
;;;2312   		if (res == FR_OK) {
;;;2313   			if (!dir)	/* Current dir itself */
;;;2314   				res = FR_INVALID_NAME;
;;;2315   #if _FS_LOCK
;;;2316   			else
;;;2317   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2318   #endif
;;;2319   		}
;;;2320   		/* Create or Open a file */
;;;2321   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2322   			DWORD dw, cl;
;;;2323   
;;;2324   			if (res != FR_OK) {					/* No file, create new */
;;;2325   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2326   #if _FS_LOCK
;;;2327   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2328   #else
;;;2329   					res = dir_register(&dj);
;;;2330   #endif
;;;2331   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2332   				dir = dj.dir;					/* New entry */
;;;2333   			}
;;;2334   			else {								/* Any object is already existing */
;;;2335   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2336   					res = FR_DENIED;
;;;2337   				} else {
;;;2338   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2339   						res = FR_EXIST;
;;;2340   				}
;;;2341   			}
;;;2342   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2343   				dw = get_fattime();					/* Created time */
;;;2344   				ST_DWORD(dir+DIR_CrtTime, dw);
;;;2345   				dir[DIR_Attr] = 0;					/* Reset attribute */
;;;2346   				ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
;;;2347   				cl = ld_clust(dj.fs, dir);			/* Get start cluster */
;;;2348   				st_clust(dir, 0);					/* cluster = 0 */
;;;2349   				dj.fs->wflag = 1;
;;;2350   				if (cl) {							/* Remove the cluster chain if exist */
;;;2351   					dw = dj.fs->winsect;
;;;2352   					res = remove_chain(dj.fs, cl);
;;;2353   					if (res == FR_OK) {
;;;2354   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2355   						res = move_window(dj.fs, dw);
;;;2356   					}
;;;2357   				}
;;;2358   			}
;;;2359   		}
;;;2360   		else {	/* Open an existing file */
;;;2361   			if (res == FR_OK) {						/* Follow succeeded */
;;;2362   				if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
;;;2363   					res = FR_NO_FILE;
;;;2364   				} else {
;;;2365   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2366   						res = FR_DENIED;
;;;2367   				}
;;;2368   			}
;;;2369   		}
;;;2370   		if (res == FR_OK) {
;;;2371   			if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
;;;2372   				mode |= FA__WRITTEN;
;;;2373   			fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
;;;2374   			fp->dir_ptr = dir;
;;;2375   #if _FS_LOCK
;;;2376   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2377   			if (!fp->lockid) res = FR_INT_ERR;
;;;2378   #endif
;;;2379   		}
;;;2380   
;;;2381   #else				/* R/O configuration */
;;;2382   		if (res == FR_OK) {					/* Follow succeeded */
;;;2383   			dir = dj.dir;
;;;2384   			if (!dir) {						/* Current dir itself */
;;;2385   				res = FR_INVALID_NAME;
;;;2386   			} else {
;;;2387   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2388   					res = FR_NO_FILE;
;;;2389   			}
;;;2390   		}
;;;2391   #endif
;;;2392   		FREE_BUF();
;;;2393   
;;;2394   		if (res == FR_OK) {
;;;2395   			fp->flag = mode;					/* File access mode */
;;;2396   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2397   			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
;;;2398   			fp->fptr = 0;						/* File pointer */
;;;2399   			fp->dsect = 0;
;;;2400   #if _USE_FASTSEEK
;;;2401   			fp->cltbl = 0;						/* Normal seek mode */
;;;2402   #endif
;;;2403   			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
;;;2404   		}
;;;2405   	}
;;;2406   
;;;2407   	LEAVE_FF(dj.fs, res);
;;;2408   }
00000e  f50d7d0f          ADD      sp,sp,#0x23c
000012  bdf0              POP      {r4-r7,pc}
                  |L18.20|
000014  2000              MOVS     r0,#0                 ;2298
000016  6020              STR      r0,[r4,#0]            ;2298
000018  f0070701          AND      r7,r7,#1              ;2304
00001c  2200              MOVS     r2,#0                 ;2305
00001e  a983              ADD      r1,sp,#0x20c          ;2305
000020  a88d              ADD      r0,sp,#0x234          ;2305
000022  f7fffffe          BL       chk_mounted
000026  4606              MOV      r6,r0                 ;2305
000028  2e00              CMP      r6,#0                 ;2307
00002a  d12d              BNE      |L18.136|
00002c  a880              ADD      r0,sp,#0x200          ;2308
00002e  9089              STR      r0,[sp,#0x224]        ;2308
000030  f8cdd228          STR      sp,[sp,#0x228]        ;2308
000034  a883              ADD      r0,sp,#0x20c          ;2309
000036  998d              LDR      r1,[sp,#0x234]        ;2309
000038  f7fffffe          BL       follow_path
00003c  4606              MOV      r6,r0                 ;2309
00003e  9d88              LDR      r5,[sp,#0x220]        ;2310
000040  b946              CBNZ     r6,|L18.84|
000042  9d88              LDR      r5,[sp,#0x220]        ;2383
000044  b90d              CBNZ     r5,|L18.74|
000046  2606              MOVS     r6,#6                 ;2385
000048  e004              B        |L18.84|
                  |L18.74|
00004a  7ae8              LDRB     r0,[r5,#0xb]          ;2387
00004c  f0000010          AND      r0,r0,#0x10           ;2387
000050  b100              CBZ      r0,|L18.84|
000052  2604              MOVS     r6,#4                 ;2388
                  |L18.84|
000054  b9c6              CBNZ     r6,|L18.136|
000056  71a7              STRB     r7,[r4,#6]            ;2395
000058  4629              MOV      r1,r5                 ;2396
00005a  9883              LDR      r0,[sp,#0x20c]        ;2396
00005c  f7fffffe          BL       ld_clust
000060  6120              STR      r0,[r4,#0x10]         ;2396
000062  7fe8              LDRB     r0,[r5,#0x1f]         ;2397
000064  0601              LSLS     r1,r0,#24             ;2397
000066  7fa8              LDRB     r0,[r5,#0x1e]         ;2397
000068  ea414100          ORR      r1,r1,r0,LSL #16      ;2397
00006c  7f68              LDRB     r0,[r5,#0x1d]         ;2397
00006e  ea412000          ORR      r0,r1,r0,LSL #8       ;2397
000072  7f29              LDRB     r1,[r5,#0x1c]         ;2397
000074  4308              ORRS     r0,r0,r1              ;2397
000076  60e0              STR      r0,[r4,#0xc]          ;2397
000078  2000              MOVS     r0,#0                 ;2398
00007a  60a0              STR      r0,[r4,#8]            ;2398
00007c  61a0              STR      r0,[r4,#0x18]         ;2399
00007e  9883              LDR      r0,[sp,#0x20c]        ;2403
000080  6020              STR      r0,[r4,#0]            ;2403
000082  9883              LDR      r0,[sp,#0x20c]        ;2403
000084  88c0              LDRH     r0,[r0,#6]            ;2403
000086  80a0              STRH     r0,[r4,#4]            ;2403
                  |L18.136|
000088  4630              MOV      r0,r6                 ;2407
00008a  e7c0              B        |L18.14|
;;;2409   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3011   
;;;3012   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3013   	DIR *dj,			/* Pointer to directory object to create */
;;;3014   	const TCHAR *path	/* Pointer to the directory path */
;;;3015   )
;;;3016   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  4604              MOV      r4,r0
;;;3017   	FRESULT res;
;;;3018   	FATFS *fs;
;;;3019   	DEF_NAMEBUF;
;;;3020   
;;;3021   
;;;3022   	if (!dj) return FR_INVALID_OBJECT;
000008  b91c              CBNZ     r4,|L19.18|
00000a  2009              MOVS     r0,#9
                  |L19.12|
;;;3023   
;;;3024   	res = chk_mounted(&path, &dj->fs, 0);
;;;3025   	fs = dj->fs;
;;;3026   	if (res == FR_OK) {
;;;3027   		INIT_BUF(*dj);
;;;3028   		res = follow_path(dj, path);			/* Follow the path to the directory */
;;;3029   		FREE_BUF();
;;;3030   		if (res == FR_OK) {						/* Follow completed */
;;;3031   			if (dj->dir) {						/* It is not the root dir */
;;;3032   				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
;;;3033   					dj->sclust = ld_clust(fs, dj->dir);
;;;3034   				} else {						/* The object is not a directory */
;;;3035   					res = FR_NO_PATH;
;;;3036   				}
;;;3037   			}
;;;3038   			if (res == FR_OK) {
;;;3039   				dj->id = fs->id;
;;;3040   				res = dir_sdi(dj, 0);			/* Rewind dir */
;;;3041   			}
;;;3042   		}
;;;3043   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3044   		if (res != FR_OK) dj->fs = 0;			/* Invalidate the dir object if function faild */
;;;3045   	} else {
;;;3046   		dj->fs = 0;
;;;3047   	}
;;;3048   
;;;3049   	LEAVE_FF(fs, res);
;;;3050   }
00000c  f50d7d06          ADD      sp,sp,#0x218
000010  bd70              POP      {r4-r6,pc}
                  |L19.18|
000012  2200              MOVS     r2,#0                 ;3024
000014  4621              MOV      r1,r4                 ;3024
000016  a885              ADD      r0,sp,#0x214          ;3024
000018  f7fffffe          BL       chk_mounted
00001c  4605              MOV      r5,r0                 ;3024
00001e  6826              LDR      r6,[r4,#0]            ;3025
000020  bb35              CBNZ     r5,|L19.112|
000022  a881              ADD      r0,sp,#0x204          ;3027
000024  61a0              STR      r0,[r4,#0x18]         ;3027
000026  a801              ADD      r0,sp,#4              ;3027
000028  61e0              STR      r0,[r4,#0x1c]         ;3027
00002a  4620              MOV      r0,r4                 ;3028
00002c  9985              LDR      r1,[sp,#0x214]        ;3028
00002e  f7fffffe          BL       follow_path
000032  4605              MOV      r5,r0                 ;3028
000034  b9ad              CBNZ     r5,|L19.98|
000036  6960              LDR      r0,[r4,#0x14]         ;3031
000038  b158              CBZ      r0,|L19.82|
00003a  6960              LDR      r0,[r4,#0x14]         ;3032
00003c  7ac0              LDRB     r0,[r0,#0xb]          ;3032
00003e  f0000010          AND      r0,r0,#0x10           ;3032
000042  b128              CBZ      r0,|L19.80|
000044  4630              MOV      r0,r6                 ;3033
000046  6961              LDR      r1,[r4,#0x14]         ;3033
000048  f7fffffe          BL       ld_clust
00004c  60a0              STR      r0,[r4,#8]            ;3033
00004e  e000              B        |L19.82|
                  |L19.80|
000050  2505              MOVS     r5,#5                 ;3035
                  |L19.82|
000052  b935              CBNZ     r5,|L19.98|
000054  88f0              LDRH     r0,[r6,#6]            ;3039
000056  80a0              STRH     r0,[r4,#4]            ;3039
000058  2100              MOVS     r1,#0                 ;3040
00005a  4620              MOV      r0,r4                 ;3040
00005c  f7fffffe          BL       dir_sdi
000060  4605              MOV      r5,r0                 ;3040
                  |L19.98|
000062  2d04              CMP      r5,#4                 ;3043
000064  d100              BNE      |L19.104|
000066  2505              MOVS     r5,#5                 ;3043
                  |L19.104|
000068  b125              CBZ      r5,|L19.116|
00006a  2000              MOVS     r0,#0                 ;3044
00006c  6020              STR      r0,[r4,#0]            ;3044
00006e  e001              B        |L19.116|
                  |L19.112|
000070  2000              MOVS     r0,#0                 ;3046
000072  6020              STR      r0,[r4,#0]            ;3046
                  |L19.116|
000074  4628              MOV      r0,r5                 ;3049
000076  e7c9              B        |L19.12|
;;;3051   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2416   
;;;2417   FRESULT f_read (
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;2418   	FIL *fp, 		/* Pointer to the file object */
;;;2419   	void *buff,		/* Pointer to data buffer */
;;;2420   	UINT btr,		/* Number of bytes to read */
;;;2421   	UINT *br		/* Pointer to number of bytes read */
;;;2422   )
;;;2423   {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  4615              MOV      r5,r2
00000a  4699              MOV      r9,r3
;;;2424   	FRESULT res;
;;;2425   	DWORD clst, sect, remain;
;;;2426   	UINT rcnt, cc;
;;;2427   	BYTE csect, *rbuff = buff;
00000c  9804              LDR      r0,[sp,#0x10]
00000e  9000              STR      r0,[sp,#0]
;;;2428   
;;;2429   
;;;2430   	*br = 0;	/* Clear read byte counter */
000010  2000              MOVS     r0,#0
000012  f8c90000          STR      r0,[r9,#0]
;;;2431   
;;;2432   	res = validate(fp);							/* Check validity */
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       validate
00001c  9002              STR      r0,[sp,#8]
;;;2433   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
00001e  9802              LDR      r0,[sp,#8]
000020  b118              CBZ      r0,|L20.42|
000022  9802              LDR      r0,[sp,#8]
                  |L20.36|
;;;2434   	if (fp->flag & FA__ERROR)					/* Aborted file? */
;;;2435   		LEAVE_FF(fp->fs, FR_INT_ERR);
;;;2436   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
;;;2437   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2438   	remain = fp->fsize - fp->fptr;
;;;2439   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2440   
;;;2441   	for ( ;  btr;								/* Repeat until all data read */
;;;2442   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2443   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2444   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2445   			if (!csect) {						/* On the cluster boundary? */
;;;2446   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2447   					clst = fp->sclust;			/* Follow from the origin */
;;;2448   				} else {						/* Middle or end of the file */
;;;2449   #if _USE_FASTSEEK
;;;2450   					if (fp->cltbl)
;;;2451   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2452   					else
;;;2453   #endif
;;;2454   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2455   				}
;;;2456   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2457   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2458   				fp->clust = clst;				/* Update current cluster */
;;;2459   			}
;;;2460   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2461   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2462   			sect += csect;
;;;2463   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2464   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2465   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2466   					cc = fp->fs->csize - csect;
;;;2467   				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
;;;2468   					ABORT(fp->fs, FR_DISK_ERR);
;;;2469   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2470   #if _FS_TINY
;;;2471   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2472   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2473   #else
;;;2474   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2475   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
;;;2476   #endif
;;;2477   #endif
;;;2478   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2479   				continue;
;;;2480   			}
;;;2481   #if !_FS_TINY
;;;2482   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2483   #if !_FS_READONLY
;;;2484   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2485   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2486   						ABORT(fp->fs, FR_DISK_ERR);
;;;2487   					fp->flag &= ~FA__DIRTY;
;;;2488   				}
;;;2489   #endif
;;;2490   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2491   					ABORT(fp->fs, FR_DISK_ERR);
;;;2492   			}
;;;2493   #endif
;;;2494   			fp->dsect = sect;
;;;2495   		}
;;;2496   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2497   		if (rcnt > btr) rcnt = btr;
;;;2498   #if _FS_TINY
;;;2499   		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
;;;2500   			ABORT(fp->fs, FR_DISK_ERR);
;;;2501   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2502   #else
;;;2503   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2504   #endif
;;;2505   	}
;;;2506   
;;;2507   	LEAVE_FF(fp->fs, FR_OK);
;;;2508   }
000024  b007              ADD      sp,sp,#0x1c
000026  e8bd8ff0          POP      {r4-r11,pc}
                  |L20.42|
00002a  79a0              LDRB     r0,[r4,#6]            ;2434
00002c  f0000080          AND      r0,r0,#0x80           ;2434
000030  b108              CBZ      r0,|L20.54|
000032  2002              MOVS     r0,#2                 ;2435
000034  e7f6              B        |L20.36|
                  |L20.54|
000036  79a0              LDRB     r0,[r4,#6]            ;2436
000038  f0000001          AND      r0,r0,#1              ;2436
00003c  b908              CBNZ     r0,|L20.66|
00003e  2007              MOVS     r0,#7                 ;2437
000040  e7f0              B        |L20.36|
                  |L20.66|
000042  e9d41002          LDRD     r1,r0,[r4,#8]         ;2438
000046  1a40              SUBS     r0,r0,r1              ;2438
000048  9001              STR      r0,[sp,#4]            ;2438
00004a  9801              LDR      r0,[sp,#4]            ;2439
00004c  4285              CMP      r5,r0                 ;2439
00004e  d900              BLS      |L20.82|
000050  9d01              LDR      r5,[sp,#4]            ;2439
                  |L20.82|
000052  e08d              B        |L20.368|
                  |L20.84|
000054  8920              LDRH     r0,[r4,#8]            ;2443
000056  f3c00008          UBFX     r0,r0,#0,#9           ;2443
00005a  2800              CMP      r0,#0                 ;2443
00005c  d169              BNE      |L20.306|
00005e  6820              LDR      r0,[r4,#0]            ;2444
000060  7880              LDRB     r0,[r0,#2]            ;2444
000062  1e40              SUBS     r0,r0,#1              ;2444
000064  68a1              LDR      r1,[r4,#8]            ;2444
000066  ea002051          AND      r0,r0,r1,LSR #9       ;2444
00006a  f00008ff          AND      r8,r0,#0xff           ;2444
00006e  f1b80f00          CMP      r8,#0                 ;2445
000072  d11d              BNE      |L20.176|
000074  68a0              LDR      r0,[r4,#8]            ;2446
000076  b910              CBNZ     r0,|L20.126|
000078  f8d4b010          LDR      r11,[r4,#0x10]        ;2447
00007c  e004              B        |L20.136|
                  |L20.126|
00007e  6961              LDR      r1,[r4,#0x14]         ;2454
000080  6820              LDR      r0,[r4,#0]            ;2454
000082  f7fffffe          BL       get_fat
000086  4683              MOV      r11,r0                ;2454
                  |L20.136|
000088  f1bb0f02          CMP      r11,#2                ;2456
00008c  d205              BCS      |L20.154|
00008e  79a0              LDRB     r0,[r4,#6]            ;2456
000090  f0400080          ORR      r0,r0,#0x80           ;2456
000094  71a0              STRB     r0,[r4,#6]            ;2456
000096  2002              MOVS     r0,#2                 ;2456
000098  e7c4              B        |L20.36|
                  |L20.154|
00009a  f10b0001          ADD      r0,r11,#1             ;2457
00009e  b928              CBNZ     r0,|L20.172|
0000a0  79a0              LDRB     r0,[r4,#6]            ;2457
0000a2  f0400080          ORR      r0,r0,#0x80           ;2457
0000a6  71a0              STRB     r0,[r4,#6]            ;2457
0000a8  2001              MOVS     r0,#1                 ;2457
0000aa  e7bb              B        |L20.36|
                  |L20.172|
0000ac  f8c4b014          STR      r11,[r4,#0x14]        ;2458
                  |L20.176|
0000b0  6961              LDR      r1,[r4,#0x14]         ;2460
0000b2  6820              LDR      r0,[r4,#0]            ;2460
0000b4  f7fffffe          BL       clust2sect
0000b8  4607              MOV      r7,r0                 ;2460
0000ba  b92f              CBNZ     r7,|L20.200|
0000bc  79a0              LDRB     r0,[r4,#6]            ;2461
0000be  f0400080          ORR      r0,r0,#0x80           ;2461
0000c2  71a0              STRB     r0,[r4,#6]            ;2461
0000c4  2002              MOVS     r0,#2                 ;2461
0000c6  e7ad              B        |L20.36|
                  |L20.200|
0000c8  4447              ADD      r7,r7,r8              ;2462
0000ca  ea4f2a55          LSR      r10,r5,#9             ;2463
0000ce  f1ba0f00          CMP      r10,#0                ;2464
0000d2  d01b              BEQ      |L20.268|
0000d4  eb08000a          ADD      r0,r8,r10             ;2465
0000d8  6821              LDR      r1,[r4,#0]            ;2465
0000da  7889              LDRB     r1,[r1,#2]            ;2465
0000dc  4288              CMP      r0,r1                 ;2465
0000de  d903              BLS      |L20.232|
0000e0  6820              LDR      r0,[r4,#0]            ;2466
0000e2  7880              LDRB     r0,[r0,#2]            ;2466
0000e4  eba00a08          SUB      r10,r0,r8             ;2466
                  |L20.232|
0000e8  f00a03ff          AND      r3,r10,#0xff          ;2467
0000ec  6821              LDR      r1,[r4,#0]            ;2467
0000ee  7848              LDRB     r0,[r1,#1]            ;2467
0000f0  463a              MOV      r2,r7                 ;2467
0000f2  9900              LDR      r1,[sp,#0]            ;2467
0000f4  f7fffffe          BL       disk_read
0000f8  b128              CBZ      r0,|L20.262|
0000fa  79a0              LDRB     r0,[r4,#6]            ;2468
0000fc  f0400080          ORR      r0,r0,#0x80           ;2468
000100  71a0              STRB     r0,[r4,#6]            ;2468
000102  2001              MOVS     r0,#1                 ;2468
000104  e78e              B        |L20.36|
                  |L20.262|
000106  ea4f264a          LSL      r6,r10,#9             ;2478
00010a  e025              B        |L20.344|
                  |L20.268|
00010c  69a0              LDR      r0,[r4,#0x18]         ;2482
00010e  42b8              CMP      r0,r7                 ;2482
000110  d00e              BEQ      |L20.304|
000112  6821              LDR      r1,[r4,#0]            ;2490
000114  7848              LDRB     r0,[r1,#1]            ;2490
000116  2301              MOVS     r3,#1                 ;2490
000118  463a              MOV      r2,r7                 ;2490
00011a  f104011c          ADD      r1,r4,#0x1c           ;2490
00011e  f7fffffe          BL       disk_read
000122  b128              CBZ      r0,|L20.304|
000124  79a0              LDRB     r0,[r4,#6]            ;2491
000126  f0400080          ORR      r0,r0,#0x80           ;2491
00012a  71a0              STRB     r0,[r4,#6]            ;2491
00012c  2001              MOVS     r0,#1                 ;2491
00012e  e779              B        |L20.36|
                  |L20.304|
000130  61a7              STR      r7,[r4,#0x18]         ;2494
                  |L20.306|
000132  8920              LDRH     r0,[r4,#8]            ;2496
000134  f3c00008          UBFX     r0,r0,#0,#9           ;2496
000138  f5c07600          RSB      r6,r0,#0x200          ;2496
00013c  42ae              CMP      r6,r5                 ;2497
00013e  d900              BLS      |L20.322|
000140  462e              MOV      r6,r5                 ;2497
                  |L20.322|
000142  8920              LDRH     r0,[r4,#8]            ;2503
000144  f3c00208          UBFX     r2,r0,#0,#9           ;2503
000148  f104001c          ADD      r0,r4,#0x1c           ;2503
00014c  1811              ADDS     r1,r2,r0              ;2503
00014e  4632              MOV      r2,r6                 ;2503
000150  9800              LDR      r0,[sp,#0]            ;2503
000152  f7fffffe          BL       mem_cpy
000156  bf00              NOP                            ;2479
                  |L20.344|
000158  9800              LDR      r0,[sp,#0]            ;2442
00015a  4430              ADD      r0,r0,r6              ;2442
00015c  9000              STR      r0,[sp,#0]            ;2442
00015e  68a0              LDR      r0,[r4,#8]            ;2442
000160  4430              ADD      r0,r0,r6              ;2442
000162  60a0              STR      r0,[r4,#8]            ;2442
000164  f8d90000          LDR      r0,[r9,#0]            ;2442
000168  4430              ADD      r0,r0,r6              ;2442
00016a  f8c90000          STR      r0,[r9,#0]            ;2442
00016e  1bad              SUBS     r5,r5,r6              ;2442
                  |L20.368|
000170  2d00              CMP      r5,#0                 ;2441
000172  f47faf6f          BNE      |L20.84|
000176  2000              MOVS     r0,#0                 ;2507
000178  e754              B        |L20.36|
;;;2509   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3058   
;;;3059   FRESULT f_readdir (
000000  b570              PUSH     {r4-r6,lr}
;;;3060   	DIR *dj,			/* Pointer to the open directory object */
;;;3061   	FILINFO *fno		/* Pointer to file information to return */
;;;3062   )
;;;3063   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  4604              MOV      r4,r0
000008  460e              MOV      r6,r1
;;;3064   	FRESULT res;
;;;3065   	DEF_NAMEBUF;
;;;3066   
;;;3067   
;;;3068   	res = validate(dj);						/* Check validity of the object */
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       validate
000010  4605              MOV      r5,r0
;;;3069   	if (res == FR_OK) {
000012  bb15              CBNZ     r5,|L21.90|
;;;3070   		if (!fno) {
000014  b92e              CBNZ     r6,|L21.34|
;;;3071   			res = dir_sdi(dj, 0);			/* Rewind the directory object */
000016  2100              MOVS     r1,#0
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_sdi
00001e  4605              MOV      r5,r0
000020  e01b              B        |L21.90|
                  |L21.34|
;;;3072   		} else {
;;;3073   			INIT_BUF(*dj);
000022  a881              ADD      r0,sp,#0x204
000024  61a0              STR      r0,[r4,#0x18]
000026  a801              ADD      r0,sp,#4
000028  61e0              STR      r0,[r4,#0x1c]
;;;3074   			res = dir_read(dj);				/* Read an directory item */
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       dir_read
000030  4605              MOV      r5,r0
;;;3075   			if (res == FR_NO_FILE) {		/* Reached end of dir */
000032  2d04              CMP      r5,#4
000034  d102              BNE      |L21.60|
;;;3076   				dj->sect = 0;
000036  2000              MOVS     r0,#0
000038  6120              STR      r0,[r4,#0x10]
;;;3077   				res = FR_OK;
00003a  2500              MOVS     r5,#0
                  |L21.60|
;;;3078   			}
;;;3079   			if (res == FR_OK) {				/* A valid entry is found */
00003c  b96d              CBNZ     r5,|L21.90|
;;;3080   				get_fileinfo(dj, fno);		/* Get the object information */
00003e  4631              MOV      r1,r6
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       get_fileinfo
;;;3081   				res = dir_next(dj, 0);		/* Increment index for next */
000046  2100              MOVS     r1,#0
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       dir_next
00004e  4605              MOV      r5,r0
;;;3082   				if (res == FR_NO_FILE) {
000050  2d04              CMP      r5,#4
000052  d102              BNE      |L21.90|
;;;3083   					dj->sect = 0;
000054  2000              MOVS     r0,#0
000056  6120              STR      r0,[r4,#0x10]
;;;3084   					res = FR_OK;
000058  2500              MOVS     r5,#0
                  |L21.90|
;;;3085   				}
;;;3086   			}
;;;3087   			FREE_BUF();
;;;3088   		}
;;;3089   	}
;;;3090   	LEAVE_FF(dj->fs, res);
00005a  4628              MOV      r0,r5
;;;3091   }
00005c  f50d7d04          ADD      sp,sp,#0x210
000060  bd70              POP      {r4-r6,pc}
;;;3092   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3099   
;;;3100   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3101   	const TCHAR *path,	/* Pointer to the file path */
;;;3102   	FILINFO *fno		/* Pointer to file information to return */
;;;3103   )
;;;3104   {
000002  f5ad7d0d          SUB      sp,sp,#0x234
000006  460d              MOV      r5,r1
;;;3105   	FRESULT res;
;;;3106   	DIR dj;
;;;3107   	DEF_NAMEBUF;
;;;3108   
;;;3109   	res = chk_mounted(&path, &dj.fs, 0);
000008  2200              MOVS     r2,#0
00000a  a984              ADD      r1,sp,#0x210
00000c  a88d              ADD      r0,sp,#0x234
00000e  f7fffffe          BL       chk_mounted
000012  4604              MOV      r4,r0
;;;3110   	if (res == FR_OK) {
000014  b98c              CBNZ     r4,|L22.58|
;;;3111   		INIT_BUF(dj);
000016  a881              ADD      r0,sp,#0x204
000018  908a              STR      r0,[sp,#0x228]
00001a  a801              ADD      r0,sp,#4
00001c  908b              STR      r0,[sp,#0x22c]
;;;3112   		res = follow_path(&dj, path);	/* Follow the file path */
00001e  a884              ADD      r0,sp,#0x210
000020  998d              LDR      r1,[sp,#0x234]
000022  f7fffffe          BL       follow_path
000026  4604              MOV      r4,r0
;;;3113   		if (res == FR_OK) {				/* Follow completed */
000028  b93c              CBNZ     r4,|L22.58|
;;;3114   			if (dj.dir)		/* Found an object */
00002a  9889              LDR      r0,[sp,#0x224]
00002c  b120              CBZ      r0,|L22.56|
;;;3115   				get_fileinfo(&dj, fno);
00002e  4629              MOV      r1,r5
000030  a884              ADD      r0,sp,#0x210
000032  f7fffffe          BL       get_fileinfo
000036  e000              B        |L22.58|
                  |L22.56|
;;;3116   			else			/* It is root dir */
;;;3117   				res = FR_INVALID_NAME;
000038  2406              MOVS     r4,#6
                  |L22.58|
;;;3118   		}
;;;3119   		FREE_BUF();
;;;3120   	}
;;;3121   
;;;3122   	LEAVE_FF(dj.fs, res);
00003a  4620              MOV      r0,r4
;;;3123   }
00003c  f50d7d0f          ADD      sp,sp,#0x23c
000040  bd30              POP      {r4,r5,pc}
;;;3124   
                          ENDP


                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;1956   static
;;;1957   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  e92d41f3          PUSH     {r0,r1,r4-r8,lr}
;;;1958   	DIR *dj,			/* Directory object to return last directory and found object */
;;;1959   	const TCHAR *path	/* Full-path string to find a file or directory */
;;;1960   )
;;;1961   {
000004  4604              MOV      r4,r0
;;;1962   	FRESULT res;
;;;1963   	BYTE *dir, ns;
;;;1964   
;;;1965   
;;;1966   #if _FS_RPATH
;;;1967   	if (*path == '/' || *path == '\\') { /* There is a heading separator */
000006  9801              LDR      r0,[sp,#4]
000008  7800              LDRB     r0,[r0,#0]
00000a  282f              CMP      r0,#0x2f
00000c  d003              BEQ      |L23.22|
00000e  9801              LDR      r0,[sp,#4]
000010  7800              LDRB     r0,[r0,#0]
000012  285c              CMP      r0,#0x5c
000014  d105              BNE      |L23.34|
                  |L23.22|
;;;1968   		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
000016  9801              LDR      r0,[sp,#4]
000018  1c40              ADDS     r0,r0,#1
00001a  9001              STR      r0,[sp,#4]
00001c  2000              MOVS     r0,#0
00001e  60a0              STR      r0,[r4,#8]
000020  e002              B        |L23.40|
                  |L23.34|
;;;1969   	} else {							/* No heading separator */
;;;1970   		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
000022  6820              LDR      r0,[r4,#0]
000024  68c0              LDR      r0,[r0,#0xc]
000026  60a0              STR      r0,[r4,#8]
                  |L23.40|
;;;1971   	}
;;;1972   #else
;;;1973   	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
;;;1974   		path++;
;;;1975   	dj->sclust = 0;						/* Start from the root dir */
;;;1976   #endif
;;;1977   
;;;1978   	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
000028  9801              LDR      r0,[sp,#4]
00002a  7800              LDRB     r0,[r0,#0]
00002c  2820              CMP      r0,#0x20
00002e  d207              BCS      |L23.64|
;;;1979   		res = dir_sdi(dj, 0);
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       dir_sdi
000038  4605              MOV      r5,r0
;;;1980   		dj->dir = 0;
00003a  2000              MOVS     r0,#0
00003c  6160              STR      r0,[r4,#0x14]
00003e  e033              B        |L23.168|
                  |L23.64|
;;;1981   	} else {							/* Follow path */
;;;1982   		for (;;) {
000040  bf00              NOP      
                  |L23.66|
;;;1983   			res = create_name(dj, &path);	/* Get a segment */
000042  a901              ADD      r1,sp,#4
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       create_name
00004a  4605              MOV      r5,r0
;;;1984   			if (res != FR_OK) break;
00004c  b105              CBZ      r5,|L23.80|
00004e  e02a              B        |L23.166|
                  |L23.80|
;;;1985   			res = dir_find(dj);				/* Find it */
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       dir_find
000056  4605              MOV      r5,r0
;;;1986   			ns = *(dj->fn+NS);
000058  69a0              LDR      r0,[r4,#0x18]
00005a  7ac6              LDRB     r6,[r0,#0xb]
;;;1987   			if (res != FR_OK) {				/* Failed to find the object */
00005c  b195              CBZ      r5,|L23.132|
;;;1988   				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
00005e  2d04              CMP      r5,#4
000060  d000              BEQ      |L23.100|
000062  e020              B        |L23.166|
                  |L23.100|
;;;1989   				/* Object not found */
;;;1990   				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
000064  f0060020          AND      r0,r6,#0x20
000068  b138              CBZ      r0,|L23.122|
;;;1991   					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
00006a  2000              MOVS     r0,#0
00006c  60a0              STR      r0,[r4,#8]
00006e  6160              STR      r0,[r4,#0x14]
;;;1992   					res = FR_OK;
000070  2500              MOVS     r5,#0
;;;1993   					if (!(ns & NS_LAST)) continue;
000072  f0060004          AND      r0,r6,#4
000076  b920              CBNZ     r0,|L23.130|
000078  e7e3              B        |L23.66|
                  |L23.122|
;;;1994   				} else {							/* Could not find the object */
;;;1995   					if (!(ns & NS_LAST)) res = FR_NO_PATH;
00007a  f0060004          AND      r0,r6,#4
00007e  b900              CBNZ     r0,|L23.130|
000080  2505              MOVS     r5,#5
                  |L23.130|
;;;1996   				}
;;;1997   				break;
000082  e010              B        |L23.166|
                  |L23.132|
;;;1998   			}
;;;1999   			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
000084  f0060004          AND      r0,r6,#4
000088  b100              CBZ      r0,|L23.140|
00008a  e00c              B        |L23.166|
                  |L23.140|
;;;2000   			dir = dj->dir;						/* There is next segment. Follow the sub directory */
00008c  6967              LDR      r7,[r4,#0x14]
;;;2001   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
00008e  7af8              LDRB     r0,[r7,#0xb]
000090  f0000010          AND      r0,r0,#0x10
000094  b908              CBNZ     r0,|L23.154|
;;;2002   				res = FR_NO_PATH; break;
000096  2505              MOVS     r5,#5
000098  e005              B        |L23.166|
                  |L23.154|
;;;2003   			}
;;;2004   			dj->sclust = ld_clust(dj->fs, dir);
00009a  4639              MOV      r1,r7
00009c  6820              LDR      r0,[r4,#0]
00009e  f7fffffe          BL       ld_clust
0000a2  60a0              STR      r0,[r4,#8]
0000a4  e7cd              B        |L23.66|
                  |L23.166|
0000a6  bf00              NOP                            ;1984
                  |L23.168|
;;;2005   		}
;;;2006   	}
;;;2007   
;;;2008   	return res;
0000a8  4628              MOV      r0,r5
;;;2009   }
0000aa  e8bd81fc          POP      {r2-r8,pc}
;;;2010   
                          ENDP


                          AREA ||i.gen_numname||, CODE, READONLY, ALIGN=1

                  gen_numname PROC
;;;1321   #if _USE_LFN
;;;1322   void gen_numname (
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1323   	BYTE *dst,			/* Pointer to generated SFN */
;;;1324   	const BYTE *src,	/* Pointer to source SFN to be modified */
;;;1325   	const WCHAR *lfn,	/* Pointer to LFN */
;;;1326   	WORD seq			/* Sequence number */
;;;1327   )
;;;1328   {
000004  4680              MOV      r8,r0
000006  468a              MOV      r10,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;1329   	BYTE ns[8], c;
;;;1330   	UINT i, j;
;;;1331   
;;;1332   
;;;1333   	mem_cpy(dst, src, 11);
00000c  220b              MOVS     r2,#0xb
00000e  4651              MOV      r1,r10
000010  4640              MOV      r0,r8
000012  f7fffffe          BL       mem_cpy
;;;1334   
;;;1335   	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
000016  2c05              CMP      r4,#5
000018  dd0a              BLE      |L24.48|
;;;1336   		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
00001a  bf00              NOP      
                  |L24.28|
00001c  1060              ASRS     r0,r4,#1
00001e  eb0031c4          ADD      r1,r0,r4,LSL #15
000022  f8372b02          LDRH     r2,[r7],#2
000026  1888              ADDS     r0,r1,r2
000028  b284              UXTH     r4,r0
00002a  8838              LDRH     r0,[r7,#0]
00002c  2800              CMP      r0,#0
00002e  d1f5              BNE      |L24.28|
                  |L24.48|
;;;1337   	}
;;;1338   
;;;1339   	/* itoa (hexdecimal) */
;;;1340   	i = 7;
000030  2507              MOVS     r5,#7
;;;1341   	do {
000032  bf00              NOP      
                  |L24.52|
;;;1342   		c = (seq % 16) + '0';
000034  4620              MOV      r0,r4
000036  17e1              ASRS     r1,r4,#31
000038  eb047111          ADD      r1,r4,r1,LSR #28
00003c  1109              ASRS     r1,r1,#4
00003e  eba41101          SUB      r1,r4,r1,LSL #4
000042  3130              ADDS     r1,r1,#0x30
000044  f00109ff          AND      r9,r1,#0xff
;;;1343   		if (c > '9') c += 7;
000048  f1b90f39          CMP      r9,#0x39
00004c  dd03              BLE      |L24.86|
00004e  f1090007          ADD      r0,r9,#7
000052  f00009ff          AND      r9,r0,#0xff
                  |L24.86|
;;;1344   		ns[i--] = c;
000056  4628              MOV      r0,r5
000058  1e6d              SUBS     r5,r5,#1
00005a  f80d9000          STRB     r9,[sp,r0]
;;;1345   		seq /= 16;
00005e  4620              MOV      r0,r4
000060  17e1              ASRS     r1,r4,#31
000062  eb047111          ADD      r1,r4,r1,LSR #28
000066  f3c1140f          UBFX     r4,r1,#4,#16
;;;1346   	} while (seq);
00006a  2c00              CMP      r4,#0
00006c  d1e2              BNE      |L24.52|
;;;1347   	ns[i] = '~';
00006e  207e              MOVS     r0,#0x7e
000070  f80d0005          STRB     r0,[sp,r5]
;;;1348   
;;;1349   	/* Append the number */
;;;1350   	for (j = 0; j < i && dst[j] != ' '; j++) {
000074  2600              MOVS     r6,#0
000076  e000              B        |L24.122|
                  |L24.120|
000078  1c76              ADDS     r6,r6,#1
                  |L24.122|
00007a  42ae              CMP      r6,r5
00007c  d203              BCS      |L24.134|
00007e  f8180006          LDRB     r0,[r8,r6]
000082  2820              CMP      r0,#0x20
000084  d1f8              BNE      |L24.120|
                  |L24.134|
;;;1351   		if (IsDBCS1(dst[j])) {
;;;1352   			if (j == i - 1) break;
;;;1353   			j++;
;;;1354   		}
;;;1355   	}
;;;1356   	do {
000086  bf00              NOP      
                  |L24.136|
;;;1357   		dst[j++] = (i < 8) ? ns[i++] : ' ';
000088  2d08              CMP      r5,#8
00008a  d204              BCS      |L24.150|
00008c  4628              MOV      r0,r5
00008e  1c6d              ADDS     r5,r5,#1
000090  f81d0000          LDRB     r0,[sp,r0]
000094  e000              B        |L24.152|
                  |L24.150|
000096  2020              MOVS     r0,#0x20
                  |L24.152|
000098  4631              MOV      r1,r6
00009a  1c76              ADDS     r6,r6,#1
00009c  f8080001          STRB     r0,[r8,r1]
;;;1358   	} while (j < 8);
0000a0  2e08              CMP      r6,#8
0000a2  d3f1              BCC      |L24.136|
;;;1359   }
0000a4  e8bd87fc          POP      {r2-r10,pc}
;;;1360   #endif
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;821    
;;;822    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;823    	FATFS *fs,	/* File system object */
;;;824    	DWORD clst	/* Cluster# to get the link information */
;;;825    )
;;;826    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;827    	UINT wc, bc;
;;;828    	BYTE *p;
;;;829    
;;;830    
;;;831    	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
000008  2c02              CMP      r4,#2
00000a  d302              BCC      |L25.18|
00000c  6928              LDR      r0,[r5,#0x10]
00000e  42a0              CMP      r0,r4
000010  d802              BHI      |L25.24|
                  |L25.18|
;;;832    		return 1;
000012  2001              MOVS     r0,#1
                  |L25.20|
;;;833    
;;;834    	switch (fs->fs_type) {
;;;835    	case FS_FAT12 :
;;;836    		bc = (UINT)clst; bc += bc / 2;
;;;837    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;838    		wc = fs->win[bc % SS(fs)]; bc++;
;;;839    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;840    		wc |= fs->win[bc % SS(fs)] << 8;
;;;841    		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
;;;842    
;;;843    	case FS_FAT16 :
;;;844    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
;;;845    		p = &fs->win[clst * 2 % SS(fs)];
;;;846    		return LD_WORD(p);
;;;847    
;;;848    	case FS_FAT32 :
;;;849    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
;;;850    		p = &fs->win[clst * 4 % SS(fs)];
;;;851    		return LD_DWORD(p) & 0x0FFFFFFF;
;;;852    	}
;;;853    
;;;854    	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
;;;855    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L25.24|
000018  7828              LDRB     r0,[r5,#0]            ;834
00001a  2801              CMP      r0,#1                 ;834
00001c  d004              BEQ      |L25.40|
00001e  2802              CMP      r0,#2                 ;834
000020  d02c              BEQ      |L25.124|
000022  2803              CMP      r0,#3                 ;834
000024  d15a              BNE      |L25.220|
000026  e03d              B        |L25.164|
                  |L25.40|
000028  4627              MOV      r7,r4                 ;836
00002a  eb070757          ADD      r7,r7,r7,LSR #1       ;836
00002e  69a8              LDR      r0,[r5,#0x18]         ;837
000030  eb002157          ADD      r1,r0,r7,LSR #9       ;837
000034  4628              MOV      r0,r5                 ;837
000036  f7fffffe          BL       move_window
00003a  b100              CBZ      r0,|L25.62|
00003c  e04e              B        |L25.220|
                  |L25.62|
00003e  f3c70108          UBFX     r1,r7,#0,#9           ;838
000042  f1050028          ADD      r0,r5,#0x28           ;838
000046  f8108001          LDRB     r8,[r0,r1]            ;838
00004a  1c7f              ADDS     r7,r7,#1              ;838
00004c  69a8              LDR      r0,[r5,#0x18]         ;839
00004e  eb002157          ADD      r1,r0,r7,LSR #9       ;839
000052  4628              MOV      r0,r5                 ;839
000054  f7fffffe          BL       move_window
000058  b100              CBZ      r0,|L25.92|
00005a  e03f              B        |L25.220|
                  |L25.92|
00005c  f3c70108          UBFX     r1,r7,#0,#9           ;840
000060  f1050028          ADD      r0,r5,#0x28           ;840
000064  5c40              LDRB     r0,[r0,r1]            ;840
000066  ea482800          ORR      r8,r8,r0,LSL #8       ;840
00006a  f0040001          AND      r0,r4,#1              ;841
00006e  b110              CBZ      r0,|L25.118|
000070  ea4f1018          LSR      r0,r8,#4              ;841
000074  e7ce              B        |L25.20|
                  |L25.118|
000076  f3c8000b          UBFX     r0,r8,#0,#12          ;841
00007a  e7cb              B        |L25.20|
                  |L25.124|
00007c  69a8              LDR      r0,[r5,#0x18]         ;844
00007e  eb002114          ADD      r1,r0,r4,LSR #8       ;844
000082  4628              MOV      r0,r5                 ;844
000084  f7fffffe          BL       move_window
000088  b100              CBZ      r0,|L25.140|
00008a  e027              B        |L25.220|
                  |L25.140|
00008c  f24010ff          MOV      r0,#0x1ff             ;845
000090  ea000144          AND      r1,r0,r4,LSL #1       ;845
000094  f1050028          ADD      r0,r5,#0x28           ;845
000098  180e              ADDS     r6,r1,r0              ;845
00009a  7830              LDRB     r0,[r6,#0]            ;846
00009c  7871              LDRB     r1,[r6,#1]            ;846
00009e  ea402001          ORR      r0,r0,r1,LSL #8       ;846
0000a2  e7b7              B        |L25.20|
                  |L25.164|
0000a4  69a8              LDR      r0,[r5,#0x18]         ;849
0000a6  eb0011d4          ADD      r1,r0,r4,LSR #7       ;849
0000aa  4628              MOV      r0,r5                 ;849
0000ac  f7fffffe          BL       move_window
0000b0  b100              CBZ      r0,|L25.180|
0000b2  e013              B        |L25.220|
                  |L25.180|
0000b4  f24010ff          MOV      r0,#0x1ff             ;850
0000b8  ea000184          AND      r1,r0,r4,LSL #2       ;850
0000bc  f1050028          ADD      r0,r5,#0x28           ;850
0000c0  180e              ADDS     r6,r1,r0              ;850
0000c2  78f0              LDRB     r0,[r6,#3]            ;851
0000c4  0600              LSLS     r0,r0,#24             ;851
0000c6  78b1              LDRB     r1,[r6,#2]            ;851
0000c8  ea404001          ORR      r0,r0,r1,LSL #16      ;851
0000cc  7871              LDRB     r1,[r6,#1]            ;851
0000ce  ea402001          ORR      r0,r0,r1,LSL #8       ;851
0000d2  7831              LDRB     r1,[r6,#0]            ;851
0000d4  4308              ORRS     r0,r0,r1              ;851
0000d6  f0204070          BIC      r0,r0,#0xf0000000     ;851
0000da  e79b              B        |L25.20|
                  |L25.220|
0000dc  bf00              NOP                            ;837
0000de  f04f30ff          MOV      r0,#0xffffffff        ;854
0000e2  e797              B        |L25.20|
;;;856    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1874   static
;;;1875   void get_fileinfo (		/* No return code */
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1876   	DIR *dj,			/* Pointer to the directory object */
;;;1877   	FILINFO *fno	 	/* Pointer to the file information to be filled */
;;;1878   )
;;;1879   {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
;;;1880   	UINT i;
;;;1881   	BYTE nt, *dir;
;;;1882   	TCHAR *p, c;
;;;1883   
;;;1884   
;;;1885   	p = fno->fname;
000008  f1060809          ADD      r8,r6,#9
;;;1886   	if (dj->sect) {
00000c  f8d90010          LDR      r0,[r9,#0x10]
000010  2800              CMP      r0,#0
000012  d051              BEQ      |L26.184|
;;;1887   		dir = dj->dir;
000014  f8d94014          LDR      r4,[r9,#0x14]
;;;1888   		nt = dir[DIR_NTres];		/* NT flag */
000018  7b20              LDRB     r0,[r4,#0xc]
00001a  9001              STR      r0,[sp,#4]
;;;1889   		for (i = 0; i < 8; i++) {	/* Copy name body */
00001c  2700              MOVS     r7,#0
00001e  e014              B        |L26.74|
                  |L26.32|
;;;1890   			c = dir[i];
000020  5de5              LDRB     r5,[r4,r7]
;;;1891   			if (c == ' ') break;
000022  2d20              CMP      r5,#0x20
000024  d100              BNE      |L26.40|
000026  e012              B        |L26.78|
                  |L26.40|
;;;1892   			if (c == NDDE) c = (TCHAR)DDE;
000028  2d05              CMP      r5,#5
00002a  d100              BNE      |L26.46|
00002c  25e5              MOVS     r5,#0xe5
                  |L26.46|
;;;1893   			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
00002e  9801              LDR      r0,[sp,#4]
000030  f0000008          AND      r0,r0,#8
000034  b130              CBZ      r0,|L26.68|
000036  2d41              CMP      r5,#0x41
000038  db04              BLT      |L26.68|
00003a  2d5a              CMP      r5,#0x5a
00003c  dc02              BGT      |L26.68|
00003e  f1050020          ADD      r0,r5,#0x20
000042  b2c5              UXTB     r5,r0
                  |L26.68|
;;;1894   #if _LFN_UNICODE
;;;1895   			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
;;;1896   				c = (c << 8) | dir[++i];
;;;1897   			c = ff_convert(c, 1);
;;;1898   			if (!c) c = '?';
;;;1899   #endif
;;;1900   			*p++ = c;
000044  f8085b01          STRB     r5,[r8],#1
000048  1c7f              ADDS     r7,r7,#1              ;1889
                  |L26.74|
00004a  2f08              CMP      r7,#8                 ;1889
00004c  d3e8              BCC      |L26.32|
                  |L26.78|
00004e  bf00              NOP                            ;1891
;;;1901   		}
;;;1902   		if (dir[8] != ' ') {		/* Copy name extension */
000050  7a20              LDRB     r0,[r4,#8]
000052  2820              CMP      r0,#0x20
000054  d019              BEQ      |L26.138|
;;;1903   			*p++ = '.';
000056  202e              MOVS     r0,#0x2e
000058  f8080b01          STRB     r0,[r8],#1
;;;1904   			for (i = 8; i < 11; i++) {
00005c  2708              MOVS     r7,#8
00005e  e011              B        |L26.132|
                  |L26.96|
;;;1905   				c = dir[i];
000060  5de5              LDRB     r5,[r4,r7]
;;;1906   				if (c == ' ') break;
000062  2d20              CMP      r5,#0x20
000064  d100              BNE      |L26.104|
000066  e00f              B        |L26.136|
                  |L26.104|
;;;1907   				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
000068  9801              LDR      r0,[sp,#4]
00006a  f0000010          AND      r0,r0,#0x10
00006e  b130              CBZ      r0,|L26.126|
000070  2d41              CMP      r5,#0x41
000072  db04              BLT      |L26.126|
000074  2d5a              CMP      r5,#0x5a
000076  dc02              BGT      |L26.126|
000078  f1050020          ADD      r0,r5,#0x20
00007c  b2c5              UXTB     r5,r0
                  |L26.126|
;;;1908   #if _LFN_UNICODE
;;;1909   				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
;;;1910   					c = (c << 8) | dir[++i];
;;;1911   				c = ff_convert(c, 1);
;;;1912   				if (!c) c = '?';
;;;1913   #endif
;;;1914   				*p++ = c;
00007e  f8085b01          STRB     r5,[r8],#1
000082  1c7f              ADDS     r7,r7,#1              ;1904
                  |L26.132|
000084  2f0b              CMP      r7,#0xb               ;1904
000086  d3eb              BCC      |L26.96|
                  |L26.136|
000088  bf00              NOP                            ;1906
                  |L26.138|
;;;1915   			}
;;;1916   		}
;;;1917   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
00008a  7ae0              LDRB     r0,[r4,#0xb]
00008c  7230              STRB     r0,[r6,#8]
;;;1918   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
00008e  7fe0              LDRB     r0,[r4,#0x1f]
000090  0601              LSLS     r1,r0,#24
000092  7fa0              LDRB     r0,[r4,#0x1e]
000094  ea414100          ORR      r1,r1,r0,LSL #16
000098  7f60              LDRB     r0,[r4,#0x1d]
00009a  ea412000          ORR      r0,r1,r0,LSL #8
00009e  7f21              LDRB     r1,[r4,#0x1c]
0000a0  4308              ORRS     r0,r0,r1
0000a2  6030              STR      r0,[r6,#0]
;;;1919   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
0000a4  7e21              LDRB     r1,[r4,#0x18]
0000a6  7e60              LDRB     r0,[r4,#0x19]
0000a8  ea412000          ORR      r0,r1,r0,LSL #8
0000ac  80b0              STRH     r0,[r6,#4]
;;;1920   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
0000ae  7da1              LDRB     r1,[r4,#0x16]
0000b0  7de0              LDRB     r0,[r4,#0x17]
0000b2  ea412000          ORR      r0,r1,r0,LSL #8
0000b6  80f0              STRH     r0,[r6,#6]
                  |L26.184|
;;;1921   	}
;;;1922   	*p = 0;		/* Terminate SFN str by a \0 */
0000b8  2000              MOVS     r0,#0
0000ba  f8880000          STRB     r0,[r8,#0]
;;;1923   
;;;1924   #if _USE_LFN
;;;1925   	if (fno->lfname && fno->lfsize) {
0000be  69b0              LDR      r0,[r6,#0x18]
0000c0  b380              CBZ      r0,|L26.292|
0000c2  69f0              LDR      r0,[r6,#0x1c]
0000c4  b370              CBZ      r0,|L26.292|
;;;1926   		TCHAR *tp = fno->lfname;
0000c6  69b0              LDR      r0,[r6,#0x18]
0000c8  9000              STR      r0,[sp,#0]
;;;1927   		WCHAR w, *lfn;
;;;1928   
;;;1929   		i = 0;
0000ca  2700              MOVS     r7,#0
;;;1930   		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
0000cc  f8d90010          LDR      r0,[r9,#0x10]
0000d0  b320              CBZ      r0,|L26.284|
0000d2  f8b90020          LDRH     r0,[r9,#0x20]
0000d6  f64f71ff          MOV      r1,#0xffff
0000da  4288              CMP      r0,r1
0000dc  d01e              BEQ      |L26.284|
;;;1931   			lfn = dj->lfn;
0000de  f8d9b01c          LDR      r11,[r9,#0x1c]
;;;1932   			while ((w = *lfn++) != 0) {			/* Get an LFN char */
0000e2  e015              B        |L26.272|
                  |L26.228|
;;;1933   #if !_LFN_UNICODE
;;;1934   				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
0000e4  2100              MOVS     r1,#0
0000e6  4650              MOV      r0,r10
0000e8  f7fffffe          BL       ff_convert
0000ec  4682              MOV      r10,r0
;;;1935   				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
0000ee  f1ba0f00          CMP      r10,#0
0000f2  d101              BNE      |L26.248|
0000f4  2700              MOVS     r7,#0
0000f6  e010              B        |L26.282|
                  |L26.248|
;;;1936   				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
0000f8  bf00              NOP      
;;;1937   					tp[i++] = (TCHAR)(w >> 8);
;;;1938   #endif
;;;1939   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
0000fa  69f0              LDR      r0,[r6,#0x1c]
0000fc  1e40              SUBS     r0,r0,#1
0000fe  42b8              CMP      r0,r7
000100  d801              BHI      |L26.262|
000102  2700              MOVS     r7,#0
000104  e009              B        |L26.282|
                  |L26.262|
;;;1940   				tp[i++] = (TCHAR)w;
000106  4638              MOV      r0,r7
000108  1c7f              ADDS     r7,r7,#1
00010a  9900              LDR      r1,[sp,#0]
00010c  f801a000          STRB     r10,[r1,r0]
                  |L26.272|
000110  f83b1b02          LDRH     r1,[r11],#2           ;1932
000114  f1b10a00          SUBS     r10,r1,#0             ;1932
000118  d1e4              BNE      |L26.228|
                  |L26.282|
00011a  bf00              NOP                            ;1935
                  |L26.284|
;;;1941   			}
;;;1942   		}
;;;1943   		tp[i] = 0;	/* Terminate the LFN str by a \0 */
00011c  2100              MOVS     r1,#0
00011e  9800              LDR      r0,[sp,#0]
000120  55c1              STRB     r1,[r0,r7]
;;;1944   	}
000122  bf00              NOP      
                  |L26.292|
;;;1945   #endif
;;;1946   }
000124  e8bd9ffc          POP      {r2-r12,pc}
;;;1947   #endif /* _FS_MINIMIZE <= 1 */
                          ENDP


                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1183   static
;;;1184   DWORD ld_clust (
000000  b510              PUSH     {r4,lr}
;;;1185   	FATFS *fs,	/* Pointer to the fs object */
;;;1186   	BYTE *dir	/* Pointer to the directory entry */
;;;1187   )
;;;1188   {
000002  4602              MOV      r2,r0
;;;1189   	DWORD cl;
;;;1190   
;;;1191   	cl = LD_WORD(dir+DIR_FstClusLO);
000004  7e8c              LDRB     r4,[r1,#0x1a]
000006  7ecb              LDRB     r3,[r1,#0x1b]
000008  ea442003          ORR      r0,r4,r3,LSL #8
;;;1192   	if (fs->fs_type == FS_FAT32)
00000c  7813              LDRB     r3,[r2,#0]
00000e  2b03              CMP      r3,#3
000010  d105              BNE      |L27.30|
;;;1193   		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
000012  7d0c              LDRB     r4,[r1,#0x14]
000014  7d4b              LDRB     r3,[r1,#0x15]
000016  ea442303          ORR      r3,r4,r3,LSL #8
00001a  ea404003          ORR      r0,r0,r3,LSL #16
                  |L27.30|
;;;1194   
;;;1195   	return cl;
;;;1196   }
00001e  bd10              POP      {r4,pc}
;;;1197   
                          ENDP


                          AREA ||i.mem_cmp||, CODE, READONLY, ALIGN=1

                  mem_cmp PROC
;;;556    static
;;;557    int mem_cmp (const void* dst, const void* src, UINT cnt) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
;;;558    	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
000004  461c              MOV      r4,r3
000006  460d              MOV      r5,r1
;;;559    	int r = 0;
000008  2000              MOVS     r0,#0
;;;560    
;;;561    	while (cnt-- && (r = *d++ - *s++) == 0) ;
00000a  bf00              NOP      
                  |L28.12|
00000c  1e16              SUBS     r6,r2,#0
00000e  f1a20201          SUB      r2,r2,#1
000012  d007              BEQ      |L28.36|
000014  f8147b01          LDRB     r7,[r4],#1
000018  f815cb01          LDRB     r12,[r5],#1
00001c  eba7060c          SUB      r6,r7,r12
000020  1e30              SUBS     r0,r6,#0
000022  d0f3              BEQ      |L28.12|
                  |L28.36|
;;;562    	return r;
;;;563    }
000024  bdf0              POP      {r4-r7,pc}
;;;564    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;530    static
;;;531    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  b570              PUSH     {r4-r6,lr}
;;;532    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;533    	const BYTE *s = (const BYTE*)src;
000004  460c              MOV      r4,r1
;;;534    
;;;535    #if _WORD_ACCESS == 1
;;;536    	while (cnt >= sizeof (int)) {
;;;537    		*(int*)d = *(int*)s;
;;;538    		d += sizeof (int); s += sizeof (int);
;;;539    		cnt -= sizeof (int);
;;;540    	}
;;;541    #endif
;;;542    	while (cnt--)
000006  e003              B        |L29.16|
                  |L29.8|
;;;543    		*d++ = *s++;
000008  f8145b01          LDRB     r5,[r4],#1
00000c  f8035b01          STRB     r5,[r3],#1
                  |L29.16|
000010  1e15              SUBS     r5,r2,#0              ;542
000012  f1a20201          SUB      r2,r2,#1              ;542
000016  d1f7              BNE      |L29.8|
;;;544    }
000018  bd70              POP      {r4-r6,pc}
;;;545    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;547    static
;;;548    void mem_set (void* dst, int val, UINT cnt) {
000000  b530              PUSH     {r4,r5,lr}
;;;549    	BYTE *d = (BYTE*)dst;
000002  4603              MOV      r3,r0
;;;550    
;;;551    	while (cnt--)
000004  e001              B        |L30.10|
                  |L30.6|
;;;552    		*d++ = (BYTE)val;
000006  f8031b01          STRB     r1,[r3],#1
                  |L30.10|
00000a  1e14              SUBS     r4,r2,#0              ;551
00000c  f1a20201          SUB      r2,r2,#1              ;551
000010  d1f9              BNE      |L30.6|
;;;553    }
000012  bd30              POP      {r4,r5,pc}
;;;554    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;721    static
;;;722    FRESULT move_window (
000000  b570              PUSH     {r4-r6,lr}
;;;723    	FATFS *fs,		/* File system object */
;;;724    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;725    )					/* Move to zero only writes back dirty window */
;;;726    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;727    	DWORD wsect;
;;;728    
;;;729    
;;;730    	wsect = fs->winsect;
000006  6a66              LDR      r6,[r4,#0x24]
;;;731    	if (wsect != sector) {	/* Changed current window */
000008  42ae              CMP      r6,r5
00000a  d00b              BEQ      |L31.36|
;;;732    #if !_FS_READONLY
;;;733    		if (fs->wflag) {	/* Write back dirty window if needed */
;;;734    			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
;;;735    				return FR_DISK_ERR;
;;;736    			fs->wflag = 0;
;;;737    			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
;;;738    				BYTE nf;
;;;739    				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
;;;740    					wsect += fs->fsize;
;;;741    					disk_write(fs->drv, fs->win, wsect, 1);
;;;742    				}
;;;743    			}
;;;744    		}
;;;745    #endif
;;;746    		if (sector) {
00000c  b155              CBZ      r5,|L31.36|
;;;747    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
00000e  7860              LDRB     r0,[r4,#1]
000010  2301              MOVS     r3,#1
000012  462a              MOV      r2,r5
000014  f1040128          ADD      r1,r4,#0x28
000018  f7fffffe          BL       disk_read
00001c  b108              CBZ      r0,|L31.34|
;;;748    				return FR_DISK_ERR;
00001e  2001              MOVS     r0,#1
                  |L31.32|
;;;749    			fs->winsect = sector;
;;;750    		}
;;;751    	}
;;;752    
;;;753    	return FR_OK;
;;;754    }
000020  bd70              POP      {r4-r6,pc}
                  |L31.34|
000022  6265              STR      r5,[r4,#0x24]         ;749
                  |L31.36|
000024  2000              MOVS     r0,#0                 ;753
000026  e7fb              B        |L31.32|
;;;755    
                          ENDP


                          AREA ||i.pick_lfn||, CODE, READONLY, ALIGN=2

                  pick_lfn PROC
;;;1252   static
;;;1253   int pick_lfn (			/* 1:Succeeded, 0:Buffer overflow */
000000  b5f0              PUSH     {r4-r7,lr}
;;;1254   	WCHAR *lfnbuf,		/* Pointer to the Unicode-LFN buffer */
;;;1255   	BYTE *dir			/* Pointer to the directory entry */
;;;1256   )
;;;1257   {
000002  4603              MOV      r3,r0
;;;1258   	UINT i, s;
;;;1259   	WCHAR wc, uc;
;;;1260   
;;;1261   
;;;1262   	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
000004  7808              LDRB     r0,[r1,#0]
000006  f000003f          AND      r0,r0,#0x3f
00000a  1e40              SUBS     r0,r0,#1
00000c  eb000780          ADD      r7,r0,r0,LSL #2
000010  eb0702c0          ADD      r2,r7,r0,LSL #3
;;;1263   
;;;1264   	s = 0; wc = 1;
000014  2500              MOVS     r5,#0
000016  2601              MOVS     r6,#1
;;;1265   	do {
000018  bf00              NOP      
                  |L32.26|
;;;1266   		uc = LD_WORD(dir+LfnOfs[s]);		/* Pick an LFN character from the entry */
00001a  4815              LDR      r0,|L32.112|
00001c  5d40              LDRB     r0,[r0,r5]
00001e  5c08              LDRB     r0,[r1,r0]
000020  4f13              LDR      r7,|L32.112|
000022  5d7f              LDRB     r7,[r7,r5]
000024  440f              ADD      r7,r7,r1
000026  787f              LDRB     r7,[r7,#1]
000028  ea402407          ORR      r4,r0,r7,LSL #8
;;;1267   		if (wc) {	/* Last char has not been processed */
00002c  b14e              CBZ      r6,|L32.66|
;;;1268   			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
00002e  2aff              CMP      r2,#0xff
000030  d301              BCC      |L32.54|
000032  2000              MOVS     r0,#0
                  |L32.52|
;;;1269   			lfnbuf[i++] = wc = uc;			/* Store it */
;;;1270   		} else {
;;;1271   			if (uc != 0xFFFF) return 0;		/* Check filler */
;;;1272   		}
;;;1273   	} while (++s < 13);						/* Read all character in the entry */
;;;1274   
;;;1275   	if (dir[LDIR_Ord] & LLE) {				/* Put terminator if it is the last LFN part */
;;;1276   		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
;;;1277   		lfnbuf[i] = 0;
;;;1278   	}
;;;1279   
;;;1280   	return 1;
;;;1281   }
000034  bdf0              POP      {r4-r7,pc}
                  |L32.54|
000036  4626              MOV      r6,r4                 ;1269
000038  4610              MOV      r0,r2                 ;1269
00003a  1c52              ADDS     r2,r2,#1              ;1269
00003c  f8234010          STRH     r4,[r3,r0,LSL #1]     ;1269
000040  e005              B        |L32.78|
                  |L32.66|
000042  f64f70ff          MOV      r0,#0xffff            ;1271
000046  4284              CMP      r4,r0                 ;1271
000048  d001              BEQ      |L32.78|
00004a  2000              MOVS     r0,#0                 ;1271
00004c  e7f2              B        |L32.52|
                  |L32.78|
00004e  1c68              ADDS     r0,r5,#1              ;1273
000050  4605              MOV      r5,r0                 ;1273
000052  280d              CMP      r0,#0xd               ;1273
000054  d3e1              BCC      |L32.26|
000056  7808              LDRB     r0,[r1,#0]            ;1275
000058  f0000040          AND      r0,r0,#0x40           ;1275
00005c  b130              CBZ      r0,|L32.108|
00005e  2aff              CMP      r2,#0xff              ;1276
000060  d301              BCC      |L32.102|
000062  2000              MOVS     r0,#0                 ;1276
000064  e7e6              B        |L32.52|
                  |L32.102|
000066  2000              MOVS     r0,#0                 ;1277
000068  f8230012          STRH     r0,[r3,r2,LSL #1]     ;1277
                  |L32.108|
00006c  2001              MOVS     r0,#1                 ;1280
00006e  e7e1              B        |L32.52|
;;;1282   #endif
                          ENDP

                  |L32.112|
                          DCD      LfnOfs

                          AREA ||i.sum_sfn||, CODE, READONLY, ALIGN=1

                  sum_sfn PROC
;;;1369   static
;;;1370   BYTE sum_sfn (
000000  b530              PUSH     {r4,r5,lr}
;;;1371   	const BYTE *dir		/* Ptr to directory entry */
;;;1372   )
;;;1373   {
000002  4601              MOV      r1,r0
;;;1374   	BYTE sum = 0;
000004  2000              MOVS     r0,#0
;;;1375   	UINT n = 11;
000006  220b              MOVS     r2,#0xb
;;;1376   
;;;1377   	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
000008  bf00              NOP      
                  |L33.10|
00000a  1043              ASRS     r3,r0,#1
00000c  eb0314c0          ADD      r4,r3,r0,LSL #7
000010  f8115b01          LDRB     r5,[r1],#1
000014  1963              ADDS     r3,r4,r5
000016  b2d8              UXTB     r0,r3
000018  1e53              SUBS     r3,r2,#1
00001a  1e1a              SUBS     r2,r3,#0
00001c  d1f5              BNE      |L33.10|
;;;1378   	return sum;
;;;1379   }
00001e  bd30              POP      {r4,r5,pc}
;;;1380   #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2211   static
;;;2212   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b570              PUSH     {r4-r6,lr}
;;;2213   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2214   )
;;;2215   {
000002  4605              MOV      r5,r0
;;;2216   	FIL *fil;
;;;2217   
;;;2218   	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
000004  462c              MOV      r4,r5
;;;2219   	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
000006  6820              LDR      r0,[r4,#0]
000008  b138              CBZ      r0,|L34.26|
00000a  6820              LDR      r0,[r4,#0]
00000c  7800              LDRB     r0,[r0,#0]
00000e  b120              CBZ      r0,|L34.26|
000010  6820              LDR      r0,[r4,#0]
000012  88c0              LDRH     r0,[r0,#6]
000014  88a1              LDRH     r1,[r4,#4]
000016  4288              CMP      r0,r1
000018  d001              BEQ      |L34.30|
                  |L34.26|
;;;2220   		return FR_INVALID_OBJECT;
00001a  2009              MOVS     r0,#9
                  |L34.28|
;;;2221   
;;;2222   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2223   
;;;2224   	if (disk_status(fil->fs->drv) & STA_NOINIT)
;;;2225   		return FR_NOT_READY;
;;;2226   
;;;2227   	return FR_OK;
;;;2228   }
00001c  bd70              POP      {r4-r6,pc}
                  |L34.30|
00001e  6821              LDR      r1,[r4,#0]            ;2224
000020  7848              LDRB     r0,[r1,#1]            ;2224
000022  f7fffffe          BL       disk_status
000026  f0000001          AND      r0,r0,#1              ;2224
00002a  b108              CBZ      r0,|L34.48|
00002c  2003              MOVS     r0,#3                 ;2225
00002e  e7f5              B        |L34.28|
                  |L34.48|
000030  2000              MOVS     r0,#0                 ;2227
000032  e7f3              B        |L34.28|
;;;2229   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  LfnOfs
000000  01030507          DCB      0x01,0x03,0x05,0x07
000004  090e1012          DCB      0x09,0x0e,0x10,0x12
000008  1416181c          DCB      0x14,0x16,0x18,0x1c
00000c  1e                DCB      0x1e
                  excvt
00000d  808182            DCB      0x80,0x81,0x82
000010  83848586          DCB      0x83,0x84,0x85,0x86
000014  8788898a          DCB      0x87,0x88,0x89,0x8a
000018  8b8c8d8e          DCB      0x8b,0x8c,0x8d,0x8e
00001c  8f909192          DCB      0x8f,0x90,0x91,0x92
000020  93949596          DCB      0x93,0x94,0x95,0x96
000024  9798998a          DCB      0x97,0x98,0x99,0x8a
000028  9b8c8d8e          DCB      0x9b,0x8c,0x8d,0x8e
00002c  8fa0a1a2          DCB      0x8f,0xa0,0xa1,0xa2
000030  a3a4a5a6          DCB      0xa3,0xa4,0xa5,0xa6
000034  a7a8a9aa          DCB      0xa7,0xa8,0xa9,0xaa
000038  abacadae          DCB      0xab,0xac,0xad,0xae
00003c  afb0b1b2          DCB      0xaf,0xb0,0xb1,0xb2
000040  a3b4b5b6          DCB      0xa3,0xb4,0xb5,0xb6
000044  b7b8a5aa          DCB      0xb7,0xb8,0xa5,0xaa
000048  bbbcbdbc          DCB      0xbb,0xbc,0xbd,0xbc
00004c  afc0c1c2          DCB      0xaf,0xc0,0xc1,0xc2
000050  c3c4c5c6          DCB      0xc3,0xc4,0xc5,0xc6
000054  c7c8c9ca          DCB      0xc7,0xc8,0xc9,0xca
000058  cbcccdce          DCB      0xcb,0xcc,0xcd,0xce
00005c  cfd0d1d2          DCB      0xcf,0xd0,0xd1,0xd2
000060  d3d4d5d6          DCB      0xd3,0xd4,0xd5,0xd6
000064  d7d8d9da          DCB      0xd7,0xd8,0xd9,0xda
000068  dbdcddde          DCB      0xdb,0xdc,0xdd,0xde
00006c  dfc0c1c2          DCB      0xdf,0xc0,0xc1,0xc2
000070  c3c4c5c6          DCB      0xc3,0xc4,0xc5,0xc6
000074  c7c8c9ca          DCB      0xc7,0xc8,0xc9,0xca
000078  cbcccdce          DCB      0xcb,0xcc,0xcd,0xce
00007c  cfd0d1d2          DCB      0xcf,0xd0,0xd1,0xd2
000080  d3d4d5d6          DCB      0xd3,0xd4,0xd5,0xd6
000084  f7d8d9da          DCB      0xf7,0xd8,0xd9,0xda
000088  dbdcddde          DCB      0xdb,0xdc,0xdd,0xde
00008c  ff                DCB      0xff

                          AREA ||.data||, DATA, ALIGN=2

                  FatFs
                          %        8
                  Fsid
000008  0000              DCB      0x00,0x00
                  CurrVol
00000a  00                DCB      0x00
